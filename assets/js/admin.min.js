"use strict";

function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.In order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
jQuery(document).ready(function ($) {
// AjaxQ jQuery Plugin
// Copyright (c) 2012 Foliotek Inc.
// MIT License
// https://github.com/Foliotek/ajaxq
// Uses CommonJS, AMD or browser globals to create a jQuery plugin.
(function (factory) {
if (typeof define === 'function' && define.amd) {
// AMD. Register as an anonymous module.
define(['jquery'], factory);
} else if ((typeof module === "undefined" ? "undefined" : _typeof(module)) === 'object' && module.exports) {
// Node/CommonJS
module.exports = factory(require('jquery'));
} else {
// Browser globals
factory(jQuery);
}
})(function ($) {
var queues = {};
var activeReqs = {};

// Register an $.ajaxq function, which follows the $.ajax interface, but allows a queue name which will force only one request per queue to fire.
// opts can be the regular $.ajax settings plainObject, or a callback returning the settings object, to be evaluated just prior to the actual call to $.ajax.
$.ajaxq = function (qname, opts) {
if (typeof opts === "undefined") {
throw "AjaxQ: queue name is not provided";
}

// Will return a Deferred promise object extended with success/error/callback, so that this function matches the interface of $.ajax
var deferred = $.Deferred(),
promise = deferred.promise();
promise.success = promise.done;
promise.error = promise.fail;
promise.complete = promise.always;

// Check whether options are to be evaluated at call time or not.
var deferredOpts = typeof opts === 'function';
// Create a deep copy of the arguments, and enqueue this request.
var clonedOptions = !deferredOpts ? $.extend(true, {}, opts) : null;
enqueue(function () {
// Send off the ajax request now that the item has been removed from the queue
var jqXHR = $.ajax.apply(window, [deferredOpts ? opts() : clonedOptions]);

// Notify the returned deferred object with the correct context when the jqXHR is done or fails
// Note that 'always' will automatically be fired once one of these are called: http://api.jquery.com/category/deferred-object/.
jqXHR.done(function () {
deferred.resolve.apply(this, arguments);
});
jqXHR.fail(function () {
deferred.reject.apply(this, arguments);
});
jqXHR.always(dequeue); // make sure to dequeue the next request AFTER the done and fail callbacks are fired

return jqXHR;
});
return promise;

// If there is no queue, create an empty one and instantly process this item.
// Otherwise, just add this item onto it for later processing.
function enqueue(cb) {
if (!queues[qname]) {
queues[qname] = [];
var xhr = cb();
activeReqs[qname] = xhr;
} else {
queues[qname].push(cb);
}
}

// Remove the next callback from the queue and fire it off.
// If the queue was empty (this was the last item), delete it from memory so the next one can be instantly processed.
function dequeue() {
if (!queues[qname]) {
return;
}
var nextCallback = queues[qname].shift();
if (nextCallback) {
var xhr = nextCallback();
activeReqs[qname] = xhr;
} else {
delete queues[qname];
delete activeReqs[qname];
}
}
};

// Register a $.postq and $.getq method to provide shortcuts for $.get and $.post
// Copied from jQuery source to make sure the functions share the same defaults as $.get and $.post.
$.each(["getq", "postq"], function (i, method) {
$[method] = function (qname, url, data, callback, type) {
if ($.isFunction(data)) {
type = type || callback;
callback = data;
data = undefined;
}
return $.ajaxq(qname, {
type: method === "postq" ? "post" : "get",
url: url,
data: data,
success: callback,
dataType: type
});
};
});
var isQueueRunning = function isQueueRunning(qname) {
return queues.hasOwnProperty(qname) && queues[qname].length > 0 || activeReqs.hasOwnProperty(qname);
};
var isAnyQueueRunning = function isAnyQueueRunning() {
for (var i in queues) {
if (isQueueRunning(i)) return true;
}
return false;
};
$.ajaxq.isRunning = function (qname) {
if (qname) return isQueueRunning(qname);else return isAnyQueueRunning();
};
$.ajaxq.getActiveRequest = function (qname) {
if (!qname) throw "AjaxQ: queue name is required";
return activeReqs[qname];
};
$.ajaxq.abort = function (qname) {
if (!qname) throw "AjaxQ: queue name is required";
var current = $.ajaxq.getActiveRequest(qname);
delete queues[qname];
delete activeReqs[qname];
if (current) current.abort();
};
$.ajaxq.clear = function (qname) {
if (!qname) {
for (var i in queues) {
if (queues.hasOwnProperty(i)) {
queues[i] = [];
}
}
} else {
if (queues[qname]) {
queues[qname] = [];
}
}
};
});

/*!
 * chartjs-adapter-date-fns v3.0.0
 * https://www.chartjs.org
 * (c) 2022 chartjs-adapter-date-fns Contributors
 * Released under the MIT license
 */
!function (t, e) {
"object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? e(require("chart.js")) : "function" == typeof define && define.amd ? define(["chart.js"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).Chart);
}(this, function (t) {
"use strict";

function e(t) {
if (null === t || !0 === t || !1 === t) return NaN;
var e = Number(t);
return isNaN(e) ? e : e < 0 ? Math.ceil(e) : Math.floor(e);
}
function r(t, e) {
if (e.length < t) throw new TypeError(t + " argument" + (t > 1 ? "s" : "") + " required, but only " + e.length + " present");
}
function n(t) {
r(1, arguments);
var e = Object.prototype.toString.call(t);
return t instanceof Date || "object" == _typeof(t) && "[object Date]" === e ? new Date(t.getTime()) : "number" == typeof t || "[object Number]" === e ? new Date(t) : ("string" != typeof t && "[object String]" !== e || "undefined" == typeof console || (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"), console.warn(new Error().stack)), new Date(NaN));
}
function a(t, a) {
r(2, arguments);
var i = n(t),
o = e(a);
return isNaN(o) ? new Date(NaN) : o ? (i.setDate(i.getDate() + o), i) : i;
}
function i(t, a) {
r(2, arguments);
var i = n(t),
o = e(a);
if (isNaN(o)) return new Date(NaN);
if (!o) return i;
var u = i.getDate(),
s = new Date(i.getTime());
s.setMonth(i.getMonth() + o + 1, 0);
var c = s.getDate();
return u >= c ? s : (i.setFullYear(s.getFullYear(), s.getMonth(), u), i);
}
function o(t, a) {
r(2, arguments);
var i = n(t).getTime(),
o = e(a);
return new Date(i + o);
}
var u = 36e5;
function s(t, a) {
r(1, arguments);
var i = a || {},
o = i.locale,
u = o && o.options && o.options.weekStartsOn,
s = null == u ? 0 : e(u),
c = null == i.weekStartsOn ? s : e(i.weekStartsOn);
if (!(c >= 0 && c <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
var d = n(t),
l = d.getDay(),
f = (l < c ? 7 : 0) + l - c;
return d.setDate(d.getDate() - f), d.setHours(0, 0, 0, 0), d;
}
function c(t) {
var e = new Date(Date.UTC(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds()));
return e.setUTCFullYear(t.getFullYear()), t.getTime() - e.getTime();
}
function d(t) {
r(1, arguments);
var e = n(t);
return e.setHours(0, 0, 0, 0), e;
}
var l = 864e5;
function f(t, e) {
r(2, arguments);
var n = d(t),
a = d(e),
i = n.getTime() - c(n),
o = a.getTime() - c(a);
return Math.round((i - o) / l);
}
function h(t, e) {
r(2, arguments);
var a = n(t),
i = n(e),
o = a.getTime() - i.getTime();
return o < 0 ? -1 : o > 0 ? 1 : o;
}
function m(t) {
r(1, arguments);
var e = n(t);
return !isNaN(e);
}
function w(t, e) {
r(2, arguments);
var a = n(t),
i = n(e),
o = a.getFullYear() - i.getFullYear(),
u = a.getMonth() - i.getMonth();
return 12 * o + u;
}
function g(t, e) {
r(2, arguments);
var a = n(t),
i = n(e);
return a.getFullYear() - i.getFullYear();
}
function v(t, e) {
var r = t.getFullYear() - e.getFullYear() || t.getMonth() - e.getMonth() || t.getDate() - e.getDate() || t.getHours() - e.getHours() || t.getMinutes() - e.getMinutes() || t.getSeconds() - e.getSeconds() || t.getMilliseconds() - e.getMilliseconds();
return r < 0 ? -1 : r > 0 ? 1 : r;
}
function y(t, e) {
r(2, arguments);
var a = n(t),
i = n(e),
o = v(a, i),
u = Math.abs(f(a, i));
a.setDate(a.getDate() - o * u);
var s = v(a, i) === -o,
c = o * (u - s);
return 0 === c ? 0 : c;
}
function b(t, e) {
r(2, arguments);
var a = n(t),
i = n(e);
return a.getTime() - i.getTime();
}
var T = 36e5;
function p(t) {
r(1, arguments);
var e = n(t);
return e.setHours(23, 59, 59, 999), e;
}
function C(t) {
r(1, arguments);
var e = n(t),
a = e.getMonth();
return e.setFullYear(e.getFullYear(), a + 1, 0), e.setHours(23, 59, 59, 999), e;
}
function M(t) {
r(1, arguments);
var e = n(t);
return p(e).getTime() === C(e).getTime();
}
function D(t, e) {
r(2, arguments);
var a,
i = n(t),
o = n(e),
u = h(i, o),
s = Math.abs(w(i, o));
if (s < 1) a = 0;else {
1 === i.getMonth() && i.getDate() > 27 && i.setDate(30), i.setMonth(i.getMonth() - u * s);
var c = h(i, o) === -u;
M(n(t)) && 1 === s && 1 === h(t, o) && (c = !1), a = u * (s - c);
}
return 0 === a ? 0 : a;
}
var x = {
lessThanXSeconds: {
one: "less than a second",
other: "less than {{count}} seconds"
},
xSeconds: {
one: "1 second",
other: "{{count}} seconds"
},
halfAMinute: "half a minute",
lessThanXMinutes: {
one: "less than a minute",
other: "less than {{count}} minutes"
},
xMinutes: {
one: "1 minute",
other: "{{count}} minutes"
},
aboutXHours: {
one: "about 1 hour",
other: "about {{count}} hours"
},
xHours: {
one: "1 hour",
other: "{{count}} hours"
},
xDays: {
one: "1 day",
other: "{{count}} days"
},
aboutXWeeks: {
one: "about 1 week",
other: "about {{count}} weeks"
},
xWeeks: {
one: "1 week",
other: "{{count}} weeks"
},
aboutXMonths: {
one: "about 1 month",
other: "about {{count}} months"
},
xMonths: {
one: "1 month",
other: "{{count}} months"
},
aboutXYears: {
one: "about 1 year",
other: "about {{count}} years"
},
xYears: {
one: "1 year",
other: "{{count}} years"
},
overXYears: {
one: "over 1 year",
other: "over {{count}} years"
},
almostXYears: {
one: "almost 1 year",
other: "almost {{count}} years"
}
};
function k(t) {
return function (e) {
var r = e || {},
n = r.width ? String(r.width) : t.defaultWidth;
return t.formats[n] || t.formats[t.defaultWidth];
};
}
var U = {
date: k({
formats: {
full: "EEEE, MMMM do, y",
"long": "MMMM do, y",
medium: "MMM d, y",
"short": "MM/dd/yyyy"
},
defaultWidth: "full"
}),
time: k({
formats: {
full: "h:mm:ss a zzzz",
"long": "h:mm:ss a z",
medium: "h:mm:ss a",
"short": "h:mm a"
},
defaultWidth: "full"
}),
dateTime: k({
formats: {
full: "{{date}} 'at' {{time}}",
"long": "{{date}} 'at' {{time}}",
medium: "{{date}}, {{time}}",
"short": "{{date}}, {{time}}"
},
defaultWidth: "full"
})
},
Y = {
lastWeek: "'last' eeee 'at' p",
yesterday: "'yesterday at' p",
today: "'today at' p",
tomorrow: "'tomorrow at' p",
nextWeek: "eeee 'at' p",
other: "P"
};
function N(t) {
return function (e, r) {
var n,
a = r || {};
if ("formatting" === (a.context ? String(a.context) : "standalone") && t.formattingValues) {
var i = t.defaultFormattingWidth || t.defaultWidth,
o = a.width ? String(a.width) : i;
n = t.formattingValues[o] || t.formattingValues[i];
} else {
var u = t.defaultWidth,
s = a.width ? String(a.width) : t.defaultWidth;
n = t.values[s] || t.values[u];
}
return n[t.argumentCallback ? t.argumentCallback(e) : e];
};
}
function S(t) {
return function (e, r) {
var n = String(e),
a = r || {},
i = a.width,
o = i && t.matchPatterns[i] || t.matchPatterns[t.defaultMatchWidth],
u = n.match(o);
if (!u) return null;
var s,
c = u[0],
d = i && t.parsePatterns[i] || t.parsePatterns[t.defaultParseWidth];
return s = "[object Array]" === Object.prototype.toString.call(d) ? function (t, e) {
for (var r = 0; r < t.length; r++) if (e(t[r])) return r;
}(d, function (t) {
return t.test(c);
}) : function (t, e) {
for (var r in t) if (t.hasOwnProperty(r) && e(t[r])) return r;
}(d, function (t) {
return t.test(c);
}), s = t.valueCallback ? t.valueCallback(s) : s, {
value: s = a.valueCallback ? a.valueCallback(s) : s,
rest: n.slice(c.length)
};
};
}
var P,
q = {
code: "en-US",
formatDistance: function formatDistance(t, e, r) {
var n;
return r = r || {}, n = "string" == typeof x[t] ? x[t] : 1 === e ? x[t].one : x[t].other.replace("{{count}}", e), r.addSuffix ? r.comparison > 0 ? "in " + n : n + " ago" : n;
},
formatLong: U,
formatRelative: function formatRelative(t, e, r, n) {
return Y[t];
},
localize: {
ordinalNumber: function ordinalNumber(t, e) {
var r = Number(t),
n = r % 100;
if (n > 20 || n < 10) switch (n % 10) {
case 1:
return r + "st";
case 2:
return r + "nd";
case 3:
return r + "rd";
}
return r + "th";
},
era: N({
values: {
narrow: ["B", "A"],
abbreviated: ["BC", "AD"],
wide: ["Before Christ", "Anno Domini"]
},
defaultWidth: "wide"
}),
quarter: N({
values: {
narrow: ["1", "2", "3", "4"],
abbreviated: ["Q1", "Q2", "Q3", "Q4"],
wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
},
defaultWidth: "wide",
argumentCallback: function argumentCallback(t) {
return Number(t) - 1;
}
}),
month: N({
values: {
narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
},
defaultWidth: "wide"
}),
day: N({
values: {
narrow: ["S", "M", "T", "W", "T", "F", "S"],
"short": ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
},
defaultWidth: "wide"
}),
dayPeriod: N({
values: {
narrow: {
am: "a",
pm: "p",
midnight: "mi",
noon: "n",
morning: "morning",
afternoon: "afternoon",
evening: "evening",
night: "night"
},
abbreviated: {
am: "AM",
pm: "PM",
midnight: "midnight",
noon: "noon",
morning: "morning",
afternoon: "afternoon",
evening: "evening",
night: "night"
},
wide: {
am: "a.m.",
pm: "p.m.",
midnight: "midnight",
noon: "noon",
morning: "morning",
afternoon: "afternoon",
evening: "evening",
night: "night"
}
},
defaultWidth: "wide",
formattingValues: {
narrow: {
am: "a",
pm: "p",
midnight: "mi",
noon: "n",
morning: "in the morning",
afternoon: "in the afternoon",
evening: "in the evening",
night: "at night"
},
abbreviated: {
am: "AM",
pm: "PM",
midnight: "midnight",
noon: "noon",
morning: "in the morning",
afternoon: "in the afternoon",
evening: "in the evening",
night: "at night"
},
wide: {
am: "a.m.",
pm: "p.m.",
midnight: "midnight",
noon: "noon",
morning: "in the morning",
afternoon: "in the afternoon",
evening: "in the evening",
night: "at night"
}
},
defaultFormattingWidth: "wide"
})
},
match: {
ordinalNumber: (P = {
matchPattern: /^(\d+)(th|st|nd|rd)?/i,
parsePattern: /\d+/i,
valueCallback: function valueCallback(t) {
return parseInt(t, 10);
}
}, function (t, e) {
var r = String(t),
n = e || {},
a = r.match(P.matchPattern);
if (!a) return null;
var i = a[0],
o = r.match(P.parsePattern);
if (!o) return null;
var u = P.valueCallback ? P.valueCallback(o[0]) : o[0];
return {
value: u = n.valueCallback ? n.valueCallback(u) : u,
rest: r.slice(i.length)
};
}),
era: S({
matchPatterns: {
narrow: /^(b|a)/i,
abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
wide: /^(before christ|before common era|anno domini|common era)/i
},
defaultMatchWidth: "wide",
parsePatterns: {
any: [/^b/i, /^(a|c)/i]
},
defaultParseWidth: "any"
}),
quarter: S({
matchPatterns: {
narrow: /^[1234]/i,
abbreviated: /^q[1234]/i,
wide: /^[1234](th|st|nd|rd)? quarter/i
},
defaultMatchWidth: "wide",
parsePatterns: {
any: [/1/i, /2/i, /3/i, /4/i]
},
defaultParseWidth: "any",
valueCallback: function valueCallback(t) {
return t + 1;
}
}),
month: S({
matchPatterns: {
narrow: /^[jfmasond]/i,
abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
},
defaultMatchWidth: "wide",
parsePatterns: {
narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
},
defaultParseWidth: "any"
}),
day: S({
matchPatterns: {
narrow: /^[smtwf]/i,
"short": /^(su|mo|tu|we|th|fr|sa)/i,
abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
},
defaultMatchWidth: "wide",
parsePatterns: {
narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
},
defaultParseWidth: "any"
}),
dayPeriod: S({
matchPatterns: {
narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
},
defaultMatchWidth: "any",
parsePatterns: {
any: {
am: /^a/i,
pm: /^p/i,
midnight: /^mi/i,
noon: /^no/i,
morning: /morning/i,
afternoon: /afternoon/i,
evening: /evening/i,
night: /night/i
}
},
defaultParseWidth: "any"
})
},
options: {
weekStartsOn: 0,
firstWeekContainsDate: 1
}
};
function H(t, n) {
r(2, arguments);
var a = e(n);
return o(t, -a);
}
function E(t, e) {
for (var r = t < 0 ? "-" : "", n = Math.abs(t).toString(); n.length < e;) n = "0" + n;
return r + n;
}
var O = {
y: function y(t, e) {
var r = t.getUTCFullYear(),
n = r > 0 ? r : 1 - r;
return E("yy" === e ? n % 100 : n, e.length);
},
M: function M(t, e) {
var r = t.getUTCMonth();
return "M" === e ? String(r + 1) : E(r + 1, 2);
},
d: function d(t, e) {
return E(t.getUTCDate(), e.length);
},
a: function a(t, e) {
var r = t.getUTCHours() / 12 >= 1 ? "pm" : "am";
switch (e) {
case "a":
case "aa":
return r.toUpperCase();
case "aaa":
return r;
case "aaaaa":
return r[0];
default:
return "am" === r ? "a.m." : "p.m.";
}
},
h: function h(t, e) {
return E(t.getUTCHours() % 12 || 12, e.length);
},
H: function H(t, e) {
return E(t.getUTCHours(), e.length);
},
m: function m(t, e) {
return E(t.getUTCMinutes(), e.length);
},
s: function s(t, e) {
return E(t.getUTCSeconds(), e.length);
},
S: function S(t, e) {
var r = e.length,
n = t.getUTCMilliseconds();
return E(Math.floor(n * Math.pow(10, r - 3)), e.length);
}
},
F = 864e5;
function W(t) {
r(1, arguments);
var e = 1,
a = n(t),
i = a.getUTCDay(),
o = (i < e ? 7 : 0) + i - e;
return a.setUTCDate(a.getUTCDate() - o), a.setUTCHours(0, 0, 0, 0), a;
}
function L(t) {
r(1, arguments);
var e = n(t),
a = e.getUTCFullYear(),
i = new Date(0);
i.setUTCFullYear(a + 1, 0, 4), i.setUTCHours(0, 0, 0, 0);
var o = W(i),
u = new Date(0);
u.setUTCFullYear(a, 0, 4), u.setUTCHours(0, 0, 0, 0);
var s = W(u);
return e.getTime() >= o.getTime() ? a + 1 : e.getTime() >= s.getTime() ? a : a - 1;
}
function Q(t) {
r(1, arguments);
var e = L(t),
n = new Date(0);
n.setUTCFullYear(e, 0, 4), n.setUTCHours(0, 0, 0, 0);
var a = W(n);
return a;
}
var R = 6048e5;
function _I(t) {
r(1, arguments);
var e = n(t),
a = W(e).getTime() - Q(e).getTime();
return Math.round(a / R) + 1;
}
function G(t, a) {
r(1, arguments);
var i = a || {},
o = i.locale,
u = o && o.options && o.options.weekStartsOn,
s = null == u ? 0 : e(u),
c = null == i.weekStartsOn ? s : e(i.weekStartsOn);
if (!(c >= 0 && c <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
var d = n(t),
l = d.getUTCDay(),
f = (l < c ? 7 : 0) + l - c;
return d.setUTCDate(d.getUTCDate() - f), d.setUTCHours(0, 0, 0, 0), d;
}
function X(t, a) {
r(1, arguments);
var i = n(t, a),
o = i.getUTCFullYear(),
u = a || {},
s = u.locale,
c = s && s.options && s.options.firstWeekContainsDate,
d = null == c ? 1 : e(c),
l = null == u.firstWeekContainsDate ? d : e(u.firstWeekContainsDate);
if (!(l >= 1 && l <= 7)) throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
var f = new Date(0);
f.setUTCFullYear(o + 1, 0, l), f.setUTCHours(0, 0, 0, 0);
var h = G(f, a),
m = new Date(0);
m.setUTCFullYear(o, 0, l), m.setUTCHours(0, 0, 0, 0);
var w = G(m, a);
return i.getTime() >= h.getTime() ? o + 1 : i.getTime() >= w.getTime() ? o : o - 1;
}
function j(t, n) {
r(1, arguments);
var a = n || {},
i = a.locale,
o = i && i.options && i.options.firstWeekContainsDate,
u = null == o ? 1 : e(o),
s = null == a.firstWeekContainsDate ? u : e(a.firstWeekContainsDate),
c = X(t, n),
d = new Date(0);
d.setUTCFullYear(c, 0, s), d.setUTCHours(0, 0, 0, 0);
var l = G(d, n);
return l;
}
var B = 6048e5;
function z(t, e) {
r(1, arguments);
var a = n(t),
i = G(a, e).getTime() - j(a, e).getTime();
return Math.round(i / B) + 1;
}
var A = "midnight",
Z = "noon",
K = "morning",
$ = "afternoon",
_ = "evening",
J = "night",
V = {
G: function G(t, e, r) {
var n = t.getUTCFullYear() > 0 ? 1 : 0;
switch (e) {
case "G":
case "GG":
case "GGG":
return r.era(n, {
width: "abbreviated"
});
case "GGGGG":
return r.era(n, {
width: "narrow"
});
default:
return r.era(n, {
width: "wide"
});
}
},
y: function y(t, e, r) {
if ("yo" === e) {
var n = t.getUTCFullYear(),
a = n > 0 ? n : 1 - n;
return r.ordinalNumber(a, {
unit: "year"
});
}
return O.y(t, e);
},
Y: function Y(t, e, r, n) {
var a = X(t, n),
i = a > 0 ? a : 1 - a;
return "YY" === e ? E(i % 100, 2) : "Yo" === e ? r.ordinalNumber(i, {
unit: "year"
}) : E(i, e.length);
},
R: function R(t, e) {
return E(L(t), e.length);
},
u: function u(t, e) {
return E(t.getUTCFullYear(), e.length);
},
Q: function Q(t, e, r) {
var n = Math.ceil((t.getUTCMonth() + 1) / 3);
switch (e) {
case "Q":
return String(n);
case "QQ":
return E(n, 2);
case "Qo":
return r.ordinalNumber(n, {
unit: "quarter"
});
case "QQQ":
return r.quarter(n, {
width: "abbreviated",
context: "formatting"
});
case "QQQQQ":
return r.quarter(n, {
width: "narrow",
context: "formatting"
});
default:
return r.quarter(n, {
width: "wide",
context: "formatting"
});
}
},
q: function q(t, e, r) {
var n = Math.ceil((t.getUTCMonth() + 1) / 3);
switch (e) {
case "q":
return String(n);
case "qq":
return E(n, 2);
case "qo":
return r.ordinalNumber(n, {
unit: "quarter"
});
case "qqq":
return r.quarter(n, {
width: "abbreviated",
context: "standalone"
});
case "qqqqq":
return r.quarter(n, {
width: "narrow",
context: "standalone"
});
default:
return r.quarter(n, {
width: "wide",
context: "standalone"
});
}
},
M: function M(t, e, r) {
var n = t.getUTCMonth();
switch (e) {
case "M":
case "MM":
return O.M(t, e);
case "Mo":
return r.ordinalNumber(n + 1, {
unit: "month"
});
case "MMM":
return r.month(n, {
width: "abbreviated",
context: "formatting"
});
case "MMMMM":
return r.month(n, {
width: "narrow",
context: "formatting"
});
default:
return r.month(n, {
width: "wide",
context: "formatting"
});
}
},
L: function L(t, e, r) {
var n = t.getUTCMonth();
switch (e) {
case "L":
return String(n + 1);
case "LL":
return E(n + 1, 2);
case "Lo":
return r.ordinalNumber(n + 1, {
unit: "month"
});
case "LLL":
return r.month(n, {
width: "abbreviated",
context: "standalone"
});
case "LLLLL":
return r.month(n, {
width: "narrow",
context: "standalone"
});
default:
return r.month(n, {
width: "wide",
context: "standalone"
});
}
},
w: function w(t, e, r, n) {
var a = z(t, n);
return "wo" === e ? r.ordinalNumber(a, {
unit: "week"
}) : E(a, e.length);
},
I: function I(t, e, r) {
var n = _I(t);
return "Io" === e ? r.ordinalNumber(n, {
unit: "week"
}) : E(n, e.length);
},
d: function d(t, e, r) {
return "do" === e ? r.ordinalNumber(t.getUTCDate(), {
unit: "date"
}) : O.d(t, e);
},
D: function D(t, e, a) {
var i = function (t) {
r(1, arguments);
var e = n(t),
a = e.getTime();
e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
var i = e.getTime(),
o = a - i;
return Math.floor(o / F) + 1;
}(t);
return "Do" === e ? a.ordinalNumber(i, {
unit: "dayOfYear"
}) : E(i, e.length);
},
E: function E(t, e, r) {
var n = t.getUTCDay();
switch (e) {
case "E":
case "EE":
case "EEE":
return r.day(n, {
width: "abbreviated",
context: "formatting"
});
case "EEEEE":
return r.day(n, {
width: "narrow",
context: "formatting"
});
case "EEEEEE":
return r.day(n, {
width: "short",
context: "formatting"
});
default:
return r.day(n, {
width: "wide",
context: "formatting"
});
}
},
e: function e(t, _e, r, n) {
var a = t.getUTCDay(),
i = (a - n.weekStartsOn + 8) % 7 || 7;
switch (_e) {
case "e":
return String(i);
case "ee":
return E(i, 2);
case "eo":
return r.ordinalNumber(i, {
unit: "day"
});
case "eee":
return r.day(a, {
width: "abbreviated",
context: "formatting"
});
case "eeeee":
return r.day(a, {
width: "narrow",
context: "formatting"
});
case "eeeeee":
return r.day(a, {
width: "short",
context: "formatting"
});
default:
return r.day(a, {
width: "wide",
context: "formatting"
});
}
},
c: function c(t, e, r, n) {
var a = t.getUTCDay(),
i = (a - n.weekStartsOn + 8) % 7 || 7;
switch (e) {
case "c":
return String(i);
case "cc":
return E(i, e.length);
case "co":
return r.ordinalNumber(i, {
unit: "day"
});
case "ccc":
return r.day(a, {
width: "abbreviated",
context: "standalone"
});
case "ccccc":
return r.day(a, {
width: "narrow",
context: "standalone"
});
case "cccccc":
return r.day(a, {
width: "short",
context: "standalone"
});
default:
return r.day(a, {
width: "wide",
context: "standalone"
});
}
},
i: function i(t, e, r) {
var n = t.getUTCDay(),
a = 0 === n ? 7 : n;
switch (e) {
case "i":
return String(a);
case "ii":
return E(a, e.length);
case "io":
return r.ordinalNumber(a, {
unit: "day"
});
case "iii":
return r.day(n, {
width: "abbreviated",
context: "formatting"
});
case "iiiii":
return r.day(n, {
width: "narrow",
context: "formatting"
});
case "iiiiii":
return r.day(n, {
width: "short",
context: "formatting"
});
default:
return r.day(n, {
width: "wide",
context: "formatting"
});
}
},
a: function a(t, e, r) {
var n = t.getUTCHours() / 12 >= 1 ? "pm" : "am";
switch (e) {
case "a":
case "aa":
return r.dayPeriod(n, {
width: "abbreviated",
context: "formatting"
});
case "aaa":
return r.dayPeriod(n, {
width: "abbreviated",
context: "formatting"
}).toLowerCase();
case "aaaaa":
return r.dayPeriod(n, {
width: "narrow",
context: "formatting"
});
default:
return r.dayPeriod(n, {
width: "wide",
context: "formatting"
});
}
},
b: function b(t, e, r) {
var n,
a = t.getUTCHours();
switch (n = 12 === a ? Z : 0 === a ? A : a / 12 >= 1 ? "pm" : "am", e) {
case "b":
case "bb":
return r.dayPeriod(n, {
width: "abbreviated",
context: "formatting"
});
case "bbb":
return r.dayPeriod(n, {
width: "abbreviated",
context: "formatting"
}).toLowerCase();
case "bbbbb":
return r.dayPeriod(n, {
width: "narrow",
context: "formatting"
});
default:
return r.dayPeriod(n, {
width: "wide",
context: "formatting"
});
}
},
B: function B(t, e, r) {
var n,
a = t.getUTCHours();
switch (n = a >= 17 ? _ : a >= 12 ? $ : a >= 4 ? K : J, e) {
case "B":
case "BB":
case "BBB":
return r.dayPeriod(n, {
width: "abbreviated",
context: "formatting"
});
case "BBBBB":
return r.dayPeriod(n, {
width: "narrow",
context: "formatting"
});
default:
return r.dayPeriod(n, {
width: "wide",
context: "formatting"
});
}
},
h: function h(t, e, r) {
if ("ho" === e) {
var n = t.getUTCHours() % 12;
return 0 === n && (n = 12), r.ordinalNumber(n, {
unit: "hour"
});
}
return O.h(t, e);
},
H: function H(t, e, r) {
return "Ho" === e ? r.ordinalNumber(t.getUTCHours(), {
unit: "hour"
}) : O.H(t, e);
},
K: function K(t, e, r) {
var n = t.getUTCHours() % 12;
return "Ko" === e ? r.ordinalNumber(n, {
unit: "hour"
}) : E(n, e.length);
},
k: function k(t, e, r) {
var n = t.getUTCHours();
return 0 === n && (n = 24), "ko" === e ? r.ordinalNumber(n, {
unit: "hour"
}) : E(n, e.length);
},
m: function m(t, e, r) {
return "mo" === e ? r.ordinalNumber(t.getUTCMinutes(), {
unit: "minute"
}) : O.m(t, e);
},
s: function s(t, e, r) {
return "so" === e ? r.ordinalNumber(t.getUTCSeconds(), {
unit: "second"
}) : O.s(t, e);
},
S: function S(t, e) {
return O.S(t, e);
},
X: function X(t, e, r, n) {
var a = (n._originalDate || t).getTimezoneOffset();
if (0 === a) return "Z";
switch (e) {
case "X":
return et(a);
case "XXXX":
case "XX":
return rt(a);
default:
return rt(a, ":");
}
},
x: function x(t, e, r, n) {
var a = (n._originalDate || t).getTimezoneOffset();
switch (e) {
case "x":
return et(a);
case "xxxx":
case "xx":
return rt(a);
default:
return rt(a, ":");
}
},
O: function O(t, e, r, n) {
var a = (n._originalDate || t).getTimezoneOffset();
switch (e) {
case "O":
case "OO":
case "OOO":
return "GMT" + tt(a, ":");
default:
return "GMT" + rt(a, ":");
}
},
z: function z(t, e, r, n) {
var a = (n._originalDate || t).getTimezoneOffset();
switch (e) {
case "z":
case "zz":
case "zzz":
return "GMT" + tt(a, ":");
default:
return "GMT" + rt(a, ":");
}
},
t: function t(_t2, e, r, n) {
var a = n._originalDate || _t2;
return E(Math.floor(a.getTime() / 1e3), e.length);
},
T: function T(t, e, r, n) {
return E((n._originalDate || t).getTime(), e.length);
}
};
function tt(t, e) {
var r = t > 0 ? "-" : "+",
n = Math.abs(t),
a = Math.floor(n / 60),
i = n % 60;
if (0 === i) return r + String(a);
var o = e || "";
return r + String(a) + o + E(i, 2);
}
function et(t, e) {
return t % 60 == 0 ? (t > 0 ? "-" : "+") + E(Math.abs(t) / 60, 2) : rt(t, e);
}
function rt(t, e) {
var r = e || "",
n = t > 0 ? "-" : "+",
a = Math.abs(t);
return n + E(Math.floor(a / 60), 2) + r + E(a % 60, 2);
}
var nt = V;
function at(t, e) {
switch (t) {
case "P":
return e.date({
width: "short"
});
case "PP":
return e.date({
width: "medium"
});
case "PPP":
return e.date({
width: "long"
});
default:
return e.date({
width: "full"
});
}
}
function it(t, e) {
switch (t) {
case "p":
return e.time({
width: "short"
});
case "pp":
return e.time({
width: "medium"
});
case "ppp":
return e.time({
width: "long"
});
default:
return e.time({
width: "full"
});
}
}
var ot = {
p: it,
P: function P(t, e) {
var r,
n = t.match(/(P+)(p+)?/),
a = n[1],
i = n[2];
if (!i) return at(t, e);
switch (a) {
case "P":
r = e.dateTime({
width: "short"
});
break;
case "PP":
r = e.dateTime({
width: "medium"
});
break;
case "PPP":
r = e.dateTime({
width: "long"
});
break;
default:
r = e.dateTime({
width: "full"
});
}
return r.replace("{{date}}", at(a, e)).replace("{{time}}", it(i, e));
}
},
ut = ot,
st = ["D", "DD"],
ct = ["YY", "YYYY"];
function dt(t) {
return -1 !== st.indexOf(t);
}
function lt(t) {
return -1 !== ct.indexOf(t);
}
function ft(t, e, r) {
if ("YYYY" === t) throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(e, "`) for formatting years to the input `").concat(r, "`; see: https://git.io/fxCyr"));
if ("YY" === t) throw new RangeError("Use `yy` instead of `YY` (in `".concat(e, "`) for formatting years to the input `").concat(r, "`; see: https://git.io/fxCyr"));
if ("D" === t) throw new RangeError("Use `d` instead of `D` (in `".concat(e, "`) for formatting days of the month to the input `").concat(r, "`; see: https://git.io/fxCyr"));
if ("DD" === t) throw new RangeError("Use `dd` instead of `DD` (in `".concat(e, "`) for formatting days of the month to the input `").concat(r, "`; see: https://git.io/fxCyr"));
}
var ht = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,
mt = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,
wt = /^'([^]*?)'?$/,
gt = /''/g,
vt = /[a-zA-Z]/;
function yt(t) {
return t.match(wt)[1].replace(gt, "'");
}
function bt(t, e) {
if (null == t) throw new TypeError("assign requires that input parameter not be null or undefined");
for (var r in e = e || {}) e.hasOwnProperty(r) && (t[r] = e[r]);
return t;
}
function Tt(t, a, i) {
r(2, arguments);
var o = i || {},
u = o.locale,
s = u && u.options && u.options.weekStartsOn,
c = null == s ? 0 : e(s),
d = null == o.weekStartsOn ? c : e(o.weekStartsOn);
if (!(d >= 0 && d <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
var l = n(t),
f = e(a),
h = l.getUTCDay(),
m = f % 7,
w = (m + 7) % 7,
g = (w < d ? 7 : 0) + f - h;
return l.setUTCDate(l.getUTCDate() + g), l;
}
var pt = /^(1[0-2]|0?\d)/,
Ct = /^(3[0-1]|[0-2]?\d)/,
Mt = /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
Dt = /^(5[0-3]|[0-4]?\d)/,
xt = /^(2[0-3]|[0-1]?\d)/,
kt = /^(2[0-4]|[0-1]?\d)/,
Ut = /^(1[0-1]|0?\d)/,
Yt = /^(1[0-2]|0?\d)/,
Nt = /^[0-5]?\d/,
St = /^[0-5]?\d/,
Pt = /^\d/,
qt = /^\d{1,2}/,
Ht = /^\d{1,3}/,
Et = /^\d{1,4}/,
Ot = /^-?\d+/,
Ft = /^-?\d/,
Wt = /^-?\d{1,2}/,
Lt = /^-?\d{1,3}/,
Qt = /^-?\d{1,4}/,
Rt = /^([+-])(\d{2})(\d{2})?|Z/,
It = /^([+-])(\d{2})(\d{2})|Z/,
Gt = /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
Xt = /^([+-])(\d{2}):(\d{2})|Z/,
jt = /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/;
function Bt(t, e, r) {
var n = e.match(t);
if (!n) return null;
var a = parseInt(n[0], 10);
return {
value: r ? r(a) : a,
rest: e.slice(n[0].length)
};
}
function zt(t, e) {
var r = e.match(t);
return r ? "Z" === r[0] ? {
value: 0,
rest: e.slice(1)
} : {
value: ("+" === r[1] ? 1 : -1) * (36e5 * (r[2] ? parseInt(r[2], 10) : 0) + 6e4 * (r[3] ? parseInt(r[3], 10) : 0) + 1e3 * (r[5] ? parseInt(r[5], 10) : 0)),
rest: e.slice(r[0].length)
} : null;
}
function At(t, e) {
return Bt(Ot, t, e);
}
function Zt(t, e, r) {
switch (t) {
case 1:
return Bt(Pt, e, r);
case 2:
return Bt(qt, e, r);
case 3:
return Bt(Ht, e, r);
case 4:
return Bt(Et, e, r);
default:
return Bt(new RegExp("^\\d{1," + t + "}"), e, r);
}
}
function Kt(t, e, r) {
switch (t) {
case 1:
return Bt(Ft, e, r);
case 2:
return Bt(Wt, e, r);
case 3:
return Bt(Lt, e, r);
case 4:
return Bt(Qt, e, r);
default:
return Bt(new RegExp("^-?\\d{1," + t + "}"), e, r);
}
}
function $t(t) {
switch (t) {
case "morning":
return 4;
case "evening":
return 17;
case "pm":
case "noon":
case "afternoon":
return 12;
default:
return 0;
}
}
function _t(t, e) {
var r,
n = e > 0,
a = n ? e : 1 - e;
if (a <= 50) r = t || 100;else {
var i = a + 50;
r = t + 100 * Math.floor(i / 100) - (t >= i % 100 ? 100 : 0);
}
return n ? r : 1 - r;
}
var Jt = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
Vt = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function te(t) {
return t % 400 == 0 || t % 4 == 0 && t % 100 != 0;
}
var ee = {
G: {
priority: 140,
parse: function parse(t, e, r, n) {
switch (e) {
case "G":
case "GG":
case "GGG":
return r.era(t, {
width: "abbreviated"
}) || r.era(t, {
width: "narrow"
});
case "GGGGG":
return r.era(t, {
width: "narrow"
});
default:
return r.era(t, {
width: "wide"
}) || r.era(t, {
width: "abbreviated"
}) || r.era(t, {
width: "narrow"
});
}
},
set: function set(t, e, r, n) {
return e.era = r, t.setUTCFullYear(r, 0, 1), t.setUTCHours(0, 0, 0, 0), t;
},
incompatibleTokens: ["R", "u", "t", "T"]
},
y: {
priority: 130,
parse: function parse(t, e, r, n) {
var a = function a(t) {
return {
year: t,
isTwoDigitYear: "yy" === e
};
};
switch (e) {
case "y":
return Zt(4, t, a);
case "yo":
return r.ordinalNumber(t, {
unit: "year",
valueCallback: a
});
default:
return Zt(e.length, t, a);
}
},
validate: function validate(t, e, r) {
return e.isTwoDigitYear || e.year > 0;
},
set: function set(t, e, r, n) {
var a = t.getUTCFullYear();
if (r.isTwoDigitYear) {
var i = _t(r.year, a);
return t.setUTCFullYear(i, 0, 1), t.setUTCHours(0, 0, 0, 0), t;
}
var o = "era" in e && 1 !== e.era ? 1 - r.year : r.year;
return t.setUTCFullYear(o, 0, 1), t.setUTCHours(0, 0, 0, 0), t;
},
incompatibleTokens: ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]
},
Y: {
priority: 130,
parse: function parse(t, e, r, n) {
var a = function a(t) {
return {
year: t,
isTwoDigitYear: "YY" === e
};
};
switch (e) {
case "Y":
return Zt(4, t, a);
case "Yo":
return r.ordinalNumber(t, {
unit: "year",
valueCallback: a
});
default:
return Zt(e.length, t, a);
}
},
validate: function validate(t, e, r) {
return e.isTwoDigitYear || e.year > 0;
},
set: function set(t, e, r, n) {
var a = X(t, n);
if (r.isTwoDigitYear) {
var i = _t(r.year, a);
return t.setUTCFullYear(i, 0, n.firstWeekContainsDate), t.setUTCHours(0, 0, 0, 0), G(t, n);
}
var o = "era" in e && 1 !== e.era ? 1 - r.year : r.year;
return t.setUTCFullYear(o, 0, n.firstWeekContainsDate), t.setUTCHours(0, 0, 0, 0), G(t, n);
},
incompatibleTokens: ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]
},
R: {
priority: 130,
parse: function parse(t, e, r, n) {
return Kt("R" === e ? 4 : e.length, t);
},
set: function set(t, e, r, n) {
var a = new Date(0);
return a.setUTCFullYear(r, 0, 4), a.setUTCHours(0, 0, 0, 0), W(a);
},
incompatibleTokens: ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]
},
u: {
priority: 130,
parse: function parse(t, e, r, n) {
return Kt("u" === e ? 4 : e.length, t);
},
set: function set(t, e, r, n) {
return t.setUTCFullYear(r, 0, 1), t.setUTCHours(0, 0, 0, 0), t;
},
incompatibleTokens: ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]
},
Q: {
priority: 120,
parse: function parse(t, e, r, n) {
switch (e) {
case "Q":
case "QQ":
return Zt(e.length, t);
case "Qo":
return r.ordinalNumber(t, {
unit: "quarter"
});
case "QQQ":
return r.quarter(t, {
width: "abbreviated",
context: "formatting"
}) || r.quarter(t, {
width: "narrow",
context: "formatting"
});
case "QQQQQ":
return r.quarter(t, {
width: "narrow",
context: "formatting"
});
default:
return r.quarter(t, {
width: "wide",
context: "formatting"
}) || r.quarter(t, {
width: "abbreviated",
context: "formatting"
}) || r.quarter(t, {
width: "narrow",
context: "formatting"
});
}
},
validate: function validate(t, e, r) {
return e >= 1 && e <= 4;
},
set: function set(t, e, r, n) {
return t.setUTCMonth(3 * (r - 1), 1), t.setUTCHours(0, 0, 0, 0), t;
},
incompatibleTokens: ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]
},
q: {
priority: 120,
parse: function parse(t, e, r, n) {
switch (e) {
case "q":
case "qq":
return Zt(e.length, t);
case "qo":
return r.ordinalNumber(t, {
unit: "quarter"
});
case "qqq":
return r.quarter(t, {
width: "abbreviated",
context: "standalone"
}) || r.quarter(t, {
width: "narrow",
context: "standalone"
});
case "qqqqq":
return r.quarter(t, {
width: "narrow",
context: "standalone"
});
default:
return r.quarter(t, {
width: "wide",
context: "standalone"
}) || r.quarter(t, {
width: "abbreviated",
context: "standalone"
}) || r.quarter(t, {
width: "narrow",
context: "standalone"
});
}
},
validate: function validate(t, e, r) {
return e >= 1 && e <= 4;
},
set: function set(t, e, r, n) {
return t.setUTCMonth(3 * (r - 1), 1), t.setUTCHours(0, 0, 0, 0), t;
},
incompatibleTokens: ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]
},
M: {
priority: 110,
parse: function parse(t, e, r, n) {
var a = function a(t) {
return t - 1;
};
switch (e) {
case "M":
return Bt(pt, t, a);
case "MM":
return Zt(2, t, a);
case "Mo":
return r.ordinalNumber(t, {
unit: "month",
valueCallback: a
});
case "MMM":
return r.month(t, {
width: "abbreviated",
context: "formatting"
}) || r.month(t, {
width: "narrow",
context: "formatting"
});
case "MMMMM":
return r.month(t, {
width: "narrow",
context: "formatting"
});
default:
return r.month(t, {
width: "wide",
context: "formatting"
}) || r.month(t, {
width: "abbreviated",
context: "formatting"
}) || r.month(t, {
width: "narrow",
context: "formatting"
});
}
},
validate: function validate(t, e, r) {
return e >= 0 && e <= 11;
},
set: function set(t, e, r, n) {
return t.setUTCMonth(r, 1), t.setUTCHours(0, 0, 0, 0), t;
},
incompatibleTokens: ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]
},
L: {
priority: 110,
parse: function parse(t, e, r, n) {
var a = function a(t) {
return t - 1;
};
switch (e) {
case "L":
return Bt(pt, t, a);
case "LL":
return Zt(2, t, a);
case "Lo":
return r.ordinalNumber(t, {
unit: "month",
valueCallback: a
});
case "LLL":
return r.month(t, {
width: "abbreviated",
context: "standalone"
}) || r.month(t, {
width: "narrow",
context: "standalone"
});
case "LLLLL":
return r.month(t, {
width: "narrow",
context: "standalone"
});
default:
return r.month(t, {
width: "wide",
context: "standalone"
}) || r.month(t, {
width: "abbreviated",
context: "standalone"
}) || r.month(t, {
width: "narrow",
context: "standalone"
});
}
},
validate: function validate(t, e, r) {
return e >= 0 && e <= 11;
},
set: function set(t, e, r, n) {
return t.setUTCMonth(r, 1), t.setUTCHours(0, 0, 0, 0), t;
},
incompatibleTokens: ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]
},
w: {
priority: 100,
parse: function parse(t, e, r, n) {
switch (e) {
case "w":
return Bt(Dt, t);
case "wo":
return r.ordinalNumber(t, {
unit: "week"
});
default:
return Zt(e.length, t);
}
},
validate: function validate(t, e, r) {
return e >= 1 && e <= 53;
},
set: function set(t, a, i, o) {
return G(function (t, a, i) {
r(2, arguments);
var o = n(t),
u = e(a),
s = z(o, i) - u;
return o.setUTCDate(o.getUTCDate() - 7 * s), o;
}(t, i, o), o);
},
incompatibleTokens: ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]
},
I: {
priority: 100,
parse: function parse(t, e, r, n) {
switch (e) {
case "I":
return Bt(Dt, t);
case "Io":
return r.ordinalNumber(t, {
unit: "week"
});
default:
return Zt(e.length, t);
}
},
validate: function validate(t, e, r) {
return e >= 1 && e <= 53;
},
set: function set(t, a, i, o) {
return W(function (t, a) {
r(2, arguments);
var i = n(t),
o = e(a),
u = _I(i) - o;
return i.setUTCDate(i.getUTCDate() - 7 * u), i;
}(t, i, o), o);
},
incompatibleTokens: ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]
},
d: {
priority: 90,
subPriority: 1,
parse: function parse(t, e, r, n) {
switch (e) {
case "d":
return Bt(Ct, t);
case "do":
return r.ordinalNumber(t, {
unit: "date"
});
default:
return Zt(e.length, t);
}
},
validate: function validate(t, e, r) {
var n = te(t.getUTCFullYear()),
a = t.getUTCMonth();
return n ? e >= 1 && e <= Vt[a] : e >= 1 && e <= Jt[a];
},
set: function set(t, e, r, n) {
return t.setUTCDate(r), t.setUTCHours(0, 0, 0, 0), t;
},
incompatibleTokens: ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]
},
D: {
priority: 90,
subPriority: 1,
parse: function parse(t, e, r, n) {
switch (e) {
case "D":
case "DD":
return Bt(Mt, t);
case "Do":
return r.ordinalNumber(t, {
unit: "date"
});
default:
return Zt(e.length, t);
}
},
validate: function validate(t, e, r) {
return te(t.getUTCFullYear()) ? e >= 1 && e <= 366 : e >= 1 && e <= 365;
},
set: function set(t, e, r, n) {
return t.setUTCMonth(0, r), t.setUTCHours(0, 0, 0, 0), t;
},
incompatibleTokens: ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]
},
E: {
priority: 90,
parse: function parse(t, e, r, n) {
switch (e) {
case "E":
case "EE":
case "EEE":
return r.day(t, {
width: "abbreviated",
context: "formatting"
}) || r.day(t, {
width: "short",
context: "formatting"
}) || r.day(t, {
width: "narrow",
context: "formatting"
});
case "EEEEE":
return r.day(t, {
width: "narrow",
context: "formatting"
});
case "EEEEEE":
return r.day(t, {
width: "short",
context: "formatting"
}) || r.day(t, {
width: "narrow",
context: "formatting"
});
default:
return r.day(t, {
width: "wide",
context: "formatting"
}) || r.day(t, {
width: "abbreviated",
context: "formatting"
}) || r.day(t, {
width: "short",
context: "formatting"
}) || r.day(t, {
width: "narrow",
context: "formatting"
});
}
},
validate: function validate(t, e, r) {
return e >= 0 && e <= 6;
},
set: function set(t, e, r, n) {
return (t = Tt(t, r, n)).setUTCHours(0, 0, 0, 0), t;
},
incompatibleTokens: ["D", "i", "e", "c", "t", "T"]
},
e: {
priority: 90,
parse: function parse(t, e, r, n) {
var a = function a(t) {
var e = 7 * Math.floor((t - 1) / 7);
return (t + n.weekStartsOn + 6) % 7 + e;
};
switch (e) {
case "e":
case "ee":
return Zt(e.length, t, a);
case "eo":
return r.ordinalNumber(t, {
unit: "day",
valueCallback: a
});
case "eee":
return r.day(t, {
width: "abbreviated",
context: "formatting"
}) || r.day(t, {
width: "short",
context: "formatting"
}) || r.day(t, {
width: "narrow",
context: "formatting"
});
case "eeeee":
return r.day(t, {
width: "narrow",
context: "formatting"
});
case "eeeeee":
return r.day(t, {
width: "short",
context: "formatting"
}) || r.day(t, {
width: "narrow",
context: "formatting"
});
default:
return r.day(t, {
width: "wide",
context: "formatting"
}) || r.day(t, {
width: "abbreviated",
context: "formatting"
}) || r.day(t, {
width: "short",
context: "formatting"
}) || r.day(t, {
width: "narrow",
context: "formatting"
});
}
},
validate: function validate(t, e, r) {
return e >= 0 && e <= 6;
},
set: function set(t, e, r, n) {
return (t = Tt(t, r, n)).setUTCHours(0, 0, 0, 0), t;
},
incompatibleTokens: ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]
},
c: {
priority: 90,
parse: function parse(t, e, r, n) {
var a = function a(t) {
var e = 7 * Math.floor((t - 1) / 7);
return (t + n.weekStartsOn + 6) % 7 + e;
};
switch (e) {
case "c":
case "cc":
return Zt(e.length, t, a);
case "co":
return r.ordinalNumber(t, {
unit: "day",
valueCallback: a
});
case "ccc":
return r.day(t, {
width: "abbreviated",
context: "standalone"
}) || r.day(t, {
width: "short",
context: "standalone"
}) || r.day(t, {
width: "narrow",
context: "standalone"
});
case "ccccc":
return r.day(t, {
width: "narrow",
context: "standalone"
});
case "cccccc":
return r.day(t, {
width: "short",
context: "standalone"
}) || r.day(t, {
width: "narrow",
context: "standalone"
});
default:
return r.day(t, {
width: "wide",
context: "standalone"
}) || r.day(t, {
width: "abbreviated",
context: "standalone"
}) || r.day(t, {
width: "short",
context: "standalone"
}) || r.day(t, {
width: "narrow",
context: "standalone"
});
}
},
validate: function validate(t, e, r) {
return e >= 0 && e <= 6;
},
set: function set(t, e, r, n) {
return (t = Tt(t, r, n)).setUTCHours(0, 0, 0, 0), t;
},
incompatibleTokens: ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]
},
i: {
priority: 90,
parse: function parse(t, e, r, n) {
var a = function a(t) {
return 0 === t ? 7 : t;
};
switch (e) {
case "i":
case "ii":
return Zt(e.length, t);
case "io":
return r.ordinalNumber(t, {
unit: "day"
});
case "iii":
return r.day(t, {
width: "abbreviated",
context: "formatting",
valueCallback: a
}) || r.day(t, {
width: "short",
context: "formatting",
valueCallback: a
}) || r.day(t, {
width: "narrow",
context: "formatting",
valueCallback: a
});
case "iiiii":
return r.day(t, {
width: "narrow",
context: "formatting",
valueCallback: a
});
case "iiiiii":
return r.day(t, {
width: "short",
context: "formatting",
valueCallback: a
}) || r.day(t, {
width: "narrow",
context: "formatting",
valueCallback: a
});
default:
return r.day(t, {
width: "wide",
context: "formatting",
valueCallback: a
}) || r.day(t, {
width: "abbreviated",
context: "formatting",
valueCallback: a
}) || r.day(t, {
width: "short",
context: "formatting",
valueCallback: a
}) || r.day(t, {
width: "narrow",
context: "formatting",
valueCallback: a
});
}
},
validate: function validate(t, e, r) {
return e >= 1 && e <= 7;
},
set: function set(t, a, i, o) {
return t = function (t, a) {
r(2, arguments);
var i = e(a);
i % 7 == 0 && (i -= 7);
var o = 1,
u = n(t),
s = u.getUTCDay(),
c = ((i % 7 + 7) % 7 < o ? 7 : 0) + i - s;
return u.setUTCDate(u.getUTCDate() + c), u;
}(t, i, o), t.setUTCHours(0, 0, 0, 0), t;
},
incompatibleTokens: ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]
},
a: {
priority: 80,
parse: function parse(t, e, r, n) {
switch (e) {
case "a":
case "aa":
case "aaa":
return r.dayPeriod(t, {
width: "abbreviated",
context: "formatting"
}) || r.dayPeriod(t, {
width: "narrow",
context: "formatting"
});
case "aaaaa":
return r.dayPeriod(t, {
width: "narrow",
context: "formatting"
});
default:
return r.dayPeriod(t, {
width: "wide",
context: "formatting"
}) || r.dayPeriod(t, {
width: "abbreviated",
context: "formatting"
}) || r.dayPeriod(t, {
width: "narrow",
context: "formatting"
});
}
},
set: function set(t, e, r, n) {
return t.setUTCHours($t(r), 0, 0, 0), t;
},
incompatibleTokens: ["b", "B", "H", "K", "k", "t", "T"]
},
b: {
priority: 80,
parse: function parse(t, e, r, n) {
switch (e) {
case "b":
case "bb":
case "bbb":
return r.dayPeriod(t, {
width: "abbreviated",
context: "formatting"
}) || r.dayPeriod(t, {
width: "narrow",
context: "formatting"
});
case "bbbbb":
return r.dayPeriod(t, {
width: "narrow",
context: "formatting"
});
default:
return r.dayPeriod(t, {
width: "wide",
context: "formatting"
}) || r.dayPeriod(t, {
width: "abbreviated",
context: "formatting"
}) || r.dayPeriod(t, {
width: "narrow",
context: "formatting"
});
}
},
set: function set(t, e, r, n) {
return t.setUTCHours($t(r), 0, 0, 0), t;
},
incompatibleTokens: ["a", "B", "H", "K", "k", "t", "T"]
},
B: {
priority: 80,
parse: function parse(t, e, r, n) {
switch (e) {
case "B":
case "BB":
case "BBB":
return r.dayPeriod(t, {
width: "abbreviated",
context: "formatting"
}) || r.dayPeriod(t, {
width: "narrow",
context: "formatting"
});
case "BBBBB":
return r.dayPeriod(t, {
width: "narrow",
context: "formatting"
});
default:
return r.dayPeriod(t, {
width: "wide",
context: "formatting"
}) || r.dayPeriod(t, {
width: "abbreviated",
context: "formatting"
}) || r.dayPeriod(t, {
width: "narrow",
context: "formatting"
});
}
},
set: function set(t, e, r, n) {
return t.setUTCHours($t(r), 0, 0, 0), t;
},
incompatibleTokens: ["a", "b", "t", "T"]
},
h: {
priority: 70,
parse: function parse(t, e, r, n) {
switch (e) {
case "h":
return Bt(Yt, t);
case "ho":
return r.ordinalNumber(t, {
unit: "hour"
});
default:
return Zt(e.length, t);
}
},
validate: function validate(t, e, r) {
return e >= 1 && e <= 12;
},
set: function set(t, e, r, n) {
var a = t.getUTCHours() >= 12;
return a && r < 12 ? t.setUTCHours(r + 12, 0, 0, 0) : a || 12 !== r ? t.setUTCHours(r, 0, 0, 0) : t.setUTCHours(0, 0, 0, 0), t;
},
incompatibleTokens: ["H", "K", "k", "t", "T"]
},
H: {
priority: 70,
parse: function parse(t, e, r, n) {
switch (e) {
case "H":
return Bt(xt, t);
case "Ho":
return r.ordinalNumber(t, {
unit: "hour"
});
default:
return Zt(e.length, t);
}
},
validate: function validate(t, e, r) {
return e >= 0 && e <= 23;
},
set: function set(t, e, r, n) {
return t.setUTCHours(r, 0, 0, 0), t;
},
incompatibleTokens: ["a", "b", "h", "K", "k", "t", "T"]
},
K: {
priority: 70,
parse: function parse(t, e, r, n) {
switch (e) {
case "K":
return Bt(Ut, t);
case "Ko":
return r.ordinalNumber(t, {
unit: "hour"
});
default:
return Zt(e.length, t);
}
},
validate: function validate(t, e, r) {
return e >= 0 && e <= 11;
},
set: function set(t, e, r, n) {
return t.getUTCHours() >= 12 && r < 12 ? t.setUTCHours(r + 12, 0, 0, 0) : t.setUTCHours(r, 0, 0, 0), t;
},
incompatibleTokens: ["a", "b", "h", "H", "k", "t", "T"]
},
k: {
priority: 70,
parse: function parse(t, e, r, n) {
switch (e) {
case "k":
return Bt(kt, t);
case "ko":
return r.ordinalNumber(t, {
unit: "hour"
});
default:
return Zt(e.length, t);
}
},
validate: function validate(t, e, r) {
return e >= 1 && e <= 24;
},
set: function set(t, e, r, n) {
var a = r <= 24 ? r % 24 : r;
return t.setUTCHours(a, 0, 0, 0), t;
},
incompatibleTokens: ["a", "b", "h", "H", "K", "t", "T"]
},
m: {
priority: 60,
parse: function parse(t, e, r, n) {
switch (e) {
case "m":
return Bt(Nt, t);
case "mo":
return r.ordinalNumber(t, {
unit: "minute"
});
default:
return Zt(e.length, t);
}
},
validate: function validate(t, e, r) {
return e >= 0 && e <= 59;
},
set: function set(t, e, r, n) {
return t.setUTCMinutes(r, 0, 0), t;
},
incompatibleTokens: ["t", "T"]
},
s: {
priority: 50,
parse: function parse(t, e, r, n) {
switch (e) {
case "s":
return Bt(St, t);
case "so":
return r.ordinalNumber(t, {
unit: "second"
});
default:
return Zt(e.length, t);
}
},
validate: function validate(t, e, r) {
return e >= 0 && e <= 59;
},
set: function set(t, e, r, n) {
return t.setUTCSeconds(r, 0), t;
},
incompatibleTokens: ["t", "T"]
},
S: {
priority: 30,
parse: function parse(t, e, r, n) {
return Zt(e.length, t, function (t) {
return Math.floor(t * Math.pow(10, 3 - e.length));
});
},
set: function set(t, e, r, n) {
return t.setUTCMilliseconds(r), t;
},
incompatibleTokens: ["t", "T"]
},
X: {
priority: 10,
parse: function parse(t, e, r, n) {
switch (e) {
case "X":
return zt(Rt, t);
case "XX":
return zt(It, t);
case "XXXX":
return zt(Gt, t);
case "XXXXX":
return zt(jt, t);
default:
return zt(Xt, t);
}
},
set: function set(t, e, r, n) {
return e.timestampIsSet ? t : new Date(t.getTime() - r);
},
incompatibleTokens: ["t", "T", "x"]
},
x: {
priority: 10,
parse: function parse(t, e, r, n) {
switch (e) {
case "x":
return zt(Rt, t);
case "xx":
return zt(It, t);
case "xxxx":
return zt(Gt, t);
case "xxxxx":
return zt(jt, t);
default:
return zt(Xt, t);
}
},
set: function set(t, e, r, n) {
return e.timestampIsSet ? t : new Date(t.getTime() - r);
},
incompatibleTokens: ["t", "T", "X"]
},
t: {
priority: 40,
parse: function parse(t, e, r, n) {
return At(t);
},
set: function set(t, e, r, n) {
return [new Date(1e3 * r), {
timestampIsSet: !0
}];
},
incompatibleTokens: "*"
},
T: {
priority: 20,
parse: function parse(t, e, r, n) {
return At(t);
},
set: function set(t, e, r, n) {
return [new Date(r), {
timestampIsSet: !0
}];
},
incompatibleTokens: "*"
}
},
re = ee,
ne = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,
ae = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,
ie = /^'([^]*?)'?$/,
oe = /''/g,
ue = /\S/,
se = /[a-zA-Z]/;
function ce(t, e) {
if (e.timestampIsSet) return t;
var r = new Date(0);
return r.setFullYear(t.getUTCFullYear(), t.getUTCMonth(), t.getUTCDate()), r.setHours(t.getUTCHours(), t.getUTCMinutes(), t.getUTCSeconds(), t.getUTCMilliseconds()), r;
}
function de(t) {
return t.match(ie)[1].replace(oe, "'");
}
var le = 36e5,
fe = {
dateTimeDelimiter: /[T ]/,
timeZoneDelimiter: /[Z ]/i,
timezone: /([Z+-].*)$/
},
he = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/,
me = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/,
we = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function ge(t) {
var e,
r = {},
n = t.split(fe.dateTimeDelimiter);
if (n.length > 2) return r;
if (/:/.test(n[0]) ? (r.date = null, e = n[0]) : (r.date = n[0], e = n[1], fe.timeZoneDelimiter.test(r.date) && (r.date = t.split(fe.timeZoneDelimiter)[0], e = t.substr(r.date.length, t.length))), e) {
var a = fe.timezone.exec(e);
a ? (r.time = e.replace(a[1], ""), r.timezone = a[1]) : r.time = e;
}
return r;
}
function ve(t, e) {
var r = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + e) + "})|(\\d{2}|[+-]\\d{" + (2 + e) + "})$)"),
n = t.match(r);
if (!n) return {
year: null
};
var a = n[1] && parseInt(n[1]),
i = n[2] && parseInt(n[2]);
return {
year: null == i ? a : 100 * i,
restDateString: t.slice((n[1] || n[2]).length)
};
}
function ye(t, e) {
if (null === e) return null;
var r = t.match(he);
if (!r) return null;
var n = !!r[4],
a = be(r[1]),
i = be(r[2]) - 1,
o = be(r[3]),
u = be(r[4]),
s = be(r[5]) - 1;
if (n) return function (t, e, r) {
return e >= 1 && e <= 53 && r >= 0 && r <= 6;
}(0, u, s) ? function (t, e, r) {
var n = new Date(0);
n.setUTCFullYear(t, 0, 4);
var a = n.getUTCDay() || 7,
i = 7 * (e - 1) + r + 1 - a;
return n.setUTCDate(n.getUTCDate() + i), n;
}(e, u, s) : new Date(NaN);
var c = new Date(0);
return function (t, e, r) {
return e >= 0 && e <= 11 && r >= 1 && r <= (Me[e] || (De(t) ? 29 : 28));
}(e, i, o) && function (t, e) {
return e >= 1 && e <= (De(t) ? 366 : 365);
}(e, a) ? (c.setUTCFullYear(e, i, Math.max(a, o)), c) : new Date(NaN);
}
function be(t) {
return t ? parseInt(t) : 1;
}
function Te(t) {
var e = t.match(me);
if (!e) return null;
var r = pe(e[1]),
n = pe(e[2]),
a = pe(e[3]);
return function (t, e, r) {
if (24 === t) return 0 === e && 0 === r;
return r >= 0 && r < 60 && e >= 0 && e < 60 && t >= 0 && t < 25;
}(r, n, a) ? r * le + 6e4 * n + 1e3 * a : NaN;
}
function pe(t) {
return t && parseFloat(t.replace(",", ".")) || 0;
}
function Ce(t) {
if ("Z" === t) return 0;
var e = t.match(we);
if (!e) return 0;
var r = "+" === e[1] ? -1 : 1,
n = parseInt(e[2]),
a = e[3] && parseInt(e[3]) || 0;
return function (t, e) {
return e >= 0 && e <= 59;
}(0, a) ? r * (n * le + 6e4 * a) : NaN;
}
var Me = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function De(t) {
return t % 400 == 0 || t % 4 == 0 && t % 100;
}
var xe = {
datetime: "MMM d, yyyy, h:mm:ss aaaa",
millisecond: "h:mm:ss.SSS aaaa",
second: "h:mm:ss aaaa",
minute: "h:mm aaaa",
hour: "ha",
day: "MMM d",
week: "PP",
month: "MMM yyyy",
quarter: "qqq - yyyy",
year: "yyyy"
};
t._adapters._date.override({
_id: "date-fns",
formats: function formats() {
return xe;
},
parse: function parse(t, a) {
if (null == t) return null;
var i = _typeof(t);
return "number" === i || t instanceof Date ? t = n(t) : "string" === i && (t = "string" == typeof a ? function (t, a, i, o) {
r(3, arguments);
var u = String(t),
s = String(a),
d = o || {},
l = d.locale || q;
if (!l.match) throw new RangeError("locale must contain match property");
var f = l.options && l.options.firstWeekContainsDate,
h = null == f ? 1 : e(f),
m = null == d.firstWeekContainsDate ? h : e(d.firstWeekContainsDate);
if (!(m >= 1 && m <= 7)) throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
var w = l.options && l.options.weekStartsOn,
g = null == w ? 0 : e(w),
v = null == d.weekStartsOn ? g : e(d.weekStartsOn);
if (!(v >= 0 && v <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
if ("" === s) return "" === u ? n(i) : new Date(NaN);
var y,
b = {
firstWeekContainsDate: m,
weekStartsOn: v,
locale: l
},
T = [{
priority: 10,
subPriority: -1,
set: ce,
index: 0
}],
p = s.match(ae).map(function (t) {
var e = t[0];
return "p" === e || "P" === e ? (0, ut[e])(t, l.formatLong, b) : t;
}).join("").match(ne),
C = [];
for (y = 0; y < p.length; y++) {
var M = p[y];
!d.useAdditionalWeekYearTokens && lt(M) && ft(M, s, t), !d.useAdditionalDayOfYearTokens && dt(M) && ft(M, s, t);
var D = M[0],
x = re[D];
if (x) {
var k = x.incompatibleTokens;
if (Array.isArray(k)) {
for (var U = void 0, Y = 0; Y < C.length; Y++) {
var N = C[Y].token;
if (-1 !== k.indexOf(N) || N === D) {
U = C[Y];
break;
}
}
if (U) throw new RangeError("The format string mustn't contain `".concat(U.fullToken, "` and `").concat(M, "` at the same time"));
} else if ("*" === x.incompatibleTokens && C.length) throw new RangeError("The format string mustn't contain `".concat(M, "` and any other token at the same time"));
C.push({
token: D,
fullToken: M
});
var S = x.parse(u, M, l.match, b);
if (!S) return new Date(NaN);
T.push({
priority: x.priority,
subPriority: x.subPriority || 0,
set: x.set,
validate: x.validate,
value: S.value,
index: T.length
}), u = S.rest;
} else {
if (D.match(se)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + D + "`");
if ("''" === M ? M = "'" : "'" === D && (M = de(M)), 0 !== u.indexOf(M)) return new Date(NaN);
u = u.slice(M.length);
}
}
if (u.length > 0 && ue.test(u)) return new Date(NaN);
var P = T.map(function (t) {
return t.priority;
}).sort(function (t, e) {
return e - t;
}).filter(function (t, e, r) {
return r.indexOf(t) === e;
}).map(function (t) {
return T.filter(function (e) {
return e.priority === t;
}).sort(function (t, e) {
return e.subPriority - t.subPriority;
});
}).map(function (t) {
return t[0];
}),
E = n(i);
if (isNaN(E)) return new Date(NaN);
var O = H(E, c(E)),
F = {};
for (y = 0; y < P.length; y++) {
var W = P[y];
if (W.validate && !W.validate(O, W.value, b)) return new Date(NaN);
var L = W.set(O, F, W.value, b);
L[0] ? (O = L[0], bt(F, L[1])) : O = L;
}
return O;
}(t, a, new Date(), this.options) : function (t, n) {
r(1, arguments);
var a = n || {},
i = null == a.additionalDigits ? 2 : e(a.additionalDigits);
if (2 !== i && 1 !== i && 0 !== i) throw new RangeError("additionalDigits must be 0, 1 or 2");
if ("string" != typeof t && "[object String]" !== Object.prototype.toString.call(t)) return new Date(NaN);
var o,
u = ge(t);
if (u.date) {
var s = ve(u.date, i);
o = ye(s.restDateString, s.year);
}
if (isNaN(o) || !o) return new Date(NaN);
var c,
d = o.getTime(),
l = 0;
if (u.time && (l = Te(u.time), isNaN(l) || null === l)) return new Date(NaN);
if (!u.timezone) {
var f = new Date(d + l),
h = new Date(0);
return h.setFullYear(f.getUTCFullYear(), f.getUTCMonth(), f.getUTCDate()), h.setHours(f.getUTCHours(), f.getUTCMinutes(), f.getUTCSeconds(), f.getUTCMilliseconds()), h;
}
return c = Ce(u.timezone), isNaN(c) ? new Date(NaN) : new Date(d + l + c);
}(t, this.options)), m(t) ? t.getTime() : null;
},
format: function format(t, a) {
return function (t, a, i) {
r(2, arguments);
var o = String(a),
u = i || {},
s = u.locale || q,
d = s.options && s.options.firstWeekContainsDate,
l = null == d ? 1 : e(d),
f = null == u.firstWeekContainsDate ? l : e(u.firstWeekContainsDate);
if (!(f >= 1 && f <= 7)) throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
var h = s.options && s.options.weekStartsOn,
w = null == h ? 0 : e(h),
g = null == u.weekStartsOn ? w : e(u.weekStartsOn);
if (!(g >= 0 && g <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
if (!s.localize) throw new RangeError("locale must contain localize property");
if (!s.formatLong) throw new RangeError("locale must contain formatLong property");
var v = n(t);
if (!m(v)) throw new RangeError("Invalid time value");
var y = c(v),
b = H(v, y),
T = {
firstWeekContainsDate: f,
weekStartsOn: g,
locale: s,
_originalDate: v
},
p = o.match(mt).map(function (t) {
var e = t[0];
return "p" === e || "P" === e ? (0, ut[e])(t, s.formatLong, T) : t;
}).join("").match(ht).map(function (e) {
if ("''" === e) return "'";
var r = e[0];
if ("'" === r) return yt(e);
var n = nt[r];
if (n) return !u.useAdditionalWeekYearTokens && lt(e) && ft(e, a, t), !u.useAdditionalDayOfYearTokens && dt(e) && ft(e, a, t), n(b, e, s.localize, T);
if (r.match(vt)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + r + "`");
return e;
}).join("");
return p;
}(t, a, this.options);
},
add: function add(t, n, s) {
switch (s) {
case "millisecond":
return o(t, n);
case "second":
return function (t, n) {
r(2, arguments);
var a = e(n);
return o(t, 1e3 * a);
}(t, n);
case "minute":
return function (t, n) {
r(2, arguments);
var a = e(n);
return o(t, 6e4 * a);
}(t, n);
case "hour":
return function (t, n) {
r(2, arguments);
var a = e(n);
return o(t, a * u);
}(t, n);
case "day":
return a(t, n);
case "week":
return function (t, n) {
r(2, arguments);
var i = e(n),
o = 7 * i;
return a(t, o);
}(t, n);
case "month":
return i(t, n);
case "quarter":
return function (t, n) {
r(2, arguments);
var a = e(n),
o = 3 * a;
return i(t, o);
}(t, n);
case "year":
return function (t, n) {
r(2, arguments);
var a = e(n);
return i(t, 12 * a);
}(t, n);
default:
return t;
}
},
diff: function diff(t, e, a) {
switch (a) {
case "millisecond":
return b(t, e);
case "second":
return function (t, e) {
r(2, arguments);
var n = b(t, e) / 1e3;
return n > 0 ? Math.floor(n) : Math.ceil(n);
}(t, e);
case "minute":
return function (t, e) {
r(2, arguments);
var n = b(t, e) / 6e4;
return n > 0 ? Math.floor(n) : Math.ceil(n);
}(t, e);
case "hour":
return function (t, e) {
r(2, arguments);
var n = b(t, e) / T;
return n > 0 ? Math.floor(n) : Math.ceil(n);
}(t, e);
case "day":
return y(t, e);
case "week":
return function (t, e) {
r(2, arguments);
var n = y(t, e) / 7;
return n > 0 ? Math.floor(n) : Math.ceil(n);
}(t, e);
case "month":
return D(t, e);
case "quarter":
return function (t, e) {
r(2, arguments);
var n = D(t, e) / 3;
return n > 0 ? Math.floor(n) : Math.ceil(n);
}(t, e);
case "year":
return function (t, e) {
r(2, arguments);
var a = n(t),
i = n(e),
o = h(a, i),
u = Math.abs(g(a, i));
a.setFullYear("1584"), i.setFullYear("1584");
var s = h(a, i) === -o,
c = o * (u - s);
return 0 === c ? 0 : c;
}(t, e);
default:
return 0;
}
},
startOf: function startOf(t, e, a) {
switch (e) {
case "second":
return function (t) {
r(1, arguments);
var e = n(t);
return e.setMilliseconds(0), e;
}(t);
case "minute":
return function (t) {
r(1, arguments);
var e = n(t);
return e.setSeconds(0, 0), e;
}(t);
case "hour":
return function (t) {
r(1, arguments);
var e = n(t);
return e.setMinutes(0, 0, 0), e;
}(t);
case "day":
return d(t);
case "week":
return s(t);
case "isoWeek":
return s(t, {
weekStartsOn: +a
});
case "month":
return function (t) {
r(1, arguments);
var e = n(t);
return e.setDate(1), e.setHours(0, 0, 0, 0), e;
}(t);
case "quarter":
return function (t) {
r(1, arguments);
var e = n(t),
a = e.getMonth(),
i = a - a % 3;
return e.setMonth(i, 1), e.setHours(0, 0, 0, 0), e;
}(t);
case "year":
return function (t) {
r(1, arguments);
var e = n(t),
a = new Date(0);
return a.setFullYear(e.getFullYear(), 0, 1), a.setHours(0, 0, 0, 0), a;
}(t);
default:
return t;
}
},
endOf: function endOf(t, a) {
switch (a) {
case "second":
return function (t) {
r(1, arguments);
var e = n(t);
return e.setMilliseconds(999), e;
}(t);
case "minute":
return function (t) {
r(1, arguments);
var e = n(t);
return e.setSeconds(59, 999), e;
}(t);
case "hour":
return function (t) {
r(1, arguments);
var e = n(t);
return e.setMinutes(59, 59, 999), e;
}(t);
case "day":
return p(t);
case "week":
return function (t, a) {
r(1, arguments);
var i = a || {},
o = i.locale,
u = o && o.options && o.options.weekStartsOn,
s = null == u ? 0 : e(u),
c = null == i.weekStartsOn ? s : e(i.weekStartsOn);
if (!(c >= 0 && c <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
var d = n(t),
l = d.getDay(),
f = 6 + (l < c ? -7 : 0) - (l - c);
return d.setDate(d.getDate() + f), d.setHours(23, 59, 59, 999), d;
}(t);
case "month":
return C(t);
case "quarter":
return function (t) {
r(1, arguments);
var e = n(t),
a = e.getMonth(),
i = a - a % 3 + 3;
return e.setMonth(i, 0), e.setHours(23, 59, 59, 999), e;
}(t);
case "year":
return function (t) {
r(1, arguments);
var e = n(t),
a = e.getFullYear();
return e.setFullYear(a + 1, 0, 0), e.setHours(23, 59, 59, 999), e;
}(t);
default:
return t;
}
}
});
});

/*!
 * chartjs-chart-matrix v2.0.1
 * https://chartjs-chart-matrix.pages.dev/
 * (c) 2023 Jukka Kurkela
 * Released under the MIT license
 */
!function (t, e) {
"object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? e(exports, require("chart.js"), require("chart.js/helpers")) : "function" == typeof define && define.amd ? define(["exports", "chart.js", "chart.js/helpers"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self)["chartjs-chart-matrix"] = {}, t.Chart, t.Chart.helpers);
}(this, function (t, e, i) {
"use strict";

var r = /*#__PURE__*/function (_e$DatasetController) {
function r() {
_classCallCheck(this, r);
return _callSuper(this, r, arguments);
}
_inherits(r, _e$DatasetController);
return _createClass(r, [{
key: "initialize",
value: function initialize() {
this.enableOptionSharing = !0, _get(_getPrototypeOf(r.prototype), "initialize", this).call(this);
}
}, {
key: "update",
value: function update(t) {
var e = this._cachedMeta;
this.updateElements(e.data, 0, e.data.length, t);
}
}, {
key: "updateElements",
value: function updateElements(t, e, i, _r2) {
var s = this,
a = "reset" === _r2,
_s$_cachedMeta = s._cachedMeta,
h = _s$_cachedMeta.xScale,
l = _s$_cachedMeta.yScale,
d = s.resolveDataElementOptions(e, _r2),
c = s.getSharedOptions(_r2, t[e], d);
for (var _d = e; _d < e + i; _d++) {
var _e2 = !a && s.getParsed(_d),
_i = a ? h.getBasePixel() : h.getPixelForValue(_e2.x),
_c = a ? l.getBasePixel() : l.getPixelForValue(_e2.y),
u = s.resolveDataElementOptions(_d, _r2),
g = u.width,
p = u.height,
f = u.anchorX,
x = u.anchorY,
y = {
x: n(f, _i, g),
y: o(x, _c, p),
width: g,
height: p,
options: u
};
s.updateElement(t[_d], _d, y, _r2);
}
s.updateSharedOptions(c, _r2);
}
}, {
key: "draw",
value: function draw() {
var t = this,
e = t.getMeta().data || [];
var i, _r3;
for (i = 0, _r3 = e.length; i < _r3; ++i) e[i].draw(t._ctx);
}
}]);
}(e.DatasetController);
_defineProperty(r, "id", "matrix");
_defineProperty(r, "version", "2.0.1");
_defineProperty(r, "defaults", {
dataElementType: "matrix",
animations: {
numbers: {
type: "number",
properties: ["x", "y", "width", "height"]
}
}
});
_defineProperty(r, "overrides", {
interaction: {
mode: "nearest",
intersect: !0
},
scales: {
x: {
type: "linear",
offset: !0
},
y: {
type: "linear",
reverse: !0
}
}
});
function n(t, e, i) {
return "left" === t || "start" === t ? e : "right" === t || "end" === t ? e - i : e - i / 2;
}
function o(t, e, i) {
return "top" === t || "start" === t ? e : "bottom" === t || "end" === t ? e - i : e - i / 2;
}
function s(t, e) {
var _t$getProps = t.getProps(["x", "y", "width", "height"], e),
i = _t$getProps.x,
r = _t$getProps.y,
n = _t$getProps.width,
o = _t$getProps.height;
return {
left: i,
top: r,
right: i + n,
bottom: r + o
};
}
function a(t, e, i) {
return Math.max(Math.min(t, i), e);
}
function h(t) {
var e = s(t),
r = e.right - e.left,
n = e.bottom - e.top,
o = function (t, e, r) {
var n = t.options.borderWidth;
var o, s, h, l;
return i.isObject(n) ? (o = +n.top || 0, s = +n.right || 0, h = +n.bottom || 0, l = +n.left || 0) : o = s = h = l = +n || 0, {
t: a(o, 0, r),
r: a(s, 0, e),
b: a(h, 0, r),
l: a(l, 0, e)
};
}(t, r / 2, n / 2);
return {
outer: {
x: e.left,
y: e.top,
w: r,
h: n
},
inner: {
x: e.left + o.l,
y: e.top + o.t,
w: r - o.l - o.r,
h: n - o.t - o.b
}
};
}
function l(t, e, i, r) {
var n = null === e,
o = null === i,
a = !(!t || n && o) && s(t, r);
return a && (n || e >= a.left && e <= a.right) && (o || i >= a.top && i <= a.bottom);
}
var d = /*#__PURE__*/function (_e$Element) {
function d(t) {
var _this;
_classCallCheck(this, d);
_this = _callSuper(this, d), _this.options = void 0, _this.width = void 0, _this.height = void 0, t && Object.assign(_assertThisInitialized(_this), t);
return _this;
}
_inherits(d, _e$Element);
return _createClass(d, [{
key: "draw",
value: function draw(t) {
var e = this.options,
_h = h(this),
r = _h.inner,
n = _h.outer,
o = i.toTRBLCorners(e.borderRadius);
t.save(), n.w !== r.w || n.h !== r.h ? (t.beginPath(), i.addRoundedRectPath(t, {
x: n.x,
y: n.y,
w: n.w,
h: n.h,
radius: o
}), i.addRoundedRectPath(t, {
x: r.x,
y: r.y,
w: r.w,
h: r.h,
radius: o
}), t.fillStyle = e.backgroundColor, t.fill(), t.fillStyle = e.borderColor, t.fill("evenodd")) : (t.beginPath(), i.addRoundedRectPath(t, {
x: r.x,
y: r.y,
w: r.w,
h: r.h,
radius: o
}), t.fillStyle = e.backgroundColor, t.fill()), t.restore();
}
}, {
key: "inRange",
value: function inRange(t, e, i) {
return l(this, t, e, i);
}
}, {
key: "inXRange",
value: function inXRange(t, e) {
return l(this, t, null, e);
}
}, {
key: "inYRange",
value: function inYRange(t, e) {
return l(this, null, t, e);
}
}, {
key: "getCenterPoint",
value: function getCenterPoint(t) {
var _this$getProps = this.getProps(["x", "y", "width", "height"], t),
e = _this$getProps.x,
i = _this$getProps.y,
r = _this$getProps.width,
n = _this$getProps.height;
return {
x: e + r / 2,
y: i + n / 2
};
}
}, {
key: "tooltipPosition",
value: function tooltipPosition() {
return this.getCenterPoint();
}
}, {
key: "getRange",
value: function getRange(t) {
return "x" === t ? this.width / 2 : this.height / 2;
}
}]);
}(e.Element);
_defineProperty(d, "id", "matrix");
_defineProperty(d, "defaults", {
backgroundColor: void 0,
borderColor: void 0,
borderWidth: void 0,
borderRadius: 0,
anchorX: "center",
anchorY: "center",
width: 20,
height: 20
});
e.Chart.register(r, d), t.MatrixController = r, t.MatrixElement = d;
});
jQuery(document).ready(function () {
var datePickerBtn = jQuery('.js-date-range-picker-btn');
var datePickerElement = jQuery('.js-date-range-picker-input');
var datePickerForm = jQuery('.js-date-range-picker-form');
if (datePickerBtn.length && datePickerElement.length && datePickerForm.length) {
datePickerBtn.on('click', function () {
datePickerElement.trigger('click');
});
datePickerElement.daterangepicker({
"autoApply": true,
"ranges": {
'Today': [moment(), moment()],
'Yesterday': [moment().subtract(1, 'days'), moment().subtract(1, 'days')],
'Last 7 Days': [moment().subtract(7, 'days'), moment()],
'Last 14 Days': [moment().subtract(14, 'days'), moment()],
'Last 30 Days': [moment().subtract(30, 'days'), moment()],
'Last Month': [moment().subtract(1, 'month').startOf('month'), moment().subtract(1, 'month').endOf('month')],
'Last 60 Days': [moment().subtract(60, 'days'), moment()],
'Last 90 Days': [moment().subtract(90, 'days'), moment()],
'Last 120 Days': [moment().subtract(120, 'days'), moment()],
'Last 6 Months': [moment().subtract(180, 'days'), moment()],
'This Year': [moment().startOf('year'), moment().endOf('year')]
}
});
if (wps_js.isset(wps_js.global, 'request_params', 'from') && wps_js.isset(wps_js.global, 'request_params', 'to')) {
var requestFromDate = wps_js.global.request_params.from;
var requestToDate = wps_js.global.request_params.to;
datePickerElement.data('daterangepicker').setStartDate(moment(requestFromDate).format('MM/DD/YYYY'));
datePickerElement.data('daterangepicker').setEndDate(moment(requestToDate).format('MM/DD/YYYY'));
datePickerElement.data('daterangepicker').updateCalendars();
var activeRangeText = datePickerElement.data('daterangepicker').container.find('.ranges li.active').text();
datePickerBtn.find('span').html(activeRangeText);
} else {
var defaultRange = datePickerBtn.find('span').text();
datePickerElement.data('daterangepicker').container.find('.ranges li.active').removeClass('active');
datePickerElement.data('daterangepicker').container.find('.ranges li[data-range-key="' + defaultRange + '"]').addClass('active');
datePickerElement.on('show.daterangepicker', function (ev, picker) {
datePickerElement.data('daterangepicker').container.find('.ranges li.active').removeClass('active');
datePickerElement.data('daterangepicker').container.find('.ranges li[data-range-key="' + defaultRange + '"]').addClass('active');
});
}
datePickerElement.on('show.daterangepicker', function (ev, picker) {
var correspondingPicker = picker.container;
jQuery(correspondingPicker).addClass(ev.target.className);
});
datePickerElement.on('apply.daterangepicker', function (ev, picker) {
var inputFrom = datePickerForm.find('.js-date-range-picker-input-from').first();
var inputTo = datePickerForm.find('.js-date-range-picker-input-to').first();
inputFrom.val(picker.startDate.format('YYYY-MM-DD'));
inputTo.val(picker.endDate.format('YYYY-MM-DD'));
datePickerBtn.find('span').html(datePickerElement.data('daterangepicker').chosenLabel);
datePickerForm.submit();
});
}

// Single Calendar
var datePickerField = jQuery('.wps-js-calendar-field');
if (datePickerField.length) {
datePickerField.daterangepicker({
singleDatePicker: true,
showDropdowns: true,
minYear: 1998,
maxYear: parseInt(new Date().getFullYear() + 1),
locale: {
format: 'YYYY-MM-DD'
}
});
datePickerField.on('show.daterangepicker', function (ev, picker) {
var correspondingPicker = picker.container;
jQuery(correspondingPicker).addClass(ev.target.className);
});
datePickerField.on('apply.daterangepicker', function (ev, picker) {
jQuery('.wps-today-datepicker').submit();
});
}
});
/**
 * tooltipster http://calebjacob.github.io/tooltipster/
 * A rockin' custom tooltip jQuery plugin
 * Developed by Caleb Jacob and Louis Ameline
 * MIT license
 */
(function (root, factory) {
if (typeof define === 'function' && define.amd) {
// AMD. Register as an anonymous module unless amdModuleId is set
define(["jquery"], function (a0) {
return factory(a0);
});
} else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object') {
// Node. Does not work with strict CommonJS, but
// only CommonJS-like environments that support module.exports,
// like Node.
module.exports = factory(require("jquery"));
} else {
factory(jQuery);
}
})(this, function ($) {
// This file will be UMDified by a build task.

var defaults = {
animation: 'fade',
animationDuration: 350,
content: null,
contentAsHTML: false,
contentCloning: false,
debug: true,
delay: 300,
delayTouch: [300, 500],
functionInit: null,
functionBefore: null,
functionReady: null,
functionAfter: null,
functionFormat: null,
IEmin: 6,
interactive: false,
multiple: false,
// will default to document.body, or must be an element positioned at (0, 0)
// in the document, typically like the very top views of an app.
parent: null,
plugins: ['sideTip'],
repositionOnScroll: false,
restoration: 'none',
selfDestruction: true,
theme: [],
timer: 0,
trackerInterval: 500,
trackOrigin: false,
trackTooltip: false,
trigger: 'hover',
triggerClose: {
click: false,
mouseleave: false,
originClick: false,
scroll: false,
tap: false,
touchleave: false
},
triggerOpen: {
click: false,
mouseenter: false,
tap: false,
touchstart: false
},
updateAnimation: 'rotate',
zIndex: 9999999
},
// we'll avoid using the 'window' global as a good practice but npm's
// jquery@<2.1.0 package actually requires a 'window' global, so not sure
// it's useful at all
win = typeof window != 'undefined' ? window : null,
// env will be proxied by the core for plugins to have access its properties
env = {
// detect if this device can trigger touch events. Better have a false
// positive (unused listeners, that's ok) than a false negative.
// https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js
// http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript
hasTouchCapability: !!(win && ('ontouchstart' in win || win.DocumentTouch && win.document instanceof win.DocumentTouch || win.navigator.maxTouchPoints)),
hasTransitions: transitionSupport(),
IE: false,
// don't set manually, it will be updated by a build task after the manifest
semVer: '4.2.8',
window: win
},
core = function core() {
// core variables

// the core emitters
this.__$emitterPrivate = $({});
this.__$emitterPublic = $({});
this.__instancesLatestArr = [];
// collects plugin constructors
this.__plugins = {};
// proxy env variables for plugins who might use them
this._env = env;
};

// core methods
core.prototype = {
/**
 * A function to proxy the public methods of an object onto another
 *
 * @param {object} constructor The constructor to bridge
 * @param {object} obj The object that will get new methods (an instance or the core)
 * @param {string} pluginName A plugin name for the console log message
 * @return {core}
 * @private
 */
__bridge: function __bridge(constructor, obj, pluginName) {
// if it's not already bridged
if (!obj[pluginName]) {
var fn = function fn() {};
fn.prototype = constructor;
var pluginInstance = new fn();

// the _init method has to exist in instance constructors but might be missing
// in core constructors
if (pluginInstance.__init) {
pluginInstance.__init(obj);
}
$.each(constructor, function (methodName, fn) {
// don't proxy "private" methods, only "protected" and public ones
if (methodName.indexOf('__') != 0) {
// if the method does not exist yet
if (!obj[methodName]) {
obj[methodName] = function () {
return pluginInstance[methodName].apply(pluginInstance, Array.prototype.slice.apply(arguments));
};

// remember to which plugin this method corresponds (several plugins may
// have methods of the same name, we need to be sure)
obj[methodName].bridged = pluginInstance;
} else if (defaults.debug) {
console.log('The ' + methodName + ' method of the ' + pluginName + ' plugin conflicts with another plugin or native methods');
}
}
});
obj[pluginName] = pluginInstance;
}
return this;
},
/**
 * For mockup in Node env if need be, for testing purposes
 *
 * @return {core}
 * @private
 */
__setWindow: function __setWindow(window) {
env.window = window;
return this;
},
/**
 * Returns a ruler, a tool to help measure the size of a tooltip under
 * various settings. Meant for plugins
 * 
 * @see Ruler
 * @return {object} A Ruler instance
 * @protected
 */
_getRuler: function _getRuler($tooltip) {
return new Ruler($tooltip);
},
/**
 * For internal use by plugins, if needed
 *
 * @return {core}
 * @protected
 */
_off: function _off() {
this.__$emitterPrivate.off.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
return this;
},
/**
 * For internal use by plugins, if needed
 *
 * @return {core}
 * @protected
 */
_on: function _on() {
this.__$emitterPrivate.on.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
return this;
},
/**
 * For internal use by plugins, if needed
 *
 * @return {core}
 * @protected
 */
_one: function _one() {
this.__$emitterPrivate.one.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
return this;
},
/**
 * Returns (getter) or adds (setter) a plugin
 *
 * @param {string|object} plugin Provide a string (in the full form
 * "namespace.name") to use as as getter, an object to use as a setter
 * @return {object|core}
 * @protected
 */
_plugin: function _plugin(plugin) {
var self = this;

// getter
if (typeof plugin == 'string') {
var pluginName = plugin,
p = null;

// if the namespace is provided, it's easy to search
if (pluginName.indexOf('.') > 0) {
p = self.__plugins[pluginName];
}
// otherwise, return the first name that matches
else {
$.each(self.__plugins, function (i, plugin) {
if (plugin.name.substring(plugin.name.length - pluginName.length - 1) == '.' + pluginName) {
p = plugin;
return false;
}
});
}
return p;
}
// setter
else {
// force namespaces
if (plugin.name.indexOf('.') < 0) {
throw new Error('Plugins must be namespaced');
}
self.__plugins[plugin.name] = plugin;

// if the plugin has core features
if (plugin.core) {
// bridge non-private methods onto the core to allow new core methods
self.__bridge(plugin.core, self, plugin.name);
}
return this;
}
},
/**
 * Trigger events on the core emitters
 * 
 * @returns {core}
 * @protected
 */
_trigger: function _trigger() {
var args = Array.prototype.slice.apply(arguments);
if (typeof args[0] == 'string') {
args[0] = {
type: args[0]
};
}

// note: the order of emitters matters
this.__$emitterPrivate.trigger.apply(this.__$emitterPrivate, args);
this.__$emitterPublic.trigger.apply(this.__$emitterPublic, args);
return this;
},
/**
 * Returns instances of all tooltips in the page or an a given element
 *
 * @param {string|HTML object collection} selector optional Use this
 * parameter to restrict the set of objects that will be inspected
 * for the retrieval of instances. By default, all instances in the
 * page are returned.
 * @return {array} An array of instance objects
 * @public
 */
instances: function instances(selector) {
var instances = [],
sel = selector || '.tooltipstered';
$(sel).each(function () {
var $this = $(this),
ns = $this.data('tooltipster-ns');
if (ns) {
$.each(ns, function (i, namespace) {
instances.push($this.data(namespace));
});
}
});
return instances;
},
/**
 * Returns the Tooltipster objects generated by the last initializing call
 *
 * @return {array} An array of instance objects
 * @public
 */
instancesLatest: function instancesLatest() {
return this.__instancesLatestArr;
},
/**
 * For public use only, not to be used by plugins (use ::_off() instead)
 *
 * @return {core}
 * @public
 */
off: function off() {
this.__$emitterPublic.off.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
return this;
},
/**
 * For public use only, not to be used by plugins (use ::_on() instead)
 *
 * @return {core}
 * @public
 */
on: function on() {
this.__$emitterPublic.on.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
return this;
},
/**
 * For public use only, not to be used by plugins (use ::_one() instead)
 * 
 * @return {core}
 * @public
 */
one: function one() {
this.__$emitterPublic.one.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
return this;
},
/**
 * Returns all HTML elements which have one or more tooltips
 *
 * @param {string} selector optional Use this to restrict the results
 * to the descendants of an element
 * @return {array} An array of HTML elements
 * @public
 */
origins: function origins(selector) {
var sel = selector ? selector + ' ' : '';
return $(sel + '.tooltipstered').toArray();
},
/**
 * Change default options for all future instances
 *
 * @param {object} d The options that should be made defaults
 * @return {core}
 * @public
 */
setDefaults: function setDefaults(d) {
$.extend(defaults, d);
return this;
},
/**
 * For users to trigger their handlers on the public emitter
 * 
 * @returns {core}
 * @public
 */
triggerHandler: function triggerHandler() {
this.__$emitterPublic.triggerHandler.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
return this;
}
};

// $.tooltipster will be used to call core methods
$.tooltipster = new core();

// the Tooltipster instance class (mind the capital T)
$.Tooltipster = function (element, options) {
// list of instance variables

// stack of custom callbacks provided as parameters to API methods
this.__callbacks = {
close: [],
open: []
};
// the schedule time of DOM removal
this.__closingTime;
// this will be the user content shown in the tooltip. A capital "C" is used
// because there is also a method called content()
this.__Content;
// for the size tracker
this.__contentBcr;
// to disable the tooltip after destruction
this.__destroyed = false;
// we can't emit directly on the instance because if a method with the same
// name as the event exists, it will be called by jQuery. Se we use a plain
// object as emitter. This emitter is for internal use by plugins,
// if needed.
this.__$emitterPrivate = $({});
// this emitter is for the user to listen to events without risking to mess
// with our internal listeners
this.__$emitterPublic = $({});
this.__enabled = true;
// the reference to the gc interval
this.__garbageCollector;
// various position and size data recomputed before each repositioning
this.__Geometry;
// the tooltip position, saved after each repositioning by a plugin
this.__lastPosition;
// a unique namespace per instance
this.__namespace = 'tooltipster-' + Math.round(Math.random() * 1000000);
this.__options;
// will be used to support origins in scrollable areas
this.__$originParents;
this.__pointerIsOverOrigin = false;
// to remove themes if needed
this.__previousThemes = [];
// the state can be either: appearing, stable, disappearing, closed
this.__state = 'closed';
// timeout references
this.__timeouts = {
close: [],
open: null
};
// store touch events to be able to detect emulated mouse events
this.__touchEvents = [];
// the reference to the tracker interval
this.__tracker = null;
// the element to which this tooltip is associated
this._$origin;
// this will be the tooltip element (jQuery wrapped HTML element).
// It's the job of a plugin to create it and append it to the DOM
this._$tooltip;

// launch
this.__init(element, options);
};
$.Tooltipster.prototype = {
/**
 * @param origin
 * @param options
 * @private
 */
__init: function __init(origin, options) {
var self = this;
self._$origin = $(origin);
self.__options = $.extend(true, {}, defaults, options);

// some options may need to be reformatted
self.__optionsFormat();

// don't run on old IE if asked no to
if (!env.IE || env.IE >= self.__options.IEmin) {
// note: the content is null (empty) by default and can stay that
// way if the plugin remains initialized but not fed any content. The
// tooltip will just not appear.

// let's save the initial value of the title attribute for later
// restoration if need be.
var initialTitle = null;

// it will already have been saved in case of multiple tooltips
if (self._$origin.data('tooltipster-initialTitle') === undefined) {
initialTitle = self._$origin.attr('title');

// we do not want initialTitle to be "undefined" because
// of how jQuery's .data() method works
if (initialTitle === undefined) initialTitle = null;
self._$origin.data('tooltipster-initialTitle', initialTitle);
}

// If content is provided in the options, it has precedence over the
// title attribute.
// Note: an empty string is considered content, only 'null' represents
// the absence of content.
// Also, an existing title="" attribute will result in an empty string
// content
if (self.__options.content !== null) {
self.__contentSet(self.__options.content);
} else {
var selector = self._$origin.attr('data-tooltip-content'),
$el;
if (selector) {
$el = $(selector);
}
if ($el && $el[0]) {
self.__contentSet($el.first());
} else {
self.__contentSet(initialTitle);
}
}
self._$origin
// strip the title off of the element to prevent the default tooltips
// from popping up
.removeAttr('title')
// to be able to find all instances on the page later (upon window
// events in particular)
.addClass('tooltipstered');

// set listeners on the origin
self.__prepareOrigin();

// set the garbage collector
self.__prepareGC();

// init plugins
$.each(self.__options.plugins, function (i, pluginName) {
self._plug(pluginName);
});

// to detect swiping
if (env.hasTouchCapability) {
$(env.window.document.body).on('touchmove.' + self.__namespace + '-triggerOpen', function (event) {
self._touchRecordEvent(event);
});
}
self
// prepare the tooltip when it gets created. This event must
// be fired by a plugin
._on('created', function () {
self.__prepareTooltip();
})
// save position information when it's sent by a plugin
._on('repositioned', function (e) {
self.__lastPosition = e.position;
});
} else {
self.__options.disabled = true;
}
},
/**
 * Insert the content into the appropriate HTML element of the tooltip
 * 
 * @returns {self}
 * @private
 */
__contentInsert: function __contentInsert() {
var self = this,
$el = self._$tooltip.find('.tooltipster-content'),
formattedContent = self.__Content,
format = function format(content) {
formattedContent = content;
};
self._trigger({
type: 'format',
content: self.__Content,
format: format
});
if (self.__options.functionFormat) {
formattedContent = self.__options.functionFormat.call(self, self, {
origin: self._$origin[0]
}, self.__Content);
}
if (typeof formattedContent === 'string' && !self.__options.contentAsHTML) {
$el.text(formattedContent);
} else {
$el.empty().append(formattedContent);
}
return self;
},
/**
 * Save the content, cloning it beforehand if need be
 * 
 * @param content
 * @returns {self}
 * @private
 */
__contentSet: function __contentSet(content) {
// clone if asked. Cloning the object makes sure that each instance has its
// own version of the content (in case a same object were provided for several
// instances)
// reminder: typeof null === object
if (content instanceof $ && this.__options.contentCloning) {
content = content.clone(true);
}
this.__Content = content;
this._trigger({
type: 'updated',
content: content
});
return this;
},
/**
 * Error message about a method call made after destruction
 * 
 * @private
 */
__destroyError: function __destroyError() {
throw new Error('This tooltip has been destroyed and cannot execute your method call.');
},
/**
 * Gather all information about dimensions and available space,
 * called before every repositioning
 * 
 * @private
 * @returns {object}
 */
__geometry: function __geometry() {
var self = this,
$target = self._$origin,
originIsArea = self._$origin.is('area');

// if this._$origin is a map area, the target we'll need
// the dimensions of is actually the image using the map,
// not the area itself
if (originIsArea) {
var mapName = self._$origin.parent().attr('name');
$target = $('img[usemap="#' + mapName + '"]');
}
var bcr = $target[0].getBoundingClientRect(),
$document = $(env.window.document),
$window = $(env.window),
$parent = $target,
// some useful properties of important elements
geo = {
// available space for the tooltip, see down below
available: {
document: null,
window: null
},
document: {
size: {
height: $document.height(),
width: $document.width()
}
},
window: {
scroll: {
// the second ones are for IE compatibility
left: env.window.scrollX || env.window.document.documentElement.scrollLeft,
top: env.window.scrollY || env.window.document.documentElement.scrollTop
},
size: {
height: $window.height(),
width: $window.width()
}
},
origin: {
// the origin has a fixed lineage if itself or one of its
// ancestors has a fixed position
fixedLineage: false,
// relative to the document
offset: {},
size: {
height: bcr.bottom - bcr.top,
width: bcr.right - bcr.left
},
usemapImage: originIsArea ? $target[0] : null,
// relative to the window
windowOffset: {
bottom: bcr.bottom,
left: bcr.left,
right: bcr.right,
top: bcr.top
}
}
},
geoFixed = false;

// if the element is a map area, some properties may need
// to be recalculated
if (originIsArea) {
var shape = self._$origin.attr('shape'),
coords = self._$origin.attr('coords');
if (coords) {
coords = coords.split(',');
$.map(coords, function (val, i) {
coords[i] = parseInt(val);
});
}

// if the image itself is the area, nothing more to do
if (shape != 'default') {
switch (shape) {
case 'circle':
var circleCenterLeft = coords[0],
circleCenterTop = coords[1],
circleRadius = coords[2],
areaTopOffset = circleCenterTop - circleRadius,
areaLeftOffset = circleCenterLeft - circleRadius;
geo.origin.size.height = circleRadius * 2;
geo.origin.size.width = geo.origin.size.height;
geo.origin.windowOffset.left += areaLeftOffset;
geo.origin.windowOffset.top += areaTopOffset;
break;
case 'rect':
var areaLeft = coords[0],
areaTop = coords[1],
areaRight = coords[2],
areaBottom = coords[3];
geo.origin.size.height = areaBottom - areaTop;
geo.origin.size.width = areaRight - areaLeft;
geo.origin.windowOffset.left += areaLeft;
geo.origin.windowOffset.top += areaTop;
break;
case 'poly':
var areaSmallestX = 0,
areaSmallestY = 0,
areaGreatestX = 0,
areaGreatestY = 0,
arrayAlternate = 'even';
for (var i = 0; i < coords.length; i++) {
var areaNumber = coords[i];
if (arrayAlternate == 'even') {
if (areaNumber > areaGreatestX) {
areaGreatestX = areaNumber;
if (i === 0) {
areaSmallestX = areaGreatestX;
}
}
if (areaNumber < areaSmallestX) {
areaSmallestX = areaNumber;
}
arrayAlternate = 'odd';
} else {
if (areaNumber > areaGreatestY) {
areaGreatestY = areaNumber;
if (i == 1) {
areaSmallestY = areaGreatestY;
}
}
if (areaNumber < areaSmallestY) {
areaSmallestY = areaNumber;
}
arrayAlternate = 'even';
}
}
geo.origin.size.height = areaGreatestY - areaSmallestY;
geo.origin.size.width = areaGreatestX - areaSmallestX;
geo.origin.windowOffset.left += areaSmallestX;
geo.origin.windowOffset.top += areaSmallestY;
break;
}
}
}

// user callback through an event
var edit = function edit(r) {
geo.origin.size.height = r.height, geo.origin.windowOffset.left = r.left, geo.origin.windowOffset.top = r.top, geo.origin.size.width = r.width;
};
self._trigger({
type: 'geometry',
edit: edit,
geometry: {
height: geo.origin.size.height,
left: geo.origin.windowOffset.left,
top: geo.origin.windowOffset.top,
width: geo.origin.size.width
}
});

// calculate the remaining properties with what we got

geo.origin.windowOffset.right = geo.origin.windowOffset.left + geo.origin.size.width;
geo.origin.windowOffset.bottom = geo.origin.windowOffset.top + geo.origin.size.height;
geo.origin.offset.left = geo.origin.windowOffset.left + geo.window.scroll.left;
geo.origin.offset.top = geo.origin.windowOffset.top + geo.window.scroll.top;
geo.origin.offset.bottom = geo.origin.offset.top + geo.origin.size.height;
geo.origin.offset.right = geo.origin.offset.left + geo.origin.size.width;

// the space that is available to display the tooltip relatively to the document
geo.available.document = {
bottom: {
height: geo.document.size.height - geo.origin.offset.bottom,
width: geo.document.size.width
},
left: {
height: geo.document.size.height,
width: geo.origin.offset.left
},
right: {
height: geo.document.size.height,
width: geo.document.size.width - geo.origin.offset.right
},
top: {
height: geo.origin.offset.top,
width: geo.document.size.width
}
};

// the space that is available to display the tooltip relatively to the viewport
// (the resulting values may be negative if the origin overflows the viewport)
geo.available.window = {
bottom: {
// the inner max is here to make sure the available height is no bigger
// than the viewport height (when the origin is off screen at the top).
// The outer max just makes sure that the height is not negative (when
// the origin overflows at the bottom).
height: Math.max(geo.window.size.height - Math.max(geo.origin.windowOffset.bottom, 0), 0),
width: geo.window.size.width
},
left: {
height: geo.window.size.height,
width: Math.max(geo.origin.windowOffset.left, 0)
},
right: {
height: geo.window.size.height,
width: Math.max(geo.window.size.width - Math.max(geo.origin.windowOffset.right, 0), 0)
},
top: {
height: Math.max(geo.origin.windowOffset.top, 0),
width: geo.window.size.width
}
};
while ($parent[0].tagName.toLowerCase() != 'html') {
if ($parent.css('position') == 'fixed') {
geo.origin.fixedLineage = true;
break;
}
$parent = $parent.parent();
}
return geo;
},
/**
 * Some options may need to be formated before being used
 * 
 * @returns {self}
 * @private
 */
__optionsFormat: function __optionsFormat() {
if (typeof this.__options.animationDuration == 'number') {
this.__options.animationDuration = [this.__options.animationDuration, this.__options.animationDuration];
}
if (typeof this.__options.delay == 'number') {
this.__options.delay = [this.__options.delay, this.__options.delay];
}
if (typeof this.__options.delayTouch == 'number') {
this.__options.delayTouch = [this.__options.delayTouch, this.__options.delayTouch];
}
if (typeof this.__options.theme == 'string') {
this.__options.theme = [this.__options.theme];
}

// determine the future parent
if (this.__options.parent === null) {
this.__options.parent = $(env.window.document.body);
} else if (typeof this.__options.parent == 'string') {
this.__options.parent = $(this.__options.parent);
}
if (this.__options.trigger == 'hover') {
this.__options.triggerOpen = {
mouseenter: true,
touchstart: true
};
this.__options.triggerClose = {
mouseleave: true,
originClick: true,
touchleave: true
};
} else if (this.__options.trigger == 'click') {
this.__options.triggerOpen = {
click: true,
tap: true
};
this.__options.triggerClose = {
click: true,
tap: true
};
}

// for the plugins
this._trigger('options');
return this;
},
/**
 * Schedules or cancels the garbage collector task
 *
 * @returns {self}
 * @private
 */
__prepareGC: function __prepareGC() {
var self = this;

// in case the selfDestruction option has been changed by a method call
if (self.__options.selfDestruction) {
// the GC task
self.__garbageCollector = setInterval(function () {
var now = new Date().getTime();

// forget the old events
self.__touchEvents = $.grep(self.__touchEvents, function (event, i) {
// 1 minute
return now - event.time > 60000;
});

// auto-destruct if the origin is gone
if (!bodyContains(self._$origin)) {
self.close(function () {
self.destroy();
});
}
}, 20000);
} else {
clearInterval(self.__garbageCollector);
}
return self;
},
/**
 * Sets listeners on the origin if the open triggers require them.
 * Unlike the listeners set at opening time, these ones
 * remain even when the tooltip is closed. It has been made a
 * separate method so it can be called when the triggers are
 * changed in the options. Closing is handled in _open()
 * because of the bindings that may be needed on the tooltip
 * itself
 *
 * @returns {self}
 * @private
 */
__prepareOrigin: function __prepareOrigin() {
var self = this;

// in case we're resetting the triggers
self._$origin.off('.' + self.__namespace + '-triggerOpen');

// if the device is touch capable, even if only mouse triggers
// are asked, we need to listen to touch events to know if the mouse
// events are actually emulated (so we can ignore them)
if (env.hasTouchCapability) {
self._$origin.on('touchstart.' + self.__namespace + '-triggerOpen ' + 'touchend.' + self.__namespace + '-triggerOpen ' + 'touchcancel.' + self.__namespace + '-triggerOpen', function (event) {
self._touchRecordEvent(event);
});
}

// mouse click and touch tap work the same way
if (self.__options.triggerOpen.click || self.__options.triggerOpen.tap && env.hasTouchCapability) {
var eventNames = '';
if (self.__options.triggerOpen.click) {
eventNames += 'click.' + self.__namespace + '-triggerOpen ';
}
if (self.__options.triggerOpen.tap && env.hasTouchCapability) {
eventNames += 'touchend.' + self.__namespace + '-triggerOpen';
}
self._$origin.on(eventNames, function (event) {
if (self._touchIsMeaningfulEvent(event)) {
self._open(event);
}
});
}

// mouseenter and touch start work the same way
if (self.__options.triggerOpen.mouseenter || self.__options.triggerOpen.touchstart && env.hasTouchCapability) {
var eventNames = '';
if (self.__options.triggerOpen.mouseenter) {
eventNames += 'mouseenter.' + self.__namespace + '-triggerOpen ';
}
if (self.__options.triggerOpen.touchstart && env.hasTouchCapability) {
eventNames += 'touchstart.' + self.__namespace + '-triggerOpen';
}
self._$origin.on(eventNames, function (event) {
if (self._touchIsTouchEvent(event) || !self._touchIsEmulatedEvent(event)) {
self.__pointerIsOverOrigin = true;
self._openShortly(event);
}
});
}

// info for the mouseleave/touchleave close triggers when they use a delay
if (self.__options.triggerClose.mouseleave || self.__options.triggerClose.touchleave && env.hasTouchCapability) {
var eventNames = '';
if (self.__options.triggerClose.mouseleave) {
eventNames += 'mouseleave.' + self.__namespace + '-triggerOpen ';
}
if (self.__options.triggerClose.touchleave && env.hasTouchCapability) {
eventNames += 'touchend.' + self.__namespace + '-triggerOpen touchcancel.' + self.__namespace + '-triggerOpen';
}
self._$origin.on(eventNames, function (event) {
if (self._touchIsMeaningfulEvent(event)) {
self.__pointerIsOverOrigin = false;
}
});
}
return self;
},
/**
 * Do the things that need to be done only once after the tooltip
 * HTML element it has been created. It has been made a separate
 * method so it can be called when options are changed. Remember
 * that the tooltip may actually exist in the DOM before it is
 * opened, and present after it has been closed: it's the display
 * plugin that takes care of handling it.
 * 
 * @returns {self}
 * @private
 */
__prepareTooltip: function __prepareTooltip() {
var self = this,
p = self.__options.interactive ? 'auto' : '';

// this will be useful to know quickly if the tooltip is in
// the DOM or not 
self._$tooltip.attr('id', self.__namespace).css({
// pointer events
'pointer-events': p,
zIndex: self.__options.zIndex
});

// themes
// remove the old ones and add the new ones
$.each(self.__previousThemes, function (i, theme) {
self._$tooltip.removeClass(theme);
});
$.each(self.__options.theme, function (i, theme) {
self._$tooltip.addClass(theme);
});
self.__previousThemes = $.merge([], self.__options.theme);
return self;
},
/**
 * Handles the scroll on any of the parents of the origin (when the
 * tooltip is open)
 *
 * @param {object} event
 * @returns {self}
 * @private
 */
__scrollHandler: function __scrollHandler(event) {
var self = this;
if (self.__options.triggerClose.scroll) {
self._close(event);
} else {
// if the origin or tooltip have been removed: do nothing, the tracker will
// take care of it later
if (bodyContains(self._$origin) && bodyContains(self._$tooltip)) {
var geo = null;

// if the scroll happened on the window
if (event.target === env.window.document) {
// if the origin has a fixed lineage, window scroll will have no
// effect on its position nor on the position of the tooltip
if (!self.__Geometry.origin.fixedLineage) {
// we don't need to do anything unless repositionOnScroll is true
// because the tooltip will already have moved with the window
// (and of course with the origin)
if (self.__options.repositionOnScroll) {
self.reposition(event);
}
}
}
// if the scroll happened on another parent of the tooltip, it means
// that it's in a scrollable area and now needs to have its position
// adjusted or recomputed, depending ont the repositionOnScroll
// option. Also, if the origin is partly hidden due to a parent that
// hides its overflow, we'll just hide (not close) the tooltip.
else {
geo = self.__geometry();
var overflows = false;

// a fixed position origin is not affected by the overflow hiding
// of a parent
if (self._$origin.css('position') != 'fixed') {
self.__$originParents.each(function (i, el) {
var $el = $(el),
overflowX = $el.css('overflow-x'),
overflowY = $el.css('overflow-y');
if (overflowX != 'visible' || overflowY != 'visible') {
var bcr = el.getBoundingClientRect();
if (overflowX != 'visible') {
if (geo.origin.windowOffset.left < bcr.left || geo.origin.windowOffset.right > bcr.right) {
overflows = true;
return false;
}
}
if (overflowY != 'visible') {
if (geo.origin.windowOffset.top < bcr.top || geo.origin.windowOffset.bottom > bcr.bottom) {
overflows = true;
return false;
}
}
}

// no need to go further if fixed, for the same reason as above
if ($el.css('position') == 'fixed') {
return false;
}
});
}
if (overflows) {
self._$tooltip.css('visibility', 'hidden');
} else {
self._$tooltip.css('visibility', 'visible');

// reposition
if (self.__options.repositionOnScroll) {
self.reposition(event);
}
// or just adjust offset
else {
// we have to use offset and not windowOffset because this way,
// only the scroll distance of the scrollable areas are taken into
// account (the scrolltop value of the main window must be
// ignored since the tooltip already moves with it)
var offsetLeft = geo.origin.offset.left - self.__Geometry.origin.offset.left,
offsetTop = geo.origin.offset.top - self.__Geometry.origin.offset.top;

// add the offset to the position initially computed by the display plugin
self._$tooltip.css({
left: self.__lastPosition.coord.left + offsetLeft,
top: self.__lastPosition.coord.top + offsetTop
});
}
}
}
self._trigger({
type: 'scroll',
event: event,
geo: geo
});
}
}
return self;
},
/**
 * Changes the state of the tooltip
 *
 * @param {string} state
 * @returns {self}
 * @private
 */
__stateSet: function __stateSet(state) {
this.__state = state;
this._trigger({
type: 'state',
state: state
});
return this;
},
/**
 * Clear appearance timeouts
 *
 * @returns {self}
 * @private
 */
__timeoutsClear: function __timeoutsClear() {
// there is only one possible open timeout: the delayed opening
// when the mouseenter/touchstart open triggers are used
clearTimeout(this.__timeouts.open);
this.__timeouts.open = null;

// ... but several close timeouts: the delayed closing when the
// mouseleave close trigger is used and the timer option
$.each(this.__timeouts.close, function (i, timeout) {
clearTimeout(timeout);
});
this.__timeouts.close = [];
return this;
},
/**
 * Start the tracker that will make checks at regular intervals
 * 
 * @returns {self}
 * @private
 */
__trackerStart: function __trackerStart() {
var self = this,
$content = self._$tooltip.find('.tooltipster-content');

// get the initial content size
if (self.__options.trackTooltip) {
self.__contentBcr = $content[0].getBoundingClientRect();
}
self.__tracker = setInterval(function () {
// if the origin or tooltip elements have been removed.
// Note: we could destroy the instance now if the origin has
// been removed but we'll leave that task to our garbage collector
if (!bodyContains(self._$origin) || !bodyContains(self._$tooltip)) {
self._close();
}
// if everything is alright
else {
// compare the former and current positions of the origin to reposition
// the tooltip if need be
if (self.__options.trackOrigin) {
var g = self.__geometry(),
identical = false;

// compare size first (a change requires repositioning too)
if (areEqual(g.origin.size, self.__Geometry.origin.size)) {
// for elements that have a fixed lineage (see __geometry()), we track the
// top and left properties (relative to window)
if (self.__Geometry.origin.fixedLineage) {
if (areEqual(g.origin.windowOffset, self.__Geometry.origin.windowOffset)) {
identical = true;
}
}
// otherwise, track total offset (relative to document)
else {
if (areEqual(g.origin.offset, self.__Geometry.origin.offset)) {
identical = true;
}
}
}
if (!identical) {
// close the tooltip when using the mouseleave close trigger
// (see https://github.com/calebjacob/tooltipster/pull/253)
if (self.__options.triggerClose.mouseleave) {
self._close();
} else {
self.reposition();
}
}
}
if (self.__options.trackTooltip) {
var currentBcr = $content[0].getBoundingClientRect();
if (currentBcr.height !== self.__contentBcr.height || currentBcr.width !== self.__contentBcr.width) {
self.reposition();
self.__contentBcr = currentBcr;
}
}
}
}, self.__options.trackerInterval);
return self;
},
/**
 * Closes the tooltip (after the closing delay)
 * 
 * @param event
 * @param callback
 * @param force Set to true to override a potential refusal of the user's function
 * @returns {self}
 * @protected
 */
_close: function _close(event, callback, force) {
var self = this,
ok = true;
self._trigger({
type: 'close',
event: event,
stop: function stop() {
ok = false;
}
});

// a destroying tooltip (force == true) may not refuse to close
if (ok || force) {
// save the method custom callback and cancel any open method custom callbacks
if (callback) self.__callbacks.close.push(callback);
self.__callbacks.open = [];

// clear open/close timeouts
self.__timeoutsClear();
var finishCallbacks = function finishCallbacks() {
// trigger any close method custom callbacks and reset them
$.each(self.__callbacks.close, function (i, c) {
c.call(self, self, {
event: event,
origin: self._$origin[0]
});
});
self.__callbacks.close = [];
};
if (self.__state != 'closed') {
var necessary = true,
d = new Date(),
now = d.getTime(),
newClosingTime = now + self.__options.animationDuration[1];

// the tooltip may already already be disappearing, but if a new
// call to close() is made after the animationDuration was changed
// to 0 (for example), we ought to actually close it sooner than
// previously scheduled. In that case it should be noted that the
// browser will not adapt the animation duration to the new
// animationDuration that was set after the start of the closing
// animation.
// Note: the same thing could be considered at opening, but is not
// really useful since the tooltip is actually opened immediately
// upon a call to _open(). Since it would not make the opening
// animation finish sooner, its sole impact would be to trigger the
// state event and the open callbacks sooner than the actual end of
// the opening animation, which is not great.
if (self.__state == 'disappearing') {
if (newClosingTime > self.__closingTime
// in case closing is actually overdue because the script
// execution was suspended. See #679
&& self.__options.animationDuration[1] > 0) {
necessary = false;
}
}
if (necessary) {
self.__closingTime = newClosingTime;
if (self.__state != 'disappearing') {
self.__stateSet('disappearing');
}
var finish = function finish() {
// stop the tracker
clearInterval(self.__tracker);

// a "beforeClose" option has been asked several times but would
// probably useless since the content element is still accessible
// via ::content(), and because people can always use listeners
// inside their content to track what's going on. For the sake of
// simplicity, this has been denied. Bur for the rare people who
// really need the option (for old browsers or for the case where
// detaching the content is actually destructive, for file or
// password inputs for example), this event will do the work.
self._trigger({
type: 'closing',
event: event
});

// unbind listeners which are no longer needed

self._$tooltip.off('.' + self.__namespace + '-triggerClose').removeClass('tooltipster-dying');

// orientationchange, scroll and resize listeners
$(env.window).off('.' + self.__namespace + '-triggerClose');

// scroll listeners
self.__$originParents.each(function (i, el) {
$(el).off('scroll.' + self.__namespace + '-triggerClose');
});
// clear the array to prevent memory leaks
self.__$originParents = null;
$(env.window.document.body).off('.' + self.__namespace + '-triggerClose');
self._$origin.off('.' + self.__namespace + '-triggerClose');
self._off('dismissable');

// a plugin that would like to remove the tooltip from the
// DOM when closed should bind on this
self.__stateSet('closed');

// trigger event
self._trigger({
type: 'after',
event: event
});

// call our constructor custom callback function
if (self.__options.functionAfter) {
self.__options.functionAfter.call(self, self, {
event: event,
origin: self._$origin[0]
});
}

// call our method custom callbacks functions
finishCallbacks();
};
if (env.hasTransitions) {
self._$tooltip.css({
'-moz-animation-duration': self.__options.animationDuration[1] + 'ms',
'-ms-animation-duration': self.__options.animationDuration[1] + 'ms',
'-o-animation-duration': self.__options.animationDuration[1] + 'ms',
'-webkit-animation-duration': self.__options.animationDuration[1] + 'ms',
'animation-duration': self.__options.animationDuration[1] + 'ms',
'transition-duration': self.__options.animationDuration[1] + 'ms'
});
self._$tooltip
// clear both potential open and close tasks
.clearQueue().removeClass('tooltipster-show')
// for transitions only
.addClass('tooltipster-dying');
if (self.__options.animationDuration[1] > 0) {
self._$tooltip.delay(self.__options.animationDuration[1]);
}
self._$tooltip.queue(finish);
} else {
self._$tooltip.stop().fadeOut(self.__options.animationDuration[1], finish);
}
}
}
// if the tooltip is already closed, we still need to trigger
// the method custom callbacks
else {
finishCallbacks();
}
}
return self;
},
/**
 * For internal use by plugins, if needed
 * 
 * @returns {self}
 * @protected
 */
_off: function _off() {
this.__$emitterPrivate.off.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
return this;
},
/**
 * For internal use by plugins, if needed
 *
 * @returns {self}
 * @protected
 */
_on: function _on() {
this.__$emitterPrivate.on.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
return this;
},
/**
 * For internal use by plugins, if needed
 *
 * @returns {self}
 * @protected
 */
_one: function _one() {
this.__$emitterPrivate.one.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
return this;
},
/**
 * Opens the tooltip right away.
 *
 * @param event
 * @param callback Will be called when the opening animation is over
 * @returns {self}
 * @protected
 */
_open: function _open(event, callback) {
var self = this;

// if the destruction process has not begun and if this was not
// triggered by an unwanted emulated click event
if (!self.__destroying) {
// check that the origin is still in the DOM
if (bodyContains(self._$origin)
// if the tooltip is enabled
&& self.__enabled) {
var ok = true;

// if the tooltip is not open yet, we need to call functionBefore.
// otherwise we can jst go on
if (self.__state == 'closed') {
// trigger an event. The event.stop function allows the callback
// to prevent the opening of the tooltip
self._trigger({
type: 'before',
event: event,
stop: function stop() {
ok = false;
}
});
if (ok && self.__options.functionBefore) {
// call our custom function before continuing
ok = self.__options.functionBefore.call(self, self, {
event: event,
origin: self._$origin[0]
});
}
}
if (ok !== false) {
// if there is some content
if (self.__Content !== null) {
// save the method callback and cancel close method callbacks
if (callback) {
self.__callbacks.open.push(callback);
}
self.__callbacks.close = [];

// get rid of any appearance timeouts
self.__timeoutsClear();
var extraTime,
finish = function finish() {
if (self.__state != 'stable') {
self.__stateSet('stable');
}

// trigger any open method custom callbacks and reset them
$.each(self.__callbacks.open, function (i, c) {
c.call(self, self, {
origin: self._$origin[0],
tooltip: self._$tooltip[0]
});
});
self.__callbacks.open = [];
};

// if the tooltip is already open
if (self.__state !== 'closed') {
// the timer (if any) will start (or restart) right now
extraTime = 0;

// if it was disappearing, cancel that
if (self.__state === 'disappearing') {
self.__stateSet('appearing');
if (env.hasTransitions) {
self._$tooltip.clearQueue().removeClass('tooltipster-dying').addClass('tooltipster-show');
if (self.__options.animationDuration[0] > 0) {
self._$tooltip.delay(self.__options.animationDuration[0]);
}
self._$tooltip.queue(finish);
} else {
// in case the tooltip was currently fading out, bring it back
// to life
self._$tooltip.stop().fadeIn(finish);
}
}
// if the tooltip is already open, we still need to trigger the method
// custom callback
else if (self.__state == 'stable') {
finish();
}
}
// if the tooltip isn't already open, open it
else {
// a plugin must bind on this and store the tooltip in this._$tooltip
self.__stateSet('appearing');

// the timer (if any) will start when the tooltip has fully appeared
// after its transition
extraTime = self.__options.animationDuration[0];

// insert the content inside the tooltip
self.__contentInsert();

// reposition the tooltip and attach to the DOM
self.reposition(event, true);

// animate in the tooltip. If the display plugin wants no css
// animations, it may override the animation option with a
// dummy value that will produce no effect
if (env.hasTransitions) {
// note: there seems to be an issue with start animations which
// are randomly not played on fast devices in both Chrome and FF,
// couldn't find a way to solve it yet. It seems that applying
// the classes before appending to the DOM helps a little, but
// it messes up some CSS transitions. The issue almost never
// happens when delay[0]==0 though
self._$tooltip.addClass('tooltipster-' + self.__options.animation).addClass('tooltipster-initial').css({
'-moz-animation-duration': self.__options.animationDuration[0] + 'ms',
'-ms-animation-duration': self.__options.animationDuration[0] + 'ms',
'-o-animation-duration': self.__options.animationDuration[0] + 'ms',
'-webkit-animation-duration': self.__options.animationDuration[0] + 'ms',
'animation-duration': self.__options.animationDuration[0] + 'ms',
'transition-duration': self.__options.animationDuration[0] + 'ms'
});
setTimeout(function () {
// a quick hover may have already triggered a mouseleave
if (self.__state != 'closed') {
self._$tooltip.addClass('tooltipster-show').removeClass('tooltipster-initial');
if (self.__options.animationDuration[0] > 0) {
self._$tooltip.delay(self.__options.animationDuration[0]);
}
self._$tooltip.queue(finish);
}
}, 0);
} else {
// old browsers will have to live with this
self._$tooltip.css('display', 'none').fadeIn(self.__options.animationDuration[0], finish);
}

// checks if the origin is removed while the tooltip is open
self.__trackerStart();

// NOTE: the listeners below have a '-triggerClose' namespace
// because we'll remove them when the tooltip closes (unlike
// the '-triggerOpen' listeners). So some of them are actually
// not about close triggers, rather about positioning.

$(env.window)
// reposition on resize
.on('resize.' + self.__namespace + '-triggerClose', function (e) {
var $ae = $(document.activeElement);

// reposition only if the resize event was not triggered upon the opening
// of a virtual keyboard due to an input field being focused within the tooltip
// (otherwise the repositioning would lose the focus)
if (!$ae.is('input') && !$ae.is('textarea') || !$.contains(self._$tooltip[0], $ae[0])) {
self.reposition(e);
}
})
// same as below for parents
.on('scroll.' + self.__namespace + '-triggerClose', function (e) {
self.__scrollHandler(e);
});
self.__$originParents = self._$origin.parents();

// scrolling may require the tooltip to be moved or even
// repositioned in some cases
self.__$originParents.each(function (i, parent) {
$(parent).on('scroll.' + self.__namespace + '-triggerClose', function (e) {
self.__scrollHandler(e);
});
});
if (self.__options.triggerClose.mouseleave || self.__options.triggerClose.touchleave && env.hasTouchCapability) {
// we use an event to allow users/plugins to control when the mouseleave/touchleave
// close triggers will come to action. It allows to have more triggering elements
// than just the origin and the tooltip for example, or to cancel/delay the closing,
// or to make the tooltip interactive even if it wasn't when it was open, etc.
self._on('dismissable', function (event) {
if (event.dismissable) {
if (event.delay) {
timeout = setTimeout(function () {
// event.event may be undefined
self._close(event.event);
}, event.delay);
self.__timeouts.close.push(timeout);
} else {
self._close(event);
}
} else {
clearTimeout(timeout);
}
});

// now set the listeners that will trigger 'dismissable' events
var $elements = self._$origin,
eventNamesIn = '',
eventNamesOut = '',
timeout = null;

// if we have to allow interaction, bind on the tooltip too
if (self.__options.interactive) {
$elements = $elements.add(self._$tooltip);
}
if (self.__options.triggerClose.mouseleave) {
eventNamesIn += 'mouseenter.' + self.__namespace + '-triggerClose ';
eventNamesOut += 'mouseleave.' + self.__namespace + '-triggerClose ';
}
if (self.__options.triggerClose.touchleave && env.hasTouchCapability) {
eventNamesIn += 'touchstart.' + self.__namespace + '-triggerClose';
eventNamesOut += 'touchend.' + self.__namespace + '-triggerClose touchcancel.' + self.__namespace + '-triggerClose';
}
$elements
// close after some time spent outside of the elements
.on(eventNamesOut, function (event) {
// it's ok if the touch gesture ended up to be a swipe,
// it's still a "touch leave" situation
if (self._touchIsTouchEvent(event) || !self._touchIsEmulatedEvent(event)) {
var delay = event.type == 'mouseleave' ? self.__options.delay : self.__options.delayTouch;
self._trigger({
delay: delay[1],
dismissable: true,
event: event,
type: 'dismissable'
});
}
})
// suspend the mouseleave timeout when the pointer comes back
// over the elements
.on(eventNamesIn, function (event) {
// it's also ok if the touch event is a swipe gesture
if (self._touchIsTouchEvent(event) || !self._touchIsEmulatedEvent(event)) {
self._trigger({
dismissable: false,
event: event,
type: 'dismissable'
});
}
});
}

// close the tooltip when the origin gets a mouse click (common behavior of
// native tooltips)
if (self.__options.triggerClose.originClick) {
self._$origin.on('click.' + self.__namespace + '-triggerClose', function (event) {
// we could actually let a tap trigger this but this feature just
// does not make sense on touch devices
if (!self._touchIsTouchEvent(event) && !self._touchIsEmulatedEvent(event)) {
self._close(event);
}
});
}

// set the same bindings for click and touch on the body to close the tooltip
if (self.__options.triggerClose.click || self.__options.triggerClose.tap && env.hasTouchCapability) {
// don't set right away since the click/tap event which triggered this method
// (if it was a click/tap) is going to bubble up to the body, we don't want it
// to close the tooltip immediately after it opened
setTimeout(function () {
if (self.__state != 'closed') {
var eventNames = '',
$body = $(env.window.document.body);
if (self.__options.triggerClose.click) {
eventNames += 'click.' + self.__namespace + '-triggerClose ';
}
if (self.__options.triggerClose.tap && env.hasTouchCapability) {
eventNames += 'touchend.' + self.__namespace + '-triggerClose';
}
$body.on(eventNames, function (event) {
if (self._touchIsMeaningfulEvent(event)) {
self._touchRecordEvent(event);
if (!self.__options.interactive || !$.contains(self._$tooltip[0], event.target)) {
self._close(event);
}
}
});

// needed to detect and ignore swiping
if (self.__options.triggerClose.tap && env.hasTouchCapability) {
$body.on('touchstart.' + self.__namespace + '-triggerClose', function (event) {
self._touchRecordEvent(event);
});
}
}
}, 0);
}
self._trigger('ready');

// call our custom callback
if (self.__options.functionReady) {
self.__options.functionReady.call(self, self, {
origin: self._$origin[0],
tooltip: self._$tooltip[0]
});
}
}

// if we have a timer set, let the countdown begin
if (self.__options.timer > 0) {
var timeout = setTimeout(function () {
self._close();
}, self.__options.timer + extraTime);
self.__timeouts.close.push(timeout);
}
}
}
}
}
return self;
},
/**
 * When using the mouseenter/touchstart open triggers, this function will
 * schedule the opening of the tooltip after the delay, if there is one
 *
 * @param event
 * @returns {self}
 * @protected
	 */
_openShortly: function _openShortly(event) {
var self = this,
ok = true;
if (self.__state != 'stable' && self.__state != 'appearing') {
// if a timeout is not already running
if (!self.__timeouts.open) {
self._trigger({
type: 'start',
event: event,
stop: function stop() {
ok = false;
}
});
if (ok) {
var delay = event.type.indexOf('touch') == 0 ? self.__options.delayTouch : self.__options.delay;
if (delay[0]) {
self.__timeouts.open = setTimeout(function () {
self.__timeouts.open = null;

// open only if the pointer (mouse or touch) is still over the origin.
// The check on the "meaningful event" can only be made here, after some
// time has passed (to know if the touch was a swipe or not)
if (self.__pointerIsOverOrigin && self._touchIsMeaningfulEvent(event)) {
// signal that we go on
self._trigger('startend');
self._open(event);
} else {
// signal that we cancel
self._trigger('startcancel');
}
}, delay[0]);
} else {
// signal that we go on
self._trigger('startend');
self._open(event);
}
}
}
}
return self;
},
/**
 * Meant for plugins to get their options
 * 
 * @param {string} pluginName The name of the plugin that asks for its options
 * @param {object} defaultOptions The default options of the plugin
 * @returns {object} The options
 * @protected
 */
_optionsExtract: function _optionsExtract(pluginName, defaultOptions) {
var self = this,
options = $.extend(true, {}, defaultOptions);

// if the plugin options were isolated in a property named after the
// plugin, use them (prevents conflicts with other plugins)
var pluginOptions = self.__options[pluginName];

// if not, try to get them as regular options
if (!pluginOptions) {
pluginOptions = {};
$.each(defaultOptions, function (optionName, value) {
var o = self.__options[optionName];
if (o !== undefined) {
pluginOptions[optionName] = o;
}
});
}

// let's merge the default options and the ones that were provided. We'd want
// to do a deep copy but not let jQuery merge arrays, so we'll do a shallow
// extend on two levels, that will be enough if options are not more than 1
// level deep
$.each(options, function (optionName, value) {
if (pluginOptions[optionName] !== undefined) {
if (_typeof(value) == 'object' && !(value instanceof Array) && value != null && _typeof(pluginOptions[optionName]) == 'object' && !(pluginOptions[optionName] instanceof Array) && pluginOptions[optionName] != null) {
$.extend(options[optionName], pluginOptions[optionName]);
} else {
options[optionName] = pluginOptions[optionName];
}
}
});
return options;
},
/**
 * Used at instantiation of the plugin, or afterwards by plugins that activate themselves
 * on existing instances
 * 
 * @param {object} pluginName
 * @returns {self}
 * @protected
 */
_plug: function _plug(pluginName) {
var plugin = $.tooltipster._plugin(pluginName);
if (plugin) {
// if there is a constructor for instances
if (plugin.instance) {
// proxy non-private methods on the instance to allow new instance methods
$.tooltipster.__bridge(plugin.instance, this, plugin.name);
}
} else {
throw new Error('The "' + pluginName + '" plugin is not defined');
}
return this;
},
/**
 * This will return true if the event is a mouse event which was
 * emulated by the browser after a touch event. This allows us to
 * really dissociate mouse and touch triggers.
 * 
 * There is a margin of error if a real mouse event is fired right
 * after (within the delay shown below) a touch event on the same
 * element, but hopefully it should not happen often.
 * 
 * @returns {boolean}
 * @protected
 */
_touchIsEmulatedEvent: function _touchIsEmulatedEvent(event) {
var isEmulated = false,
now = new Date().getTime();
for (var i = this.__touchEvents.length - 1; i >= 0; i--) {
var e = this.__touchEvents[i];

// delay, in milliseconds. It's supposed to be 300ms in
// most browsers (350ms on iOS) to allow a double tap but
// can be less (check out FastClick for more info)
if (now - e.time < 500) {
if (e.target === event.target) {
isEmulated = true;
}
} else {
break;
}
}
return isEmulated;
},
/**
 * Returns false if the event was an emulated mouse event or
 * a touch event involved in a swipe gesture.
 * 
 * @param {object} event
 * @returns {boolean}
 * @protected
 */
_touchIsMeaningfulEvent: function _touchIsMeaningfulEvent(event) {
return this._touchIsTouchEvent(event) && !this._touchSwiped(event.target) || !this._touchIsTouchEvent(event) && !this._touchIsEmulatedEvent(event);
},
/**
 * Checks if an event is a touch event
 * 
 * @param {object} event
 * @returns {boolean}
 * @protected
 */
_touchIsTouchEvent: function _touchIsTouchEvent(event) {
return event.type.indexOf('touch') == 0;
},
/**
 * Store touch events for a while to detect swiping and emulated mouse events
 * 
 * @param {object} event
 * @returns {self}
 * @protected
 */
_touchRecordEvent: function _touchRecordEvent(event) {
if (this._touchIsTouchEvent(event)) {
event.time = new Date().getTime();
this.__touchEvents.push(event);
}
return this;
},
/**
 * Returns true if a swipe happened after the last touchstart event fired on
 * event.target.
 * 
 * We need to differentiate a swipe from a tap before we let the event open
 * or close the tooltip. A swipe is when a touchmove (scroll) event happens
 * on the body between the touchstart and the touchend events of an element.
 * 
 * @param {object} target The HTML element that may have triggered the swipe
 * @returns {boolean}
 * @protected
 */
_touchSwiped: function _touchSwiped(target) {
var swiped = false;
for (var i = this.__touchEvents.length - 1; i >= 0; i--) {
var e = this.__touchEvents[i];
if (e.type == 'touchmove') {
swiped = true;
break;
} else if (e.type == 'touchstart' && target === e.target) {
break;
}
}
return swiped;
},
/**
 * Triggers an event on the instance emitters
 * 
 * @returns {self}
 * @protected
 */
_trigger: function _trigger() {
var args = Array.prototype.slice.apply(arguments);
if (typeof args[0] == 'string') {
args[0] = {
type: args[0]
};
}

// add properties to the event
args[0].instance = this;
args[0].origin = this._$origin ? this._$origin[0] : null;
args[0].tooltip = this._$tooltip ? this._$tooltip[0] : null;

// note: the order of emitters matters
this.__$emitterPrivate.trigger.apply(this.__$emitterPrivate, args);
$.tooltipster._trigger.apply($.tooltipster, args);
this.__$emitterPublic.trigger.apply(this.__$emitterPublic, args);
return this;
},
/**
 * Deactivate a plugin on this instance
 * 
 * @returns {self}
 * @protected
 */
_unplug: function _unplug(pluginName) {
var self = this;

// if the plugin has been activated on this instance
if (self[pluginName]) {
var plugin = $.tooltipster._plugin(pluginName);

// if there is a constructor for instances
if (plugin.instance) {
// unbridge
$.each(plugin.instance, function (methodName, fn) {
// if the method exists (privates methods do not) and comes indeed from
// this plugin (may be missing or come from a conflicting plugin).
if (self[methodName] && self[methodName].bridged === self[pluginName]) {
delete self[methodName];
}
});
}

// destroy the plugin
if (self[pluginName].__destroy) {
self[pluginName].__destroy();
}

// remove the reference to the plugin instance
delete self[pluginName];
}
return self;
},
/**
 * @see self::_close
 * @returns {self}
 * @public
 */
close: function close(callback) {
if (!this.__destroyed) {
this._close(null, callback);
} else {
this.__destroyError();
}
return this;
},
/**
 * Sets or gets the content of the tooltip
 * 
 * @returns {mixed|self}
 * @public
 */
content: function content(_content) {
var self = this;

// getter method
if (_content === undefined) {
return self.__Content;
}
// setter method
else {
if (!self.__destroyed) {
// change the content
self.__contentSet(_content);
if (self.__Content !== null) {
// update the tooltip if it is open
if (self.__state !== 'closed') {
// reset the content in the tooltip
self.__contentInsert();

// reposition and resize the tooltip
self.reposition();

// if we want to play a little animation showing the content changed
if (self.__options.updateAnimation) {
if (env.hasTransitions) {
// keep the reference in the local scope
var animation = self.__options.updateAnimation;
self._$tooltip.addClass('tooltipster-update-' + animation);

// remove the class after a while. The actual duration of the
// update animation may be shorter, it's set in the CSS rules
setTimeout(function () {
if (self.__state != 'closed') {
self._$tooltip.removeClass('tooltipster-update-' + animation);
}
}, 1000);
} else {
self._$tooltip.fadeTo(200, 0.5, function () {
if (self.__state != 'closed') {
self._$tooltip.fadeTo(200, 1);
}
});
}
}
}
} else {
self._close();
}
} else {
self.__destroyError();
}
return self;
}
},
/**
 * Destroys the tooltip
 * 
 * @returns {self}
 * @public
 */
destroy: function destroy() {
var self = this;
if (!self.__destroyed) {
if (self.__state != 'closed') {
// no closing delay
self.option('animationDuration', 0)
// force closing
._close(null, null, true);
} else {
// there might be an open timeout still running
self.__timeoutsClear();
}

// send event
self._trigger('destroy');
self.__destroyed = true;
self._$origin.removeData(self.__namespace)
// remove the open trigger listeners
.off('.' + self.__namespace + '-triggerOpen');

// remove the touch listener
$(env.window.document.body).off('.' + self.__namespace + '-triggerOpen');
var ns = self._$origin.data('tooltipster-ns');

// if the origin has been removed from DOM, its data may
// well have been destroyed in the process and there would
// be nothing to clean up or restore
if (ns) {
// if there are no more tooltips on this element
if (ns.length === 1) {
// optional restoration of a title attribute
var title = null;
if (self.__options.restoration == 'previous') {
title = self._$origin.data('tooltipster-initialTitle');
} else if (self.__options.restoration == 'current') {
// old school technique to stringify when outerHTML is not supported
title = typeof self.__Content == 'string' ? self.__Content : $('<div></div>').append(self.__Content).html();
}
if (title) {
self._$origin.attr('title', title);
}

// final cleaning

self._$origin.removeClass('tooltipstered');
self._$origin.removeData('tooltipster-ns').removeData('tooltipster-initialTitle');
} else {
// remove the instance namespace from the list of namespaces of
// tooltips present on the element
ns = $.grep(ns, function (el, i) {
return el !== self.__namespace;
});
self._$origin.data('tooltipster-ns', ns);
}
}

// last event
self._trigger('destroyed');

// unbind private and public event listeners
self._off();
self.off();

// remove external references, just in case
self.__Content = null;
self.__$emitterPrivate = null;
self.__$emitterPublic = null;
self.__options.parent = null;
self._$origin = null;
self._$tooltip = null;

// make sure the object is no longer referenced in there to prevent
// memory leaks
$.tooltipster.__instancesLatestArr = $.grep($.tooltipster.__instancesLatestArr, function (el, i) {
return self !== el;
});
clearInterval(self.__garbageCollector);
} else {
self.__destroyError();
}

// we return the scope rather than true so that the call to
// .tooltipster('destroy') actually returns the matched elements
// and applies to all of them
return self;
},
/**
 * Disables the tooltip
 * 
 * @returns {self}
 * @public
 */
disable: function disable() {
if (!this.__destroyed) {
// close first, in case the tooltip would not disappear on
// its own (no close trigger)
this._close();
this.__enabled = false;
return this;
} else {
this.__destroyError();
}
return this;
},
/**
 * Returns the HTML element of the origin
 *
 * @returns {self}
 * @public
 */
elementOrigin: function elementOrigin() {
if (!this.__destroyed) {
return this._$origin[0];
} else {
this.__destroyError();
}
},
/**
 * Returns the HTML element of the tooltip
 *
 * @returns {self}
 * @public
 */
elementTooltip: function elementTooltip() {
return this._$tooltip ? this._$tooltip[0] : null;
},
/**
 * Enables the tooltip
 * 
 * @returns {self}
 * @public
 */
enable: function enable() {
this.__enabled = true;
return this;
},
/**
 * Alias, deprecated in 4.0.0
 * 
 * @param {function} callback
 * @returns {self}
 * @public
 */
hide: function hide(callback) {
return this.close(callback);
},
/**
 * Returns the instance
 * 
 * @returns {self}
 * @public
 */
instance: function instance() {
return this;
},
/**
 * For public use only, not to be used by plugins (use ::_off() instead)
 * 
 * @returns {self}
 * @public
 */
off: function off() {
if (!this.__destroyed) {
this.__$emitterPublic.off.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
}
return this;
},
/**
 * For public use only, not to be used by plugins (use ::_on() instead)
 *
 * @returns {self}
 * @public
 */
on: function on() {
if (!this.__destroyed) {
this.__$emitterPublic.on.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
} else {
this.__destroyError();
}
return this;
},
/**
 * For public use only, not to be used by plugins
 *
 * @returns {self}
 * @public
 */
one: function one() {
if (!this.__destroyed) {
this.__$emitterPublic.one.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
} else {
this.__destroyError();
}
return this;
},
/**
 * @see self::_open
 * @returns {self}
 * @public
 */
open: function open(callback) {
if (!this.__destroyed) {
this._open(null, callback);
} else {
this.__destroyError();
}
return this;
},
/**
 * Get or set options. For internal use and advanced users only.
 * 
 * @param {string} o Option name
 * @param {mixed} val optional A new value for the option
 * @return {mixed|self} If val is omitted, the value of the option
 * is returned, otherwise the instance itself is returned
 * @public
 */
option: function option(o, val) {
// getter
if (val === undefined) {
return this.__options[o];
}
// setter
else {
if (!this.__destroyed) {
// change value
this.__options[o] = val;

// format
this.__optionsFormat();

// re-prepare the triggers if needed
if ($.inArray(o, ['trigger', 'triggerClose', 'triggerOpen']) >= 0) {
this.__prepareOrigin();
}
if (o === 'selfDestruction') {
this.__prepareGC();
}
} else {
this.__destroyError();
}
return this;
}
},
/**
 * This method is in charge of setting the position and size properties of the tooltip.
 * All the hard work is delegated to the display plugin.
 * Note: The tooltip may be detached from the DOM at the moment the method is called 
 * but must be attached by the end of the method call.
 * 
 * @param {object} event For internal use only. Defined if an event such as
 * window resizing triggered the repositioning
 * @param {boolean} tooltipIsDetached For internal use only. Set this to true if you
 * know that the tooltip not being in the DOM is not an issue (typically when the
 * tooltip element has just been created but has not been added to the DOM yet).
 * @returns {self}
 * @public
 */
reposition: function reposition(event, tooltipIsDetached) {
var self = this;
if (!self.__destroyed) {
// if the tooltip is still open and the origin is still in the DOM
if (self.__state != 'closed' && bodyContains(self._$origin)) {
// if the tooltip has not been removed from DOM manually (or if it
// has been detached on purpose)
if (tooltipIsDetached || bodyContains(self._$tooltip)) {
if (!tooltipIsDetached) {
// detach in case the tooltip overflows the window and adds
// scrollbars to it, so __geometry can be accurate
self._$tooltip.detach();
}

// refresh the geometry object before passing it as a helper
self.__Geometry = self.__geometry();

// let a plugin fo the rest
self._trigger({
type: 'reposition',
event: event,
helper: {
geo: self.__Geometry
}
});
}
}
} else {
self.__destroyError();
}
return self;
},
/**
 * Alias, deprecated in 4.0.0
 *
 * @param callback
 * @returns {self}
 * @public
 */
show: function show(callback) {
return this.open(callback);
},
/**
 * Returns some properties about the instance
 * 
 * @returns {object}
 * @public
 */
status: function status() {
return {
destroyed: this.__destroyed,
enabled: this.__enabled,
open: this.__state !== 'closed',
state: this.__state
};
},
/**
 * For public use only, not to be used by plugins
 *
 * @returns {self}
 * @public
 */
triggerHandler: function triggerHandler() {
if (!this.__destroyed) {
this.__$emitterPublic.triggerHandler.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
} else {
this.__destroyError();
}
return this;
}
};
$.fn.tooltipster = function () {
// for using in closures
var args = Array.prototype.slice.apply(arguments),
// common mistake: an HTML element can't be in several tooltips at the same time
contentCloningWarning = 'You are using a single HTML element as content for several tooltips. You probably want to set the contentCloning option to TRUE.';

// this happens with $(sel).tooltipster(...) when $(sel) does not match anything
if (this.length === 0) {
// still chainable
return this;
}
// this happens when calling $(sel).tooltipster('methodName or options')
// where $(sel) matches one or more elements
else {
// method calls
if (typeof args[0] === 'string') {
var v = '#*$~&';
this.each(function () {
// retrieve the namepaces of the tooltip(s) that exist on that element.
// We will interact with the first tooltip only.
var ns = $(this).data('tooltipster-ns'),
// self represents the instance of the first tooltipster plugin
// associated to the current HTML object of the loop
self = ns ? $(this).data(ns[0]) : null;

// if the current element holds a tooltipster instance
if (self) {
if (typeof self[args[0]] === 'function') {
if (this.length > 1 && args[0] == 'content' && (args[1] instanceof $ || _typeof(args[1]) == 'object' && args[1] != null && args[1].tagName) && !self.__options.contentCloning && self.__options.debug) {
console.log(contentCloningWarning);
}

// note : args[1] and args[2] may not be defined
var resp = self[args[0]](args[1], args[2]);
} else {
throw new Error('Unknown method "' + args[0] + '"');
}

// if the function returned anything other than the instance
// itself (which implies chaining, except for the `instance` method)
if (resp !== self || args[0] === 'instance') {
v = resp;

// return false to stop .each iteration on the first element
// matched by the selector
return false;
}
} else {
throw new Error('You called Tooltipster\'s "' + args[0] + '" method on an uninitialized element');
}
});
return v !== '#*$~&' ? v : this;
}
// first argument is undefined or an object: the tooltip is initializing
else {
// reset the array of last initialized objects
$.tooltipster.__instancesLatestArr = [];

// is there a defined value for the multiple option in the options object ?
var multipleIsSet = args[0] && args[0].multiple !== undefined,
// if the multiple option is set to true, or if it's not defined but
// set to true in the defaults
multiple = multipleIsSet && args[0].multiple || !multipleIsSet && defaults.multiple,
// same for content
contentIsSet = args[0] && args[0].content !== undefined,
content = contentIsSet && args[0].content || !contentIsSet && defaults.content,
// same for contentCloning
contentCloningIsSet = args[0] && args[0].contentCloning !== undefined,
contentCloning = contentCloningIsSet && args[0].contentCloning || !contentCloningIsSet && defaults.contentCloning,
// same for debug
debugIsSet = args[0] && args[0].debug !== undefined,
debug = debugIsSet && args[0].debug || !debugIsSet && defaults.debug;
if (this.length > 1 && (content instanceof $ || _typeof(content) == 'object' && content != null && content.tagName) && !contentCloning && debug) {
console.log(contentCloningWarning);
}

// create a tooltipster instance for each element if it doesn't
// already have one or if the multiple option is set, and attach the
// object to it
this.each(function () {
var go = false,
$this = $(this),
ns = $this.data('tooltipster-ns'),
obj = null;
if (!ns) {
go = true;
} else if (multiple) {
go = true;
} else if (debug) {
console.log('Tooltipster: one or more tooltips are already attached to the element below. Ignoring.');
console.log(this);
}
if (go) {
obj = new $.Tooltipster(this, args[0]);

// save the reference of the new instance
if (!ns) ns = [];
ns.push(obj.__namespace);
$this.data('tooltipster-ns', ns);

// save the instance itself
$this.data(obj.__namespace, obj);

// call our constructor custom function.
// we do this here and not in ::init() because we wanted
// the object to be saved in $this.data before triggering
// it
if (obj.__options.functionInit) {
obj.__options.functionInit.call(obj, obj, {
origin: this
});
}

// and now the event, for the plugins and core emitter
obj._trigger('init');
}
$.tooltipster.__instancesLatestArr.push(obj);
});
return this;
}
}
};

// Utilities

/**
 * A class to check if a tooltip can fit in given dimensions
 * 
 * @param {object} $tooltip The jQuery wrapped tooltip element, or a clone of it
 */
function Ruler($tooltip) {
// list of instance variables

this.$container;
this.constraints = null;
this.__$tooltip;
this.__init($tooltip);
}
Ruler.prototype = {
/**
 * Move the tooltip into an invisible div that does not allow overflow to make
 * size tests. Note: the tooltip may or may not be attached to the DOM at the
 * moment this method is called, it does not matter.
 * 
 * @param {object} $tooltip The object to test. May be just a clone of the
 * actual tooltip.
 * @private
 */
__init: function __init($tooltip) {
this.__$tooltip = $tooltip;
this.__$tooltip.css({
// for some reason we have to specify top and left 0
left: 0,
// any overflow will be ignored while measuring
overflow: 'hidden',
// positions at (0,0) without the div using 100% of the available width
position: 'absolute',
top: 0
})
// overflow must be auto during the test. We re-set this in case
// it were modified by the user
.find('.tooltipster-content').css('overflow', 'auto');
this.$container = $('<div class="tooltipster-ruler"></div>').append(this.__$tooltip).appendTo(env.window.document.body);
},
/**
 * Force the browser to redraw (re-render) the tooltip immediately. This is required
 * when you changed some CSS properties and need to make something with it
 * immediately, without waiting for the browser to redraw at the end of instructions.
 *
 * @see http://stackoverflow.com/questions/3485365/how-can-i-force-webkit-to-redraw-repaint-to-propagate-style-changes
 * @private
 */
__forceRedraw: function __forceRedraw() {
// note: this would work but for Webkit only
//this.__$tooltip.close();
//this.__$tooltip[0].offsetHeight;
//this.__$tooltip.open();

// works in FF too
var $p = this.__$tooltip.parent();
this.__$tooltip.detach();
this.__$tooltip.appendTo($p);
},
/**
 * Set maximum dimensions for the tooltip. A call to ::measure afterwards
 * will tell us if the content overflows or if it's ok
 *
 * @param {int} width
 * @param {int} height
 * @return {Ruler}
 * @public
 */
constrain: function constrain(width, height) {
this.constraints = {
width: width,
height: height
};
this.__$tooltip.css({
// we disable display:flex, otherwise the content would overflow without
// creating horizontal scrolling (which we need to detect).
display: 'block',
// reset any previous height
height: '',
// we'll check if horizontal scrolling occurs
overflow: 'auto',
// we'll set the width and see what height is generated and if there
// is horizontal overflow
width: width
});
return this;
},
/**
 * Reset the tooltip content overflow and remove the test container
 * 
 * @returns {Ruler}
 * @public
 */
destroy: function destroy() {
// in case the element was not a clone
this.__$tooltip.detach().find('.tooltipster-content').css({
// reset to CSS value
display: '',
overflow: ''
});
this.$container.remove();
},
/**
 * Removes any constraints
 * 
 * @returns {Ruler}
 * @public
 */
free: function free() {
this.constraints = null;

// reset to natural size
this.__$tooltip.css({
display: '',
height: '',
overflow: 'visible',
width: ''
});
return this;
},
/**
 * Returns the size of the tooltip. When constraints are applied, also returns
 * whether the tooltip fits in the provided dimensions.
 * The idea is to see if the new height is small enough and if the content does
 * not overflow horizontally.
 *
 * @param {int} width
 * @param {int} height
 * @returns {object} An object with a bool `fits` property and a `size` property
 * @public
 */
measure: function measure() {
this.__forceRedraw();
var tooltipBcr = this.__$tooltip[0].getBoundingClientRect(),
result = {
size: {
// bcr.width/height are not defined in IE8- but in this
// case, bcr.right/bottom will have the same value
// except in iOS 8+ where tooltipBcr.bottom/right are wrong
// after scrolling for reasons yet to be determined.
// tooltipBcr.top/left might not be 0, see issue #514
height: tooltipBcr.height || tooltipBcr.bottom - tooltipBcr.top,
width: tooltipBcr.width || tooltipBcr.right - tooltipBcr.left
}
};
if (this.constraints) {
// note: we used to use offsetWidth instead of boundingRectClient but
// it returned rounded values, causing issues with sub-pixel layouts.

// note2: noticed that the bcrWidth of text content of a div was once
// greater than the bcrWidth of its container by 1px, causing the final
// tooltip box to be too small for its content. However, evaluating
// their widths one against the other (below) surprisingly returned
// equality. Happened only once in Chrome 48, was not able to reproduce
// => just having fun with float position values...

var $content = this.__$tooltip.find('.tooltipster-content'),
height = this.__$tooltip.outerHeight(),
contentBcr = $content[0].getBoundingClientRect(),
fits = {
height: height <= this.constraints.height,
width:
// this condition accounts for min-width property that
// may apply
tooltipBcr.width <= this.constraints.width
// the -1 is here because scrollWidth actually returns
// a rounded value, and may be greater than bcr.width if
// it was rounded up. This may cause an issue for contents
// which actually really overflowby 1px or so, but that
// should be rare. Not sure how to solve this efficiently.
// See http://blogs.msdn.com/b/ie/archive/2012/02/17/sub-pixel-rendering-and-the-css-object-model.aspx
&& contentBcr.width >= $content[0].scrollWidth - 1
};
result.fits = fits.height && fits.width;
}

// old versions of IE get the width wrong for some reason and it causes
// the text to be broken to a new line, so we round it up. If the width
// is the width of the screen though, we can assume it is accurate.
if (env.IE && env.IE <= 11 && result.size.width !== env.window.document.documentElement.clientWidth) {
result.size.width = Math.ceil(result.size.width) + 1;
}
return result;
}
};

// quick & dirty compare function, not bijective nor multidimensional
function areEqual(a, b) {
var same = true;
$.each(a, function (i, _) {
if (b[i] === undefined || a[i] !== b[i]) {
same = false;
return false;
}
});
return same;
}

/**
 * A fast function to check if an element is still in the DOM. It
 * tries to use an id as ids are indexed by the browser, or falls
 * back to jQuery's `contains` method. May fail if two elements
 * have the same id, but so be it
 *
 * @param {object} $obj A jQuery-wrapped HTML element
 * @return {boolean}
 */
function bodyContains($obj) {
var id = $obj.attr('id'),
el = id ? env.window.document.getElementById(id) : null;
// must also check that the element with the id is the one we want
return el ? el === $obj[0] : $.contains(env.window.document.body, $obj[0]);
}

// detect IE versions for dirty fixes
var uA = navigator.userAgent.toLowerCase();
if (uA.indexOf('msie') != -1) env.IE = parseInt(uA.split('msie')[1]);else if (uA.toLowerCase().indexOf('trident') !== -1 && uA.indexOf(' rv:11') !== -1) env.IE = 11;else if (uA.toLowerCase().indexOf('edge/') != -1) env.IE = parseInt(uA.toLowerCase().split('edge/')[1]);

// detecting support for CSS transitions
function transitionSupport() {
// env.window is not defined yet when this is called
if (!win) return false;
var b = win.document.body || win.document.documentElement,
s = b.style,
p = 'transition',
v = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];
if (typeof s[p] == 'string') {
return true;
}
p = p.charAt(0).toUpperCase() + p.substr(1);
for (var i = 0; i < v.length; i++) {
if (typeof s[v[i] + p] == 'string') {
return true;
}
}
return false;
}

// we'll return jQuery for plugins not to have to declare it as a dependency,
// but it's done by a build task since it should be included only once at the
// end when we concatenate the main file with a plugin
// sideTip is Tooltipster's default plugin.
// This file will be UMDified by a build task.

var pluginName = 'tooltipster.sideTip';
$.tooltipster._plugin({
name: pluginName,
instance: {
/**
 * Defaults are provided as a function for an easy override by inheritance
 *
 * @return {object} An object with the defaults options
 * @private
 */
__defaults: function __defaults() {
return {
// if the tooltip should display an arrow that points to the origin
arrow: true,
// the distance in pixels between the tooltip and the origin
distance: 6,
// allows to easily change the position of the tooltip
functionPosition: null,
maxWidth: null,
// used to accomodate the arrow of tooltip if there is one.
// First to make sure that the arrow target is not too close
// to the edge of the tooltip, so the arrow does not overflow
// the tooltip. Secondly when we reposition the tooltip to
// make sure that it's positioned in such a way that the arrow is
// still pointing at the target (and not a few pixels beyond it).
// It should be equal to or greater than half the width of
// the arrow (by width we mean the size of the side which touches
// the side of the tooltip).
minIntersection: 16,
minWidth: 0,
// deprecated in 4.0.0. Listed for _optionsExtract to pick it up
position: null,
side: 'top',
// set to false to position the tooltip relatively to the document rather
// than the window when we open it
viewportAware: true
};
},
/**
 * Run once: at instantiation of the plugin
 *
 * @param {object} instance The tooltipster object that instantiated this plugin
 * @private
 */
__init: function __init(instance) {
var self = this;

// list of instance variables

self.__instance = instance;
self.__namespace = 'tooltipster-sideTip-' + Math.round(Math.random() * 1000000);
self.__previousState = 'closed';
self.__options;

// initial formatting
self.__optionsFormat();
self.__instance._on('state.' + self.__namespace, function (event) {
if (event.state == 'closed') {
self.__close();
} else if (event.state == 'appearing' && self.__previousState == 'closed') {
self.__create();
}
self.__previousState = event.state;
});

// reformat every time the options are changed
self.__instance._on('options.' + self.__namespace, function () {
self.__optionsFormat();
});
self.__instance._on('reposition.' + self.__namespace, function (e) {
self.__reposition(e.event, e.helper);
});
},
/**
 * Called when the tooltip has closed
 * 
 * @private
 */
__close: function __close() {
// detach our content object first, so the next jQuery's remove()
// call does not unbind its event handlers
if (this.__instance.content() instanceof $) {
this.__instance.content().detach();
}

// remove the tooltip from the DOM
this.__instance._$tooltip.remove();
this.__instance._$tooltip = null;
},
/**
 * Creates the HTML element of the tooltip.
 * 
 * @private
 */
__create: function __create() {
// note: we wrap with a .tooltipster-box div to be able to set a margin on it
// (.tooltipster-base must not have one)
var $html = $('<div class="tooltipster-base tooltipster-sidetip">' + '<div class="tooltipster-box">' + '<div class="tooltipster-content"></div>' + '</div>' + '<div class="tooltipster-arrow">' + '<div class="tooltipster-arrow-uncropped">' + '<div class="tooltipster-arrow-border"></div>' + '<div class="tooltipster-arrow-background"></div>' + '</div>' + '</div>' + '</div>');

// hide arrow if asked
if (!this.__options.arrow) {
$html.find('.tooltipster-box').css('margin', 0).end().find('.tooltipster-arrow').hide();
}

// apply min/max width if asked
if (this.__options.minWidth) {
$html.css('min-width', this.__options.minWidth + 'px');
}
if (this.__options.maxWidth) {
$html.css('max-width', this.__options.maxWidth + 'px');
}
this.__instance._$tooltip = $html;

// tell the instance that the tooltip element has been created
this.__instance._trigger('created');
},
/**
 * Used when the plugin is to be unplugged
 *
 * @private
 */
__destroy: function __destroy() {
this.__instance._off('.' + self.__namespace);
},
/**
 * (Re)compute this.__options from the options declared to the instance
 *
 * @private
 */
__optionsFormat: function __optionsFormat() {
var self = this;

// get the options
self.__options = self.__instance._optionsExtract(pluginName, self.__defaults());

// for backward compatibility, deprecated in v4.0.0
if (self.__options.position) {
self.__options.side = self.__options.position;
}

// options formatting

// format distance as a four-cell array if it ain't one yet and then make
// it an object with top/bottom/left/right properties
if (_typeof(self.__options.distance) != 'object') {
self.__options.distance = [self.__options.distance];
}
if (self.__options.distance.length < 4) {
if (self.__options.distance[1] === undefined) self.__options.distance[1] = self.__options.distance[0];
if (self.__options.distance[2] === undefined) self.__options.distance[2] = self.__options.distance[0];
if (self.__options.distance[3] === undefined) self.__options.distance[3] = self.__options.distance[1];
}
self.__options.distance = {
top: self.__options.distance[0],
right: self.__options.distance[1],
bottom: self.__options.distance[2],
left: self.__options.distance[3]
};

// let's transform:
// 'top' into ['top', 'bottom', 'right', 'left']
// 'right' into ['right', 'left', 'top', 'bottom']
// 'bottom' into ['bottom', 'top', 'right', 'left']
// 'left' into ['left', 'right', 'top', 'bottom']
if (typeof self.__options.side == 'string') {
var opposites = {
'top': 'bottom',
'right': 'left',
'bottom': 'top',
'left': 'right'
};
self.__options.side = [self.__options.side, opposites[self.__options.side]];
if (self.__options.side[0] == 'left' || self.__options.side[0] == 'right') {
self.__options.side.push('top', 'bottom');
} else {
self.__options.side.push('right', 'left');
}
}

// misc
// disable the arrow in IE6 unless the arrow option was explicitly set to true
if ($.tooltipster._env.IE === 6 && self.__options.arrow !== true) {
self.__options.arrow = false;
}
},
/**
 * This method must compute and set the positioning properties of the
 * tooltip (left, top, width, height, etc.). It must also make sure the
 * tooltip is eventually appended to its parent (since the element may be
 * detached from the DOM at the moment the method is called).
 *
 * We'll evaluate positioning scenarios to find which side can contain the
 * tooltip in the best way. We'll consider things relatively to the window
 * (unless the user asks not to), then to the document (if need be, or if the
 * user explicitly requires the tests to run on the document). For each
 * scenario, measures are taken, allowing us to know how well the tooltip
 * is going to fit. After that, a sorting function will let us know what
 * the best scenario is (we also allow the user to choose his favorite
 * scenario by using an event).
 * 
 * @param {object} helper An object that contains variables that plugin
 * creators may find useful (see below)
 * @param {object} helper.geo An object with many layout properties
 * about objects of interest (window, document, origin). This should help
 * plugin users compute the optimal position of the tooltip
 * @private
 */
__reposition: function __reposition(event, helper) {
var self = this,
finalResult,
// to know where to put the tooltip, we need to know on which point
// of the x or y axis we should center it. That coordinate is the target
targets = self.__targetFind(helper),
testResults = [];

// make sure the tooltip is detached while we make tests on a clone
self.__instance._$tooltip.detach();

// we could actually provide the original element to the Ruler and
// not a clone, but it just feels right to keep it out of the
// machinery.
var $clone = self.__instance._$tooltip.clone(),
// start position tests session
ruler = $.tooltipster._getRuler($clone),
satisfied = false,
animation = self.__instance.option('animation');

// an animation class could contain properties that distort the size
if (animation) {
$clone.removeClass('tooltipster-' + animation);
}

// start evaluating scenarios
$.each(['window', 'document'], function (i, container) {
var _takeTest = null;

// let the user decide to keep on testing or not
self.__instance._trigger({
container: container,
helper: helper,
satisfied: satisfied,
takeTest: function takeTest(bool) {
_takeTest = bool;
},
results: testResults,
type: 'positionTest'
});
if (_takeTest == true || _takeTest != false && satisfied == false
// skip the window scenarios if asked. If they are reintegrated by
// the callback of the positionTest event, they will have to be
// excluded using the callback of positionTested
&& (container != 'window' || self.__options.viewportAware)) {
// for each allowed side
for (var i = 0; i < self.__options.side.length; i++) {
var distance = {
horizontal: 0,
vertical: 0
},
side = self.__options.side[i];
if (side == 'top' || side == 'bottom') {
distance.vertical = self.__options.distance[side];
} else {
distance.horizontal = self.__options.distance[side];
}

// this may have an effect on the size of the tooltip if there are css
// rules for the arrow or something else
self.__sideChange($clone, side);
$.each(['natural', 'constrained'], function (i, mode) {
_takeTest = null;

// emit an event on the instance
self.__instance._trigger({
container: container,
event: event,
helper: helper,
mode: mode,
results: testResults,
satisfied: satisfied,
side: side,
takeTest: function takeTest(bool) {
_takeTest = bool;
},
type: 'positionTest'
});
if (_takeTest == true || _takeTest != false && satisfied == false) {
var testResult = {
container: container,
// we let the distance as an object here, it can make things a little easier
// during the user's calculations at positionTest/positionTested
distance: distance,
// whether the tooltip can fit in the size of the viewport (does not mean
// that we'll be able to make it initially entirely visible, see 'whole')
fits: null,
mode: mode,
outerSize: null,
side: side,
size: null,
target: targets[side],
// check if the origin has enough surface on screen for the tooltip to
// aim at it without overflowing the viewport (this is due to the thickness
// of the arrow represented by the minIntersection length).
// If not, the tooltip will have to be partly or entirely off screen in
// order to stay docked to the origin. This value will stay null when the
// container is the document, as it is not relevant
whole: null
};

// get the size of the tooltip with or without size constraints
var rulerConfigured = mode == 'natural' ? ruler.free() : ruler.constrain(helper.geo.available[container][side].width - distance.horizontal, helper.geo.available[container][side].height - distance.vertical),
rulerResults = rulerConfigured.measure();
testResult.size = rulerResults.size;
testResult.outerSize = {
height: rulerResults.size.height + distance.vertical,
width: rulerResults.size.width + distance.horizontal
};
if (mode == 'natural') {
if (helper.geo.available[container][side].width >= testResult.outerSize.width && helper.geo.available[container][side].height >= testResult.outerSize.height) {
testResult.fits = true;
} else {
testResult.fits = false;
}
} else {
testResult.fits = rulerResults.fits;
}
if (container == 'window') {
if (!testResult.fits) {
testResult.whole = false;
} else {
if (side == 'top' || side == 'bottom') {
testResult.whole = helper.geo.origin.windowOffset.right >= self.__options.minIntersection && helper.geo.window.size.width - helper.geo.origin.windowOffset.left >= self.__options.minIntersection;
} else {
testResult.whole = helper.geo.origin.windowOffset.bottom >= self.__options.minIntersection && helper.geo.window.size.height - helper.geo.origin.windowOffset.top >= self.__options.minIntersection;
}
}
}
testResults.push(testResult);

// we don't need to compute more positions if we have one fully on screen
if (testResult.whole) {
satisfied = true;
} else {
// don't run the constrained test unless the natural width was greater
// than the available width, otherwise it's pointless as we know it
// wouldn't fit either
if (testResult.mode == 'natural' && (testResult.fits || testResult.size.width <= helper.geo.available[container][side].width)) {
return false;
}
}
}
});
}
}
});

// the user may eliminate the unwanted scenarios from testResults, but he's
// not supposed to alter them at this point. functionPosition and the
// position event serve that purpose.
self.__instance._trigger({
edit: function edit(r) {
testResults = r;
},
event: event,
helper: helper,
results: testResults,
type: 'positionTested'
});

/**
 * Sort the scenarios to find the favorite one.
 * 
 * The favorite scenario is when we can fully display the tooltip on screen,
 * even if it means that the middle of the tooltip is no longer centered on
 * the middle of the origin (when the origin is near the edge of the screen
 * or even partly off screen). We want the tooltip on the preferred side,
 * even if it means that we have to use a constrained size rather than a
 * natural one (as long as it fits). When the origin is off screen at the top
 * the tooltip will be positioned at the bottom (if allowed), if the origin
 * is off screen on the right, it will be positioned on the left, etc.
 * If there are no scenarios where the tooltip can fit on screen, or if the
 * user does not want the tooltip to fit on screen (viewportAware == false),
 * we fall back to the scenarios relative to the document.
 * 
 * When the tooltip is bigger than the viewport in either dimension, we stop
 * looking at the window scenarios and consider the document scenarios only,
 * with the same logic to find on which side it would fit best.
 * 
 * If the tooltip cannot fit the document on any side, we force it at the
 * bottom, so at least the user can scroll to see it.
	 */
testResults.sort(function (a, b) {
// best if it's whole (the tooltip fits and adapts to the viewport)
if (a.whole && !b.whole) {
return -1;
} else if (!a.whole && b.whole) {
return 1;
} else if (a.whole && b.whole) {
var ai = self.__options.side.indexOf(a.side),
bi = self.__options.side.indexOf(b.side);

// use the user's sides fallback array
if (ai < bi) {
return -1;
} else if (ai > bi) {
return 1;
} else {
// will be used if the user forced the tests to continue
return a.mode == 'natural' ? -1 : 1;
}
} else {
// better if it fits
if (a.fits && !b.fits) {
return -1;
} else if (!a.fits && b.fits) {
return 1;
} else if (a.fits && b.fits) {
var ai = self.__options.side.indexOf(a.side),
bi = self.__options.side.indexOf(b.side);

// use the user's sides fallback array
if (ai < bi) {
return -1;
} else if (ai > bi) {
return 1;
} else {
// will be used if the user forced the tests to continue
return a.mode == 'natural' ? -1 : 1;
}
} else {
// if everything failed, this will give a preference to the case where
// the tooltip overflows the document at the bottom
if (a.container == 'document' && a.side == 'bottom' && a.mode == 'natural') {
return -1;
} else {
return 1;
}
}
}
});
finalResult = testResults[0];

// now let's find the coordinates of the tooltip relatively to the window
finalResult.coord = {};
switch (finalResult.side) {
case 'left':
case 'right':
finalResult.coord.top = Math.floor(finalResult.target - finalResult.size.height / 2);
break;
case 'bottom':
case 'top':
finalResult.coord.left = Math.floor(finalResult.target - finalResult.size.width / 2);
break;
}
switch (finalResult.side) {
case 'left':
finalResult.coord.left = helper.geo.origin.windowOffset.left - finalResult.outerSize.width;
break;
case 'right':
finalResult.coord.left = helper.geo.origin.windowOffset.right + finalResult.distance.horizontal;
break;
case 'top':
finalResult.coord.top = helper.geo.origin.windowOffset.top - finalResult.outerSize.height;
break;
case 'bottom':
finalResult.coord.top = helper.geo.origin.windowOffset.bottom + finalResult.distance.vertical;
break;
}

// if the tooltip can potentially be contained within the viewport dimensions
// and that we are asked to make it fit on screen
if (finalResult.container == 'window') {
// if the tooltip overflows the viewport, we'll move it accordingly (then it will
// not be centered on the middle of the origin anymore). We only move horizontally
// for top and bottom tooltips and vice versa.
if (finalResult.side == 'top' || finalResult.side == 'bottom') {
// if there is an overflow on the left
if (finalResult.coord.left < 0) {
// prevent the overflow unless the origin itself gets off screen (minus the
// margin needed to keep the arrow pointing at the target)
if (helper.geo.origin.windowOffset.right - this.__options.minIntersection >= 0) {
finalResult.coord.left = 0;
} else {
finalResult.coord.left = helper.geo.origin.windowOffset.right - this.__options.minIntersection - 1;
}
}
// or an overflow on the right
else if (finalResult.coord.left > helper.geo.window.size.width - finalResult.size.width) {
if (helper.geo.origin.windowOffset.left + this.__options.minIntersection <= helper.geo.window.size.width) {
finalResult.coord.left = helper.geo.window.size.width - finalResult.size.width;
} else {
finalResult.coord.left = helper.geo.origin.windowOffset.left + this.__options.minIntersection + 1 - finalResult.size.width;
}
}
} else {
// overflow at the top
if (finalResult.coord.top < 0) {
if (helper.geo.origin.windowOffset.bottom - this.__options.minIntersection >= 0) {
finalResult.coord.top = 0;
} else {
finalResult.coord.top = helper.geo.origin.windowOffset.bottom - this.__options.minIntersection - 1;
}
}
// or at the bottom
else if (finalResult.coord.top > helper.geo.window.size.height - finalResult.size.height) {
if (helper.geo.origin.windowOffset.top + this.__options.minIntersection <= helper.geo.window.size.height) {
finalResult.coord.top = helper.geo.window.size.height - finalResult.size.height;
} else {
finalResult.coord.top = helper.geo.origin.windowOffset.top + this.__options.minIntersection + 1 - finalResult.size.height;
}
}
}
} else {
// there might be overflow here too but it's easier to handle. If there has
// to be an overflow, we'll make sure it's on the right side of the screen
// (because the browser will extend the document size if there is an overflow
// on the right, but not on the left). The sort function above has already
// made sure that a bottom document overflow is preferred to a top overflow,
// so we don't have to care about it.

// if there is an overflow on the right
if (finalResult.coord.left > helper.geo.window.size.width - finalResult.size.width) {
// this may actually create on overflow on the left but we'll fix it in a sec
finalResult.coord.left = helper.geo.window.size.width - finalResult.size.width;
}

// if there is an overflow on the left
if (finalResult.coord.left < 0) {
// don't care if it overflows the right after that, we made our best
finalResult.coord.left = 0;
}
}

// submit the positioning proposal to the user function which may choose to change
// the side, size and/or the coordinates

// first, set the rules that corresponds to the proposed side: it may change
// the size of the tooltip, and the custom functionPosition may want to detect the
// size of something before making a decision. So let's make things easier for the
// implementor
self.__sideChange($clone, finalResult.side);

// add some variables to the helper
helper.tooltipClone = $clone[0];
helper.tooltipParent = self.__instance.option('parent').parent[0];
// move informative values to the helper
helper.mode = finalResult.mode;
helper.whole = finalResult.whole;
// add some variables to the helper for the functionPosition callback (these
// will also be added to the event fired by self.__instance._trigger but that's
// ok, we're just being consistent)
helper.origin = self.__instance._$origin[0];
helper.tooltip = self.__instance._$tooltip[0];

// leave only the actionable values in there for functionPosition
delete finalResult.container;
delete finalResult.fits;
delete finalResult.mode;
delete finalResult.outerSize;
delete finalResult.whole;

// keep only the distance on the relevant side, for clarity
finalResult.distance = finalResult.distance.horizontal || finalResult.distance.vertical;

// beginners may not be comfortable with the concept of editing the object
//passed by reference, so we provide an edit function and pass a clone
var finalResultClone = $.extend(true, {}, finalResult);

// emit an event on the instance
self.__instance._trigger({
edit: function edit(result) {
finalResult = result;
},
event: event,
helper: helper,
position: finalResultClone,
type: 'position'
});
if (self.__options.functionPosition) {
var result = self.__options.functionPosition.call(self, self.__instance, helper, finalResultClone);
if (result) finalResult = result;
}

// end the positioning tests session (the user might have had a
// use for it during the position event, now it's over)
ruler.destroy();

// compute the position of the target relatively to the tooltip root
// element so we can place the arrow and make the needed adjustments
var arrowCoord, maxVal;
if (finalResult.side == 'top' || finalResult.side == 'bottom') {
arrowCoord = {
prop: 'left',
val: finalResult.target - finalResult.coord.left
};
maxVal = finalResult.size.width - this.__options.minIntersection;
} else {
arrowCoord = {
prop: 'top',
val: finalResult.target - finalResult.coord.top
};
maxVal = finalResult.size.height - this.__options.minIntersection;
}

// cannot lie beyond the boundaries of the tooltip, minus the
// arrow margin
if (arrowCoord.val < this.__options.minIntersection) {
arrowCoord.val = this.__options.minIntersection;
} else if (arrowCoord.val > maxVal) {
arrowCoord.val = maxVal;
}
var originParentOffset;

// let's convert the window-relative coordinates into coordinates relative to the
// future positioned parent that the tooltip will be appended to
if (helper.geo.origin.fixedLineage) {
// same as windowOffset when the position is fixed
originParentOffset = helper.geo.origin.windowOffset;
} else {
// this assumes that the parent of the tooltip is located at
// (0, 0) in the document, typically like when the parent is
// <body>.
// If we ever allow other types of parent, .tooltipster-ruler
// will have to be appended to the parent to inherit css style
// values that affect the display of the text and such.
originParentOffset = {
left: helper.geo.origin.windowOffset.left + helper.geo.window.scroll.left,
top: helper.geo.origin.windowOffset.top + helper.geo.window.scroll.top
};
}
finalResult.coord = {
left: originParentOffset.left + (finalResult.coord.left - helper.geo.origin.windowOffset.left),
top: originParentOffset.top + (finalResult.coord.top - helper.geo.origin.windowOffset.top)
};

// set position values on the original tooltip element

self.__sideChange(self.__instance._$tooltip, finalResult.side);
if (helper.geo.origin.fixedLineage) {
self.__instance._$tooltip.css('position', 'fixed');
} else {
// CSS default
self.__instance._$tooltip.css('position', '');
}
self.__instance._$tooltip.css({
left: finalResult.coord.left,
top: finalResult.coord.top,
// we need to set a size even if the tooltip is in its natural size
// because when the tooltip is positioned beyond the width of the body
// (which is by default the width of the window; it will happen when
// you scroll the window horizontally to get to the origin), its text
// content will otherwise break lines at each word to keep up with the
// body overflow strategy.
height: finalResult.size.height,
width: finalResult.size.width
}).find('.tooltipster-arrow').css({
'left': '',
'top': ''
}).css(arrowCoord.prop, arrowCoord.val);

// append the tooltip HTML element to its parent
self.__instance._$tooltip.appendTo(self.__instance.option('parent'));
self.__instance._trigger({
type: 'repositioned',
event: event,
position: finalResult
});
},
/**
 * Make whatever modifications are needed when the side is changed. This has
 * been made an independant method for easy inheritance in custom plugins based
 * on this default plugin.
 *
 * @param {object} $obj
 * @param {string} side
 * @private
 */
__sideChange: function __sideChange($obj, side) {
$obj.removeClass('tooltipster-bottom').removeClass('tooltipster-left').removeClass('tooltipster-right').removeClass('tooltipster-top').addClass('tooltipster-' + side);
},
/**
 * Returns the target that the tooltip should aim at for a given side.
 * The calculated value is a distance from the edge of the window
 * (left edge for top/bottom sides, top edge for left/right side). The
 * tooltip will be centered on that position and the arrow will be
 * positioned there (as much as possible).
 *
 * @param {object} helper
 * @return {integer}
 * @private
 */
__targetFind: function __targetFind(helper) {
var target = {},
rects = this.__instance._$origin[0].getClientRects();

// these lines fix a Chrome bug (issue #491)
if (rects.length > 1) {
var opacity = this.__instance._$origin.css('opacity');
if (opacity == 1) {
this.__instance._$origin.css('opacity', 0.99);
rects = this.__instance._$origin[0].getClientRects();
this.__instance._$origin.css('opacity', 1);
}
}

// by default, the target will be the middle of the origin
if (rects.length < 2) {
target.top = Math.floor(helper.geo.origin.windowOffset.left + helper.geo.origin.size.width / 2);
target.bottom = target.top;
target.left = Math.floor(helper.geo.origin.windowOffset.top + helper.geo.origin.size.height / 2);
target.right = target.left;
}
// if multiple client rects exist, the element may be text split
// up into multiple lines and the middle of the origin may not be
// best option anymore. We need to choose the best target client rect
else {
// top: the first
var targetRect = rects[0];
target.top = Math.floor(targetRect.left + (targetRect.right - targetRect.left) / 2);

// right: the middle line, rounded down in case there is an even
// number of lines (looks more centered => check out the
// demo with 4 split lines)
if (rects.length > 2) {
targetRect = rects[Math.ceil(rects.length / 2) - 1];
} else {
targetRect = rects[0];
}
target.right = Math.floor(targetRect.top + (targetRect.bottom - targetRect.top) / 2);

// bottom: the last
targetRect = rects[rects.length - 1];
target.bottom = Math.floor(targetRect.left + (targetRect.right - targetRect.left) / 2);

// left: the middle line, rounded up
if (rects.length > 2) {
targetRect = rects[Math.ceil((rects.length + 1) / 2) - 1];
} else {
targetRect = rects[rects.length - 1];
}
target.left = Math.floor(targetRect.top + (targetRect.bottom - targetRect.top) / 2);
}
return target;
}
}
});

/* a build task will add "return $;" here */
return $;
});

/* Start Wp-statistics Admin Js */
var wps_js = {};

/* Get WP Statistics global Data From Frontend */
wps_js.global = typeof wps_global != 'undefined' ? wps_global : [];

/* WordPress Global Lang */
wps_js._ = function (key) {
return key in this.global.i18n ? this.global.i18n[key] : '';
};

/* Check Active Option */
wps_js.is_active = function (option) {
return wps_js.global.options[option] === 1;
};
/** Set AjaxQ Option */
wps_js.ajax_queue = {
key: 'wp-statistics',
time: 400 // millisecond
};

/**
 * Base AjaxQ function For All request
 *
 * @param url
 * @param params
 * @param callback
 * @param error_callback
 * @param type
 * @param internal
 */
wps_js.ajaxQ = function (url, params, callback, error_callback) {
var type = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'GET';
var internal = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
// Check Url
if (url === false || url === "metabox") {
url = wps_js.global.meta_box_api;
}

// Add nonce to the params
params['wps_nonce'] = wps_js.global.rest_api_nonce;

// prepare Ajax Parameter
var ajaxQ = {
url: url,
type: type,
dataType: "json",
crossDomain: true,
cache: false,
data: params,
success: function success(data) {
// Check Meta Box URL
if (url === wps_js.global.meta_box_api && internal === true) {
// Check is NO Data Meta Box
if (data['no_data']) {
jQuery(wps_js.meta_box_inner(params.name)).empty().html(wps_js.no_meta_box_data());
if (wps_js.is_active('overview_page') || wps_js.global.page.file === "index.php") {
wps_js.meta_box_footer(params.name, data);
}
} else {
// Show Meta Box
jQuery(wps_js.meta_box_inner(params.name)).empty().html(wps_js[callback]['view'](data));

// Check After Load Hook
if (wps_js[callback]['meta_box_init']) {
setTimeout(function () {
wps_js[callback]['meta_box_init'](data);
}, 150);
}
if (wps_js.is_active('overview_page') || wps_js.global.page.file === "index.php") {
wps_js.meta_box_footer(params.name, data);
}
}
} else {
// If Not Meta Box Ajax
wps_js[callback](data);
}
},
error: function error(xhr, status, _error) {
// Check Meta Box Error
if (url === wps_js.global.meta_box_api && internal === true) {
jQuery(wps_js.meta_box_inner(params.name)).empty().html(wps_js[error_callback](xhr.responseText));
} else {
// Global Call Back Error
wps_js[error_callback](xhr.responseText);
}
}
};

// Check WordPress REST-API Nonce [https://developer.wordpress.org/rest-api/using-the-rest-api/authentication/]
if (url === wps_js.global.meta_box_api) {
ajaxQ.beforeSend = function (xhr) {
//xhr.setRequestHeader('X-WP-Nonce', wps_js.global.rest_api_nonce); commented because of the switching to admin-ajax.php
xhr.setRequestHeader('Access-Control-Allow-Origin', '*');
};
}

// Send Request and Get Response
jQuery.ajaxq(wps_js.ajax_queue.key, ajaxQ);
};
/**
 * Default PlaceHolder if Custom MetaBox have not this Method
 */
wps_js.placeholder = function () {
var html = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
return "<div class=\"wps-ph-item\"><div class=\"wps-ph-col-12\">".concat(wps_js.placeholder_content('picture'), "").concat(wps_js.placeholder_content('line'), "</div>") + (html !== false ? html : '') + "</div>";
};

/**
 * Line Placeholder
 */
wps_js.line_placeholder = function () {
var number = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
var html = "<div class=\"wps-ph-item\">";
for (var i = 0; i < number; i++) {
html += "<div class=\"wps-ph-col-12\"> <div class=\"wps-ph-row\"><div class=\"wps-ph-col-6 big\"></div><div class=\"wps-ph-col-4 empty big\"></div><div class=\"wps-ph-col-4\"></div><div class=\"wps-ph-col-8 empty\"></div><div class=\"wps-ph-col-6\"></div><div class=\"wps-ph-col-6 empty\"></div><div class=\"wps-ph-col-12\"></div> </div></div>";
}
html += "</div>";
return html;
};

/**
 * Default Circle PlaceHolder
 */
wps_js.circle_placeholder = function () {
return "<div class=\"wps-ph-item\"> ".concat(wps_js.placeholder_content('circle'), "</div>");
};

/**
 * Default Circle PlaceHolder
 */
wps_js.rectangle_placeholder = function () {
var cls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
return "<div class=\"wps-ph-item" + (cls.length > 0 ? ' ' + cls : '') + "\"><div class=\"wps-ph-col-12\">".concat(wps_js.placeholder_content('picture'), "</div></div>");
};

/**
 * Type Of Place Holder Content
 *
 * @param type
 */
wps_js.placeholder_content = function () {
var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'line';
// Create Empty Html
var html = '';
switch (type) {
case "picture":
{
html = "<div class=\"wps-ph-picture\"></div>";
break;
}
case "line":
{
html = "<div class=\"wps-ph-row\"><div class=\"wps-ph-col-6 big\"></div><div class=\"wps-ph-col-4 empty big\"></div><div class=\"wps-ph-col-2 big\"></div><div class=\"wps-ph-col-4\"></div><div class=\"wps-ph-col-8 empty\"></div><div class=\"wps-ph-col-6\"></div><div class=\"wps-ph-col-6 empty\"></div><div class=\"wps-ph-col-12\"></div> </div>";
break;
}
case "circle":
{
html = "<div class=\"wps-ph-col-2\"></div><div class=\"wps-ph-col-8\"><div class=\"wps-ph-avatar\"></div></div>";
break;
}
default:
{
break;
}
}
return html;
};
/**
 * Check Exist Dom
 */
wps_js.exist_tag = function (tag) {
return jQuery(tag).length;
};
/**
 * Jquery UI Picker
 */
wps_js.date_picker = function () {
var datePickerField = jQuery('input[data-wps-date-picker]');
if (datePickerField.length) {
datePickerField.daterangepicker({
singleDatePicker: true,
showDropdowns: true,
minYear: 1998,
drops: 'up',
opens: document.getElementById('TB_window') ? 'center' : 'right',
maxYear: parseInt(new Date().getFullYear() + 1),
locale: {
format: 'YYYY-MM-DD'
}
});
datePickerField.on('show.daterangepicker', function (ev, picker) {
var correspondingPicker = picker.container;
jQuery(correspondingPicker).addClass(ev.target.className);
});
}
};

/**
 * Set Select2
 */
wps_js.select2 = function () {
jQuery("select[data-type-show=select2]").select2();
};
var wpsSelect2 = jQuery('.wps-select2');
var wpsBody = jQuery('body');
var wpsDropdown = jQuery('.wps-dropdown');
if (wpsSelect2.length) {
var wpsFilterPage = jQuery('.wps-filter-page');
var dirValue = wpsBody.hasClass('rtl') ? 'rtl' : 'ltr';
wpsSelect2.select2({
dropdownParent: $('.wps-filter-page'),
dir: dirValue,
dropdownAutoWidth: true,
dropdownCssClass: 'wps-select2-filter-dropdown'
});
wpsSelect2.on('select2:open', function () {
wpsDropdown.addClass('active');
});
wpsSelect2.on('select2:close', function () {
wpsDropdown.removeClass('active');
});
wpsSelect2.on('change', function () {
var selectedOption = jQuery(this).find('option:selected');
var url = selectedOption.val();
if (url) {
window.location.href = url;
}
});
if (wpsFilterPage.length) {
wpsSelect2.select2({
dropdownParent: $('.wps-filter-page'),
dir: dirValue,
dropdownAutoWidth: true,
dropdownCssClass: 'wps-select2-filter-dropdown',
ajax: {
delay: 500,
url: wps_js.global.ajax_url,
dataType: 'json',
data: function data(params) {
var query = {
wps_nonce: wps_js.global.rest_api_nonce,
search: params.term,
action: 'wp_statistics_get_page_filter_items',
paged: params.page || 1
};
if (wps_js.isset(wps_js.global, 'request_params', 'author_id')) {
query.author_id = wps_js.global.request_params.author_id;
}
if (wps_js.isset(wps_js.global, 'request_params', 'page')) {
query.page = wps_js.global.request_params.page;
}
if (wps_js.isset(wps_js.global, 'request_params', 'pt')) {
query.post_type = wps_js.global.request_params.pt;
}
if (wps_js.isset(wps_js.global, 'request_params', 'pid')) {
query.post_id = wps_js.global.request_params.pid;
}
return query;
}
}
});
wpsFilterPage.on('click', function () {
wpsSelect2.select2('open');
});
}
}

/**
 * Set Tooltip
 */
wps_js.tooltip = function () {
jQuery('.wps-tooltip').tooltipster({
theme: 'tooltipster-flat'
});
jQuery('body').on('mouseenter touchstart', '.wps-tooltip:not(.tooltipstered)', function () {
$(this).tooltipster({
theme: 'tooltipster-flat'
}).tooltipster('open');
});
};

/**
 * Execute Tooltip
 */
wps_js.tooltip();

/**
 * Redirect To Custom Url
 *
 * @param url
 */
wps_js.redirect = function (url) {
window.location.replace(url);
};

/**
 * Create Line Chart JS
 */
wps_js.line_chart = function (tag_id, title, label, data, newOptions) {
// Get Element By ID
var ctx = document.getElementById(tag_id).getContext('2d');

// Check is RTL Mode
if (wps_js.is_active('rtl')) {
Chart.defaults.global = {
defaultFontFamily: "Tahoma"
};
}
var defaultOptions = {
type: 'line',
data: {
labels: label,
datasets: data
},
options: {
responsive: true,
legend: {
position: 'bottom'
},
animation: {
duration: 1500
},
title: {
display: true,
text: title
},
tooltips: {
mode: 'index',
intersect: false
},
interaction: {
intersect: false,
mode: 'index'
},
scales: {
y: {
ticks: {
stepSize: 1
}
}
},
plugins: {
zoom: {
pan: {
enabled: true,
mode: 'xy'
},
zoom: {
wheel: {
enabled: true,
speed: 0.05,
modifierKey: 'ctrl'
},
pinch: {
enabled: true
},
mode: 'xy'
}
}
}
}
};
var options = Object.assign({}, defaultOptions, newOptions);

// Create Chart
new Chart(ctx, options);
};

/**
 * Create pie Chart JS
 */
wps_js.pie_chart = function (tag_id, label, data) {
var label_callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
var tooltip_callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
// Get Element By ID
var ctx = document.getElementById(tag_id).getContext('2d');

// Check is RTL Mode
if (wps_js.is_active('rtl')) {
Chart.defaults.global = {
defaultFontFamily: "Tahoma"
};
}
// Set Default Label Callback
if (label_callback === false) {
label_callback = function label_callback(tooltipItem) {
return tooltipItem.formattedValue;
};
}

// Set Default tooltip title Callback
if (tooltip_callback === false) {
tooltip_callback = function tooltip_callback(tooltipItem) {
return tooltipItem.label;
};
}

// Create Chart
new Chart(ctx, {
type: 'pie',
data: {
labels: label,
datasets: data
},
options: {
responsive: true,
plugins: {
legend: {
position: function position(chart) {
if (chart.chart.width > 400) {
return 'left';
}
return 'top';
}
},
tooltip: {
enable: true,
callbacks: {
label: label_callback,
title: tooltip_callback
}
}
},
animation: {
duration: 1500
}
},
plugins: [{
afterDraw: function afterDraw(chart) {
if (chart.data.datasets[0].data.every(function (x) {
return x == 0;
}) === true) {
var _ctx = chart.ctx;
var width = chart.width;
var height = chart.height;
chart.clear();
_ctx.save();
_ctx.textAlign = 'center';
_ctx.textBaseline = 'middle';
_ctx.font = "14px normal 'Tahoma'";
_ctx.fillText(wps_js._('no_data'), width / 2, height / 2);
_ctx.restore();
}
}
}]
});
};

/**
 * Create Chart ID by Meta Box name
 *
 * @param meta_box
 */
wps_js.chart_id = function (meta_box) {
return 'wp-statistics-' + meta_box + '-meta-box-chart';
};

/**
 * Generate Flat Random Color
 */
wps_js.random_color = function () {
var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
var colors = [[243, 156, 18, "#f39c12"], [52, 152, 219, "#3498db"], [192, 57, 43, "#c0392b"], [155, 89, 182, "#9b59b6"], [39, 174, 96, "#27ae60"], [230, 126, 34, "#e67e22"], [142, 68, 173, "#8e44ad"], [46, 204, 113, "#2ecc71"], [41, 128, 185, "#2980b9"], [22, 160, 133, "#16a085"], [211, 84, 0, "#d35400"], [44, 62, 80, "#2c3e50"], [241, 196, 15, "#f1c40f"], [231, 76, 60, "#e74c3c"], [26, 188, 156, "#1abc9c"], [46, 204, 113, "#2ecc71"], [52, 152, 219, "#3498db"], [155, 89, 182, "#9b59b6"], [52, 73, 94, "#34495e"], [22, 160, 133, "#16a085"], [39, 174, 96, "#27ae60"], [44, 62, 80, "#2c3e50"], [241, 196, 15, "#f1c40f"], [230, 126, 34, "#e67e22"], [231, 76, 60, "#e74c3c"], [236, 240, 241, "#9b9e9f"], [149, 165, 166, "#a65d20"]];
return colors[i === false ? Math.floor(Math.random() * colors.length) : i];
};

/**
 * Show Domain Icon
 */
wps_js.site_icon = function (domain) {
return "<img src=\"https://www.google.com/s2/favicons?domain=".concat(domain, "\" width=\"18\" height=\"18\" alt=\"").concat(domain, "\" style=\"vertical-align: middle;\" />");
};

/**
 * Enable/Disable WordPress Admin PostBox Ajax Request
 *
 * @param type
 */
wps_js.wordpress_postbox_ajax = function () {
var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'enable';
var wordpress_postbox = jQuery('.postbox .hndle, .postbox .handlediv');
if (type === 'enable') {
wordpress_postbox.on('click', window.postboxes.handle_click);
} else {
wordpress_postbox.off('click', window.postboxes.handle_click);
}
};

/**
 * Isset Property in Object
 *
 * @param obj
 */
wps_js.isset = function (obj) {
var args = Array.prototype.slice.call(arguments, 1);
for (var i = 0; i < args.length; i++) {
if (!obj || !obj.hasOwnProperty(args[i])) {
return false;
}
obj = obj[args[i]];
}
return true;
};

/**
 * Number Format
 *
 * @param number
 * @param decimals
 * @param dec_point
 * @param thousands_point
 * @returns {*}
 */
wps_js.number_format = function (number, decimals, dec_point, thousands_point) {
if (number == null || !isFinite(number)) {
throw new TypeError("number is not valid");
}
if (!decimals) {
var len = number.toString().split('.').length;
decimals = len > 1 ? len : 0;
}
if (!dec_point) {
dec_point = '.';
}
if (!thousands_point) {
thousands_point = ',';
}
number = parseFloat(number).toFixed(decimals);
number = number.replace(".", dec_point);
var splitNum = number.split(dec_point);
splitNum[0] = splitNum[0].replace(/\B(?=(\d{3})+(?!\d))/g, thousands_point);
number = splitNum.join(dec_point);
return number;
};

/**
 * Set Equal Bigger Div Height For WordPress PostBox
 *
 * @param Dom_1
 * @param Dom_2
 */
wps_js.set_equal_height = function (Dom_1, Dom_2) {
var tbl_h = jQuery(Dom_1).height();
var ch_h = jQuery(Dom_2).height();
var ex = Dom_2;
var val = tbl_h;
if (tbl_h < ch_h) {
ex = Dom_1;
val = ch_h;
}
jQuery(ex).css('height', val + 'px');
};

/**
 * Create Half WordPress Post Box
 *
 * @param div_class
 * @param div_id
 * @returns {string}
 */
wps_js.Create_Half_PostBox = function (div_class, div_id) {
return "<div class=\"postbox-container wps-postbox-half ".concat(div_class, "\"><div class=\"metabox-holder\"><div class=\"meta-box-sortables\"> <div class=\"postbox\" id=\"").concat(div_id, "\"> <div class=\"inside\"></div></div></div></div></div>");
};

/**
 * Check IS IP
 *
 * @param str
 * @returns {boolean}
 */
wps_js.isIP = function (str) {
var octet = '(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]?|0)';
var regex = new RegExp("^".concat(octet, "\\.").concat(octet, "\\.").concat(octet, "\\.").concat(octet, "$"));
return regex.test(str);
};

/**
 * Get Link Params
 */
wps_js.getLinkParams = function (param) {
var link = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
if (!link) {
link = window.location.href;
}
var v = link.match(new RegExp('(?:[\?\&]' + param + '=)([^&]+)'));
return v ? v[1] : null;
};

/**
 * Sum array Of Item
 *
 * @param array
 * @returns {*}
 */
wps_js.sum = function (array) {
return array.reduce(function (a, b) {
return a + b;
}, 0);
};

// Head filters drop down
jQuery(document).ready(function () {
var dropdowns = document.querySelectorAll(".wps-head-filters__item");
dropdowns.forEach(function (dropdown) {
dropdown.classList.remove('loading');
dropdown.addEventListener("click", function (event) {
var dropdownContent = dropdown.querySelector(".dropdown-content");
if (dropdownContent) {
dropdownContent.classList.toggle("show");
}
});
});
window.addEventListener("click", function (event) {
dropdowns.forEach(function (dropdown) {
var dropdownContent = dropdown.querySelector(".dropdown-content");
if (dropdownContent && !dropdown.contains(event.target)) {
dropdownContent.classList.remove("show");
}
});
});
});
jQuery(document).ready(function () {
var targetElement = document.querySelector('.wp-header-end');
var noticeElement = document.querySelector('.notice.notice-warning.update-nag');
// Check if both targetElement and noticeElement exist
if (targetElement && noticeElement) {
// Move the notice element after the target element
targetElement.parentNode.insertBefore(noticeElement, targetElement.nextSibling);
}
jQuery(document).on('click', '.wps-privacy-list__item .wps-privacy-list__title', function (e) {
var title = jQuery(e.currentTarget);
var content = title.siblings('.wps-privacy-list__content');

// If the action button is clicked, don't expand the item
if (jQuery(e.target).is('.wps-privacy-list__button')) {
return;
}
title.toggleClass('open');
if (content.hasClass('show')) {
content.removeClass('show');
} else {
content.addClass('show');
}
});
});

/**
 * FeedbackBird position
 * */
function moveFeedbackBird() {
var windowWidth = window.outerWidth || document.documentElement.clientWidth;
var feedbackBird = document.getElementById('feedback-bird-app');
var feedbackBirdTitle = document.querySelector('.c-fbb-widget__header__title');
var license = document.querySelector('.wps-mobileMenuContent .wps-bundle');
var support = document.querySelector('.wps-adminHeader__side');
if (feedbackBird && document.body.classList.contains('wps_page')) {
if (windowWidth <= 1030) {
var cutDiv = feedbackBird.parentNode.removeChild(feedbackBird);
license.parentNode.insertBefore(cutDiv, license);
} else {
var _cutDiv = feedbackBird.parentNode.removeChild(feedbackBird);
support.appendChild(_cutDiv);
}
feedbackBird.style.display = 'block';
feedbackBird.setAttribute('title', feedbackBirdTitle.innerHTML);
}
}
window.onload = moveFeedbackBird;
window.addEventListener('resize', moveFeedbackBird);
jQuery(document).ready(function () {
var targetElement = document.querySelector('.wp-header-end');
var noticeElement = document.querySelector('.notice.notice-warning.update-nag');
// Check if both targetElement and noticeElement exist
if (targetElement && noticeElement) {
// Move the notice element after the target element
targetElement.parentNode.insertBefore(noticeElement, targetElement.nextSibling);
}
});
/**
 * Sanitize MetaBox name
 *
 * @param meta_box
 * @returns {*|void|string|never}
 * @see https://www.designcise.com/web/tutorial/how-to-replace-all-occurrences-of-a-word-in-a-javascript-string
 */
wps_js.sanitize_meta_box_name = function (meta_box) {
return meta_box.replace(new RegExp('-', 'g'), "_");
};

/**
 * Get Meta Box Method name
 */
wps_js.get_meta_box_method = function (meta_box) {
return this.sanitize_meta_box_name(meta_box) + '_meta_box';
};

/**
 * Get Meta Box Tags ID
 */
wps_js.getMetaBoxKey = function (key) {
return 'wp-statistics-' + key + '-widget';
};

/**
 * Show No Data Error if Meta Box is Empty
 */
wps_js.no_meta_box_data = function () {
return '<div class="o-wrap o-wrap--no-data">' + wps_js._('no_data') + '</div>';
};

/**
 * Show Error Connection if Meta Box is Empty
 */
wps_js.error_meta_box_data = function (xhr) {
if (typeof xhr !== 'undefined') {
try {
var data = JSON.parse(xhr);
if (wps_js.isset(data, 'message')) {
return '<div class="o-wrap o-wrap--no-data">' + data['message'] + '</div>';
}
} catch (error) {
console.log('An unexpected error occurred: ', xhr, error);
}
}
return '<div class="o-wrap o-wrap--no-data">' + wps_js._('rest_connect') + '</div>';
};

/**
 * Get MetaBox information by key
 */
wps_js.get_meta_box_info = function (key) {
if (key in wps_js.global.meta_boxes) {
return wps_js.global.meta_boxes[key];
}
return [];
};

/**
 * Get MetaBox Lang
 */
wps_js.meta_box_lang = function (meta_box, lang) {
if (lang in wps_js.global.meta_boxes[meta_box]['lang']) {
return wps_js.global.meta_boxes[meta_box]['lang'][lang];
}
return '';
};

/**
 * Get MetaBox inner text selector
 */
wps_js.meta_box_inner = function (key) {
return "#" + wps_js.getMetaBoxKey(key) + " div.inside";
};

/**
 * Get MetaBox name by tag ID
 * ex: wp-statistics-summary-widget -> summary
 */
wps_js.meta_box_name_by_id = function (ID) {
return ID.split('statistics-').pop().split('-widget')[0];
};

/**
 * Create Custom Button for Meta Box
 */
wps_js.meta_box_button = function (key) {
var selector = "#" + wps_js.getMetaBoxKey(key) + " .handle-actions button:first";
var meta_box_info = wps_js.get_meta_box_info(key);

// Gutenberg Button Style
var gutenberg_style = 'z-index: 9999;position: absolute;top: 1px;';
var position_gutenberg = 'right';
if (wps_js.is_active('rtl')) {
position_gutenberg = 'left';
}

// Clean Button
jQuery("#" + wps_js.getMetaBoxKey(key) + " button[class*=wps-refresh]").remove();

// Add Refresh Button
jQuery("<button class=\"handlediv wps-refresh\"" + (wps_js.is_active('gutenberg') ? " style=\"".concat(gutenberg_style).concat(position_gutenberg, ": 3%;\" ") : 'style="line-height: 28px;"') + " type=\"button\" data-tooltip=\"" + wps_js._('reload') + "\"></button>").insertBefore(selector);
};
wps_js.meta_box_tooltip = function (key) {
var selector = "#" + wps_js.getMetaBoxKey(key) + " h2.hndle";
var meta_box_info = wps_js.get_meta_box_info(key);
if (meta_box_info.hasOwnProperty('description')) {
var title = jQuery(selector).text();
var tooltip = meta_box_info.description;
var newTitle = '<a href="#" class="wps-tooltip" title="' + tooltip + '"><i class="wps-tooltip-icon"></i></a>';
if (tooltip) jQuery(selector).append(newTitle);
}
};

/**
 * Run Meta Box
 *
 * @param key
 * @param params
 * @param button
 */
wps_js.run_meta_box = function (key) {
var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
var button = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
// Check Exist Meta Box div
if (wps_js.exist_tag("#" + wps_js.getMetaBoxKey(key)) && (wps_js.is_active('gutenberg') || !wps_js.is_active('gutenberg') && jQuery("#" + wps_js.getMetaBoxKey(key)).is(":visible"))) {
// Meta Box Main
var main = jQuery(wps_js.meta_box_inner(key));

// Get Meta Box Method
var method = wps_js.get_meta_box_method(key);

// Add tooltip
wps_js.meta_box_tooltip(key);

// Check Exist Method name
if (method in wps_js) {
// Check PlaceHolder Method
if ("placeholder" in wps_js[method]) {
main.html(wps_js[method]["placeholder"]());
} else {
main.html(wps_js.placeholder());
}

// Add Custom Button
if (button === true) {
wps_js.meta_box_button(key);
}

// Get Meta Box Data
var arg = {
'name': key
};
if (params !== false) {
arg = Object.assign(params, arg);
}

// Check Request Params in Meta box
if ("params" in wps_js[method]) {
arg = Object.assign(arg, wps_js[method]['params']());
}

// Run
wps_js.ajaxQ('metabox', arg, method, 'error_meta_box_data');
}
}
};
wps_js.prepare_date_filter_data = function (args) {
var data = {
'ago': ''
};
if (args.hasOwnProperty('footer_options')) {
var selectedDateFilter = args.footer_options.default_date_filter;
if (selectedDateFilter.length) {
var dateFilterSplted = selectedDateFilter.split('|');
if (dateFilterSplted[0] == 'filter') {
data.ago = dateFilterSplted[1];
} else {
var customDateRange = dateFilterSplted[1].split(':');
data.ago = '';
data.from = customDateRange[1];
data.to = customDateRange[2];
}
}
}
return data;
};

/**
 * Load all Meta Boxes
 */
wps_js.run_meta_boxes = function () {
var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
if (list === false) {
list = Object.keys(wps_js.global.meta_boxes);
}
list.forEach(function (value) {
var args = wps_js.global.meta_boxes[value];

// Check Date Filter
var data = wps_js.prepare_date_filter_data(args);

// Run Meta Box
wps_js.run_meta_box(value, data);
});
};

/**
 * Render Meta Box Footer
 */
wps_js.meta_box_footer = function (key, data) {
var params = {
'footer_options': {
'filter_by_date': false,
'default_date_filter': '',
'display_more_link': false,
'more_link_title': ''
}
};
var args = wps_js.global.meta_boxes[key];
if (args.hasOwnProperty('footer_options')) {
Object.assign(params.footer_options, args.footer_options);
}
var selectedDateFilter = '';
if (data.hasOwnProperty('filter')) {
selectedDateFilter = data.filter;
} else if (typeof params.footer_options.default_date_filter != 'undefined') {
selectedDateFilter = params.footer_options.default_date_filter;
}
var selectedStartDate = '';
if (data.hasOwnProperty('filter_start_date')) {
selectedStartDate = data.filter_start_date;
}
var selectedEndDate = '';
if (data.hasOwnProperty('filter_end_date')) {
selectedEndDate = data.filter_end_date;
}
var fromDate = '';
if (data.hasOwnProperty('from')) {
fromDate = data.from;
}
var toDate = '';
if (data.hasOwnProperty('to')) {
toDate = data.to;
}
if (!params.footer_options.filter_by_date && !params.footer_options.display_more_link) return;
var html = '<div class="c-footer"><div class="c-footer__filter js-widget-filters">';
if (params.footer_options.filter_by_date) {
html += "<button class=\"c-footer__filter__btn js-filters-toggle\">" + wps_js._('str_' + selectedDateFilter) + "</button><div class=\"c-footer__filters\"><div class=\"c-footer__filters__current-filter\"><span class=\"c-footer__current-filter__title js-filter-title\">Last 7 days</span><span class=\"c-footer__current-filter__date-range hs-filter-range\">May 12,2020-May 20, 2020</span></div><div class=\"c-footer__filters__list\"><button data-metabox-key=\"".concat(key, "\" data-filter=\"today\" class=\"c-footer__filters__list-item\">") + wps_js._('str_today') + "</button><button data-metabox-key=\"".concat(key, "\" data-filter=\"yesterday\" class=\"c-footer__filters__list-item\">") + wps_js._('str_yesterday') + "</button><button data-metabox-key=\"".concat(key, "\" data-filter=\"7days\" class=\"c-footer__filters__list-item\">") + wps_js._('str_7days') + "</button><button data-metabox-key=\"".concat(key, "\" data-filter=\"30days\" class=\"c-footer__filters__list-item\">") + wps_js._('str_30days') + "</button><button data-metabox-key=\"".concat(key, "\" data-filter=\"last_month\" class=\"c-footer__filters__list-item\">") + wps_js._('str_last_month') + "</button><button data-metabox-key=\"".concat(key, "\" data-filter=\"90days\" class=\"c-footer__filters__list-item\">") + wps_js._('str_90days') + "</button><button class=\"c-footer__filters__list-item c-footer__filters__list-item--more\" onclick=\"jQuery(this).closest('.c-footer__filters__list').find('.js-more-filters').addClass('is-open')\">" + wps_js._('str_more') + " <svg width=\"8\" height=\"6\" viewBox=\"0 0 8 6\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.25736 5.07544L4.32794 5.14601C4.241 5.23295 4.12308 5.28182 4.00009 5.28182C3.87715 5.28182 3.7592 5.233 3.67226 5.14604C3.67226 5.14603 3.67225 5.14603 3.67225 5.14602L0.0358041 1.50968L0.106514 1.43896L0.0358032 1.50968C-0.14526 1.32861 -0.14526 1.03507 0.0357727 0.854006M4.25736 5.07544L0.10649 0.92471M4.25736 5.07544L4.32794 5.14601L7.9642 1.50965C8.14527 1.32859 8.14527 1.03504 7.9642 0.853976C7.78317 0.67294 7.4896 0.672907 7.30853 0.853976L7.37924 0.924687M4.25736 5.07544L7.37924 0.924687M0.0357727 0.854006L0.10649 0.92471M0.0357727 0.854006C0.0357708 0.854008 0.0357689 0.85401 0.035767 0.854012L0.10649 0.92471M0.0357727 0.854006C0.126294 0.763456 0.245135 0.718189 0.363629 0.718189C0.482123 0.718189 0.600959 0.763457 0.691478 0.853975L4.00008 4.16249M0.10649 0.92471C0.177495 0.85368 0.270562 0.818189 0.363629 0.818189C0.456695 0.818189 0.549762 0.85368 0.620768 0.924686L3.92938 4.2332L4.00008 4.16249M4.00008 4.16249L7.30853 0.853977L7.37924 0.924687M4.00008 4.16249L4.0708 4.2332L7.37924 0.924687\" fill=\"#5F6368\" stroke=\"#5F6368\" stroke-width=\"0.2\"/></svg></button><div class=\"c-footer__filters__more-filters js-more-filters\"><button data-metabox-key=\"".concat(key, "\" data-filter=\"14days\" class=\"c-footer__filters__list-item\">") + wps_js._('str_14days') + "</button><button data-metabox-key=\"".concat(key, "\" data-filter=\"60days\" class=\"c-footer__filters__list-item\">") + wps_js._('str_60days') + "</button><button data-metabox-key=\"".concat(key, "\" data-filter=\"120days\" class=\"c-footer__filters__list-item\">") + wps_js._('str_120days') + "</button><button data-metabox-key=\"".concat(key, "\" data-filter=\"6months\" class=\"c-footer__filters__list-item\">") + wps_js._('str_6months') + "</button><button data-metabox-key=\"".concat(key, "\" data-filter=\"year\" class=\"c-footer__filters__list-item\">") + wps_js._('str_year') + "</button><button class=\"c-footer__filters__close-more-filters\" onclick=\"jQuery(this).closest('.js-more-fi' + 'lters').removeClass('is-open')\"><svg width=\"8\" height=\"6\" viewBox=\"0 0 8 6\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.25736 5.07544L4.32794 5.14601C4.241 5.23295 4.12308 5.28182 4.00009 5.28182C3.87715 5.28182 3.7592 5.233 3.67226 5.14604C3.67226 5.14603 3.67225 5.14603 3.67225 5.14602L0.0358041 1.50968L0.106514 1.43896L0.0358032 1.50968C-0.14526 1.32861 -0.14526 1.03507 0.0357727 0.854006M4.25736 5.07544L0.10649 0.92471M4.25736 5.07544L4.32794 5.14601L7.9642 1.50965C8.14527 1.32859 8.14527 1.03504 7.9642 0.853976C7.78317 0.67294 7.4896 0.672907 7.30853 0.853976L7.37924 0.924687M4.25736 5.07544L7.37924 0.924687M0.0357727 0.854006L0.10649 0.92471M0.0357727 0.854006C0.0357708 0.854008 0.0357689 0.85401 0.035767 0.854012L0.10649 0.92471M0.0357727 0.854006C0.126294 0.763456 0.245135 0.718189 0.363629 0.718189C0.482123 0.718189 0.600959 0.763457 0.691478 0.853975L4.00008 4.16249M0.10649 0.92471C0.177495 0.85368 0.270562 0.818189 0.363629 0.818189C0.456695 0.818189 0.549762 0.85368 0.620768 0.924686L3.92938 4.2332L4.00008 4.16249M4.00008 4.16249L7.30853 0.853977L7.37924 0.924687M4.00008 4.16249L4.0708 4.2332L7.37924 0.924687\" fill=\"#5F6368\" stroke=\"#5F6368\" stroke-width=\"0.2\"/></svg> " + wps_js._('str_back') + "</button></div><input type=\"text\" class=\"c-footer__filters__custom-date-input js-datepicker-input\"/><button data-metabox-key=\"".concat(key, "\" data-filter=\"custom\" class=\"c-footer__filters__list-item c-footer__filters__list-item--custom js-custom-datepicker\">") + wps_js._('str_custom') + "</button></div></div>";
}
html += "</div><div class=\"c-footer__more\">";
if (params.footer_options.display_more_link) {
html += "<a class=\"c-footer__more__link\" href=\"" + wps_js.global.admin_url + 'admin.php?page=' + args.page_url + "\">".concat(params.footer_options.more_link_title, "<svg width=\"14\" height=\"10\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"m9.61181.611328-.71269.712722 3.17148 3.17149L0 4.49951v1.00398h12.0706L8.89912 8.67495l.71269.71272L14 4.99948 9.61181.611328Z\" fill=\"#404BF2\"/></svg></a>");
}
html += "</div></div>";
jQuery(wps_js.meta_box_inner(key)).append(html);
var datePickerElement = jQuery(wps_js.meta_box_inner(key)).find('.js-datepicker-input').first();
datePickerElement.daterangepicker({
"autoApply": true
});
datePickerElement.on('apply.daterangepicker', function (ev, picker) {
wps_js.run_meta_box(key, {
'from': picker.startDate.format('YYYY-MM-DD'),
'to': picker.endDate.format('YYYY-MM-DD')
});
});

/**
 * Add click event to filters toggle
 */
jQuery('.js-filters-toggle:not(.is-ready)').on('click', function () {
jQuery('.js-widget-filters').removeClass('is-active');
jQuery('.postbox').removeClass('has-focus');
jQuery(this).closest('.js-widget-filters').toggleClass('is-active');
jQuery(this).closest('.postbox').toggleClass('has-focus');

/**
 * Open filters to the downside if there's not enough space.
 */
if (!jQuery(this).hasClass('is-active')) {
var targetTopPosition = jQuery(this)[0].getBoundingClientRect().top;
if (targetTopPosition < 350) {
jQuery(this).closest('.js-widget-filters').addClass('is-down');
}
}
});
jQuery('.js-filters-toggle:not(.is-ready)').addClass('is-ready');
wps_js.set_date_filter_as_selected(key, selectedDateFilter, selectedStartDate, selectedEndDate, fromDate, toDate);
};

/**
 * Set As Selected Date Filter
 */
wps_js.set_date_filter_as_selected = function (key, selectedDateFilter, selectedStartDate, selectedEndDate, fromDate, toDate) {
var metaBoxInner = jQuery(wps_js.meta_box_inner(key));
var filterBtn = jQuery(metaBoxInner).find('.c-footer__filter__btn');
var filterList = jQuery(metaBoxInner).find('.c-footer__filters__list');
var currentFilterTitle = jQuery(metaBoxInner).find('.c-footer__current-filter__title');
var currentFilterRange = jQuery(metaBoxInner).find('.c-footer__current-filter__date-range');
if (selectedDateFilter.length) {
filterList.find('button[data-filter]').removeClass('is-selected');
filterList.find('button[data-filter="' + selectedDateFilter + '"').addClass('is-selected');
filterBtn.text(wps_js._('str_' + selectedDateFilter));
currentFilterTitle.text(wps_js._('str_' + selectedDateFilter));
if (selectedDateFilter == 'custom') {
filterBtn.text(selectedStartDate + ' - ' + selectedEndDate);
var datePickerElement = jQuery(wps_js.meta_box_inner(key)).find('.js-datepicker-input').first();
datePickerElement.data('daterangepicker').setStartDate(moment(fromDate).format('MM/DD/YYYY'));
datePickerElement.data('daterangepicker').setEndDate(moment(toDate).format('MM/DD/YYYY'));
}
}
if (selectedStartDate.length && selectedEndDate.length) {
currentFilterRange.text(selectedStartDate + ' - ' + selectedEndDate);
}
};

/**
 * Meta Box Footer Handle Date Filter
 */
jQuery(document).on("click", 'button[data-filter]:not(.c-footer__filters__list-item--custom)', function () {
wps_js.run_meta_box(jQuery(this).attr('data-metabox-key'), {
'ago': jQuery(this).attr('data-filter')
});
});
jQuery(document).on("click", 'button[data-filter="custom"]', function () {
var metaBoxKey = jQuery(this).attr('data-metabox-key');
var datePickerElement = jQuery(wps_js.meta_box_inner(metaBoxKey)).find('.js-datepicker-input').first();
datePickerElement.data('daterangepicker').show();
});

/**
 * Disable Close WordPress Post ox for Meta Box Button
 *
 * @see wp-admin/js/postbox.js:107
 */
jQuery(document).on('mouseenter mouseleave', '.wps-refresh, .wps-more', function (ev) {
if (ev.type === 'mouseenter') {
wps_js.wordpress_postbox_ajax('disable');
} else {
wps_js.wordpress_postbox_ajax('enable');
}
});

/**
 * Meta Box Refresh Click Handler
 */
jQuery(document).on("click", '.wps-refresh', function (e) {
e.preventDefault();

// Get Meta Box name By Parent ID
var parentID = jQuery(this).closest(".postbox").attr("id");
var meta_box_name = wps_js.meta_box_name_by_id(parentID);
var args = wps_js.global.meta_boxes[meta_box_name];

// Check Date Filter
var data = wps_js.prepare_date_filter_data(args);

// Run Meta Box
wps_js.run_meta_box(meta_box_name, data, false);
setTimeout(function () {
jQuery('#' + parentID).find('.wps-refresh').trigger('blur');
}, 1000);
});

/**
 * Watch Show/Hide Meta Box in WordPress Dashboard
 * We dont Use PreventDefault Because WordPress Core uses Checked checkbox.
 */
jQuery(document).on("click", 'input[type=checkbox][id^="wp-statistics-"][id$="-widget-hide"]', function () {
// Check is Checked For Show Post Box
if (jQuery(this).is(':checked')) {
// Get Meta Box name By ID
var ID = jQuery(this).attr("id");
var meta_box_name = wps_js.meta_box_name_by_id(ID);

// Run Meta Box
wps_js.run_meta_box(meta_box_name);
}
});

/**
 * Show Select Date Time For Chart MetaBox
 */
wps_js.btn_group_chart = function (chart) {
var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
// Datetime Select List
var select_list = {
7: wps_js._('str_week'),
30: wps_js._('str_month'),
365: wps_js._('str_year')
};

// Check Active time
var active;
if (args.type == "ago") {
active = parseInt(args.days);
}

// Create Html Data
var html = "<div class=\"wps-btn-group\"><div class=\"btn-group\" role=\"group\">";

// Show Data
Object.keys(select_list).forEach(function (key) {
html += "<button type=\"button\" class=\"btn " + (key == active ? 'btn-primary' : 'btn-default') + "\" data-chart-time=\"".concat(chart, "\" data-time=\"").concat(key, "\">").concat(select_list[key], "</button>");
});

// Add Custom
html += "<button type=\"button\" class=\"btn " + (args.type == "between" ? 'btn-primary' : 'btn-default') + "\" data-custom-date-picker=\"".concat(chart, "\">").concat(wps_js._('custom'), "</button>");
html += "</div></div>";

// Show Jquery Date Picker
html += "<div data-chart-date-picker=\"".concat(chart, "\"") + (args.type == "ago" ? ' style="display:none;"' : '') + "><input type=\"text\" size=\"18\" name=\"date-from\" data-wps-date-picker=\"from\" value=\"".concat(args['from'], "\" placeholder=\"YYYY-MM-DD\" autocomplete=\"off\">") + wps_js._('to') + "<input type=\"text\" size=\"18\" name=\"date-to\" data-wps-date-picker=\"to\" value=\"".concat(args['to'], "\" placeholder=\"YYYY-MM-DD\" autocomplete=\"off\"><input type=\"submit\" value=\"") + wps_js._('go') + "\" data-between-chart-show=\"".concat(chart, "\" class=\"button-primary\"><input type=\"hidden\" name=\"\" id=\"date-from\" value=\"").concat(args['from'], "\"><input type=\"hidden\" name=\"\" id=\"date-to\" value=\"").concat(args['to'], "\"></div>");

// Show HTMl
return html;
};

/**
 * Seat Active Class after Click Btn Group
 */
jQuery(document).on("click", '.wps-btn-group button', function () {
jQuery('.wps-btn-group button').attr('class', 'btn btn-default');
jQuery(this).attr('class', 'btn btn-primary');
});

/**
 * SlideToggle Click on Custom Date Range
 */
jQuery(document).on("click", 'button[data-custom-date-picker]', function () {
jQuery('div[data-chart-date-picker= ' + jQuery(this).attr('data-custom-date-picker') + ']').slideDown();
});

/**
 * Button Group Handle Chart time Show
 */
jQuery(document).on("click", 'button[data-chart-time]', function () {
wps_js.run_meta_box(jQuery(this).attr('data-chart-time'), {
'ago': jQuery(this).attr('data-time'),
'no-data': 'no'
});
});

/**
 * Send From/To Chart
 */
jQuery(document).on("click", 'input[data-between-chart-show]', function () {
var chart = jQuery(this).attr('data-between-chart-show');
wps_js.run_meta_box(chart, {
'from': jQuery("div[data-chart-date-picker=" + chart + "] input[id=date-from]").val(),
'to': jQuery("div[data-chart-date-picker=" + chart + "] input[id=date-to]").val(),
'no-data': 'no'
});
});

/**
 * Close filters when clicking outside the filters
 * */
jQuery(document).on("click", function (event) {
if (!jQuery(event.target).closest(".js-widget-filters").length) {
jQuery('.js-widget-filters').removeClass('is-active');
jQuery('.postbox.has-focus').removeClass('has-focus');
jQuery('.c-footer__filter__btn.is-active').removeClass('is-active');
setTimeout(function () {
jQuery('.js-widget-filters').removeClass('is-down');
}, 500);
} else {
var targetClasses = event.target.classList;
if (targetClasses.contains('c-footer__filter__btn') && targetClasses.contains('is-active')) {
event.target.classList.remove('is-active');
jQuery('.js-widget-filters').removeClass('is-active');
jQuery('.postbox.has-focus').removeClass('has-focus');
setTimeout(function () {
jQuery('.js-widget-filters').removeClass('is-down');
}, 500);
} else if (targetClasses.contains('c-footer__filter__btn') && !targetClasses.contains('is-active')) {
event.target.classList.add('is-active');
}
}
});
wps_js.browsers_meta_box = {
placeholder: function placeholder() {
return wps_js.circle_placeholder();
},
view: function view() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
// Create Html
var html = '';

// // Check Show Button Group
// if (wps_js.is_active('overview_page')) {
// html += wps_js.btn_group_chart('browsers', args);
// setTimeout(function () {
// wps_js.date_picker();
// }, 1000);
// }

// Add Chart
html += '<div class="o-wrap"><div class="c-chart c-chart--limited-height"><canvas id="' + wps_js.chart_id('browsers') + '" height="220"></canvas></div></div>';

// show Data
return html;
},
meta_box_init: function meta_box_init() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
// Get Background Color
var backgroundColor = [];
var color;
for (var i = 0; i <= 10; i++) {
color = wps_js.random_color(i);
backgroundColor.push('rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + '0.4)');
}

// Prepare Data
var data = [{
label: wps_js._('browsers'),
data: args['browsers_value'],
backgroundColor: backgroundColor
}];
var label_callback = function label_callback(tooltipItem, data) {
return tooltipItem.label;
};
var title_callback = function title_callback(ctx) {
return wps_js._('visitors') + ':' + ctx[0].formattedValue;
};

// Show Chart
wps_js.pie_chart(wps_js.chart_id('browsers'), args['browsers_name'], data, label_callback, title_callback);

// Check Table information
if (wps_js.exist_tag('#' + wps_js.getMetaBoxKey('browsers-table'))) {
// Reset All Height
['browsers-table', 'browsers'].forEach(function (key) {
jQuery("#" + wps_js.getMetaBoxKey(key) + " .inside").removeAttr("style");
});

// Show Table information
var tbl = "<div class=\"title-center\">".concat(args.title, "</div><table width=\"100%\" class=\"o-table\"><tr><td class=\"wps-text-muted\">").concat(wps_js._('browser'), "</td><td class=\"wps-text-muted\">").concat(wps_js._('visitor_count'), "</td><td class=\"wps-text-muted\">").concat(wps_js._('percentage'), "</td></tr>");
for (var _i2 = 0; _i2 < args.browsers_name.length; _i2++) {
tbl += " <tr><td>".concat(args.browsers_name[_i2], "</td><td>").concat(parseInt(args.browsers_value[_i2]) > 0 ? "".concat(args.info.agent[_i2] !== "other" ? "<a href=\"" + args.info.visitor_page + "&agent=" + args.info.agent[_i2] + "&from=" + args.from + "&to=" + args.to + "\" target=\"_blank\">" : "", " ").concat(wps_js.number_format(args.browsers_value[_i2]), " ").concat(args.info.agent[_i2] !== "other" ? "</a>" : "") : args.browsers_value[_i2], "</td><td>").concat(wps_js.number_format(args.browsers_value[_i2] / args.total * 100), "%</td> </tr>");
}

// Set Total
tbl += " <tr><td>".concat(wps_js._('total'), "</td><td>").concat(wps_js.number_format(args.total), "</td><td></td></tr>");
tbl += "</table>";
jQuery("#" + wps_js.getMetaBoxKey('browsers-table') + " .inside").html(tbl);

// Set Equal Height
wps_js.set_equal_height('.postBox-table .inside', '.postBox-chart .inside');

// Add Extra Browser List Version
var html = '';
for (var _i3 = 0; _i3 < args.browsers_name.length; _i3++) {
if (parseInt(args.browsers_value[_i3]) > 0 && args.info.agent[_i3]) {
html += "<div class=\"wps-title-group\"><img src=\"".concat(args.info.logo[_i3], "\" alt=\"").concat(args.browsers_name[_i3], "\" style=\"vertical-align: -3px;\" class=\"wps-flag log-tools\"> ").concat(args.browsers_name[_i3], "</div><div class=\"wp-clearfix\"></div>");
html += wps_js.Create_Half_PostBox('postBox-chart-' + args.info.agent[_i3], 'browser-' + args.info.agent[_i3] + '-chart');
html += wps_js.Create_Half_PostBox('postBox-table-' + args.info.agent[_i3], 'browser-' + args.info.agent[_i3] + '-table');
html += "<div class=\"wp-clearfix\"></div>";
}
}

// Set Html in Page
jQuery(html).insertAfter("#browsers-table");

// Load function to Get Meta Box
for (var _i4 = 0; _i4 < args.browsers_name.length; _i4++) {
if (parseInt(args.browsers_value[_i4]) > 0 && args.info.agent[_i4]) {
this.run_custom_browser(args.info.agent[_i4]);
}
}
}
},
run_custom_browser: function run_custom_browser(agent) {
// Show Placeholder
['browser-' + agent + '-chart', 'browser-' + agent + '-table'].forEach(function (key) {
jQuery("#" + key + " .inside").css('height', '430px');
});
jQuery("#browser-" + agent + "-table .inside").html(wps_js.placeholder());
jQuery("#browser-" + agent + "-chart .inside").html(wps_js.circle_placeholder());
jQuery(".wps-ph-picture").attr("style", "height: 310px;");

//Prepare Params
var params = {
'name': 'browsers',
'browser': agent
};
['from', 'to'].forEach(function (key) {
if (wps_js.isset(wps_js.global, 'request_params', key)) {
params[key] = wps_js.global.request_params[key];
}
});

// Send Request
wps_js.ajaxQ(wps_js.global.meta_box_api, params, 'show_custom_agent', 'error_custom_agent', 'GET', false);
}
};

/**
 * Show Custom Browser Report
 *
 * @param args
 */
wps_js.show_custom_agent = function (args) {
// Get Browser Key
var BrowserKey = args.info.agent[0];

// Set Canvas Chart
jQuery('#browser-' + BrowserKey + '-chart .inside').html("<canvas id=\"" + wps_js.chart_id('browser-' + BrowserKey) + "\" height=\"220\"></canvas>");

// After Second Run Chart JS
setTimeout(function () {
// Get Background Color
var backgroundColor = [];
var color;
for (var i = 0; i <= 10; i++) {
color = wps_js.random_color(i);
backgroundColor.push('rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + '0.4)');
}

// Prepare Data
var data = [{
label: wps_js._('browsers'),
data: args['browsers_value'],
backgroundColor: backgroundColor
}];
var label_callback = function label_callback(tooltipItem) {
return tooltipItem.label;
};
var title_callback = function title_callback(ctx) {
return wps_js._('visitors') + ':' + ctx[0].formattedValue;
};
// Show Chart
wps_js.pie_chart(wps_js.chart_id('browser-' + BrowserKey), args['browsers_name'], data, label_callback, title_callback);

// Reset All Height
['browser-' + BrowserKey + '-chart', 'browser-' + BrowserKey + '-table'].forEach(function (key) {
jQuery("#" + key + " .inside").removeAttr("style");
});

// Show Table information
var tbl = "<div class=\"title-center\">".concat(args.title, "</div><table width=\"100%\" class=\"o-table\"><tr><td class=\"wps-text-muted\">").concat(wps_js._('version_list'), "</td><td class=\"wps-text-muted\">").concat(wps_js._('visitor_count'), "</td><td class=\"wps-text-muted\">").concat(wps_js._('percentage'), "</td></tr>");
for (var _i5 = 0; _i5 < args.browsers_name.length; _i5++) {
tbl += " <tr><td>".concat(args.browsers_name[_i5], "</td><td>").concat(parseInt(args.browsers_value[_i5]) > 0 ? wps_js.number_format(args.browsers_value[_i5]) : args.browsers_value[_i5], "</td><td>").concat(wps_js.number_format(args.browsers_value[_i5] / args.total * 100), "%</td></tr>");
}

// Set Total
tbl += " <tr><td>".concat(wps_js._('total'), "</td><td>").concat(wps_js.number_format(args.total), "</td><td></td></tr>");
tbl += "</table>";
var tbl_inside = "#browser-" + BrowserKey + "-table .inside";
jQuery(tbl_inside).html(tbl);

// Set Equal Height
wps_js.set_equal_height(tbl_inside, "#browser-" + BrowserKey + "-chart .inside");
}, 500);
};
wps_js.error_custom_agent = function (data) {
// Do Stuff
};
wps_js.countries_meta_box = {
view: function view() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
var t = '';
t += "<div class=\"o-table-wrapper\"><table width=\"100%\" class=\"o-table o-table--layout-fixed o-table--link table-stats wps-report-table\"><tbody><tr> <td>".concat(wps_js._('country'), "</td><td>").concat(wps_js._('visitor_count'), "</td></tr>");
var i = 1;
args.countries.forEach(function (value) {
t += "<tr> <td><img src=\"".concat(value['flag'], "\" title=\"").concat(value['name'], "\" alt=\"").concat(value['name'], "\" class=\"wps-flag wps-flag--first\"/> ").concat(value['name'], "</td><td><a href=\"").concat(value['link'], "\" title=\"").concat(value['name'], "\" target=\"_blank\">").concat(wps_js.number_format(value['number']), " <svg style=\"margin-top: 3px;\" width=\"10\" height=\"10\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.82751 4.99993 2.62209 2.79451c-.0759-.07859-.1179-.18384-.11695-.29309.00095-.10924.04477-.21375.12203-.291.07725-.07726.18176-.12108.291-.12203.10925-.00094.2145.04105.29309.11695l2.5 2.5c.07811.07814.12199.1841.12199.29459 0 .11048-.04388.21644-.12199.29458l-2.5 2.5c-.07859.0759-.18384.1179-.29309.11695-.10924-.00095-.21375-.04477-.291-.12203-.07726-.07725-.12108-.18176-.12203-.291-.00095-.10925.04105-.2145.11695-.29309l2.20542-2.20541Z\" fill=\"#404BF2\" fill-opacity=\".5\"/><path d=\"M7.87792 5.13371 5.67251 2.9283c-.0759-.07859-.1179-.18384-.11695-.29309.00095-.10924.04477-.21375.12202-.291.07726-.07726.18176-.12108.29101-.12203.10925-.00095.2145.04105.29308.11695l2.5 2.5c.07812.07814.122.1841.122.29458 0 .11049-.04388.21645-.122.29459l-2.5 2.5c-.07858.0759-.18383.11789-.29308.11695-.10925-.00095-.21375-.04477-.29101-.12203-.07725-.07725-.12107-.18176-.12202-.29101-.00095-.10924.04105-.2145.11695-.29308l2.20541-2.20542Z\" fill=\"#404BF2\"/> </svg></a></td></tr>");
i++;
});
t += "</tbody></table></div>";
return t;
}
};
wps_js.devices_meta_box = {
placeholder: function placeholder() {
return wps_js.circle_placeholder();
},
view: function view() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
// Create Html
var html = '';

// Add Chart
html += '<div class="o-wrap"><div class="c-chart c-chart--limited-height"><canvas id="' + wps_js.chart_id('devices') + '" height="220"></canvas></div></div>';

// show Data
return html;
},
meta_box_init: function meta_box_init() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
// Get Background Color
var backgroundColor = [];
var color;
for (var i = 0; i <= 20; i++) {
color = wps_js.random_color(i);
backgroundColor.push('rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + '0.4)');
}

// Prepare Data
var data = [{
label: wps_js._('device'),
data: args['device_value'],
backgroundColor: backgroundColor,
tension: 0.4
}];
var label_callback = function label_callback(tooltipItem) {
return tooltipItem.label;
};
var title_callback = function title_callback(ctx) {
return wps_js._('visitors') + ':' + ctx[0].formattedValue;
};

// Show Chart
wps_js.pie_chart(wps_js.chart_id('devices'), args['device_name'], data, label_callback, title_callback);
}
};
wps_js.exclusions_meta_box = {
placeholder: function placeholder() {
return wps_js.rectangle_placeholder();
},
view: function view() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
// Check Chart size in Different Page
var height = wps_js.is_active('overview_page') ? 110 : 210;
if (wps_js.isset(wps_js.global, 'request_params', 'page') && wps_js.global.request_params.page === "exclusions") {
height = 80;
}

// Create Html
var html = '';

// Add Chart
html += '<canvas id="' + wps_js.chart_id('exclusions') + '" height="' + height + '"></canvas>';

// show Data
return html;
},
meta_box_init: function meta_box_init() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
// Show chart
this.show_chart(wps_js.chart_id('exclusions'), args);

// Set Total For Hits Page
if (wps_js.isset(wps_js.global, 'request_params', 'page') && wps_js.global.request_params.page === "exclusions") {
var tag = "span[id='number-total-chart-exclusions']";
if (wps_js.exist_tag(tag)) {
var sum = wps_js.sum(Object.values(args.total));
jQuery(tag).html(wps_js.number_format(sum));
}
}
},
show_chart: function show_chart(tag_id) {
var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
// Prepare Chart Data
var html = '';
var datasets = [];
var i = 0;
Object.keys(args['exclusions']).forEach(function (key) {
// Check Has Item
var sum = wps_js.sum(Object.values(args['value'][key]));
if (sum > 0) {
// Push To Chart
var item_name = args['exclusions'][key];
var color = wps_js.random_color(i);
datasets.push({
label: item_name,
data: args['value'][key],
backgroundColor: 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + '0.3)',
borderColor: 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + '1)',
borderWidth: 1,
fill: true,
tension: 0.4
});

// Push to Table List
html += "<tr><th>".concat(item_name, "</th> <th class=\"th-center\"><span style=\"color: #9a9494 !important;\">").concat(wps_js.number_format(sum), "</span></th></tr>");
i++;
}
});
if (wps_js.exist_tag("table[data-table=exclusions]")) {
jQuery(html).insertAfter("table[data-table=exclusions] tr:first");
}
wps_js.line_chart(tag_id, args['title'], args['date'], datasets);
}
};
wps_js.hits_meta_box = {
placeholder: function placeholder() {
return wps_js.rectangle_placeholder();
},
view: function view() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
// Check Hit Chart size in Different Page
var height = wps_js.is_active('overview_page') ? 300 : 210;
if (wps_js.isset(wps_js.global, 'request_params', 'page') && wps_js.global.request_params.page === "hits") {
height = 80;
}

// Create Html
var html = '';

// // Check Show Button Group
// if (wps_js.is_active('overview_page')) {
// html += wps_js.btn_group_chart('hits', args);
// setTimeout(function(){ wps_js.date_picker(); }, 1000);
// }

// Add Chart
html += '<div class="o-wrap"><canvas id="' + wps_js.chart_id('hits') + '" height="' + height + '"></canvas></div>';

// show Data
return html;
},
meta_box_init: function meta_box_init() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
// Show chart
this.hits_chart(wps_js.chart_id('hits'), args);

// Set Total For Hits Page
if (wps_js.isset(wps_js.global, 'request_params', 'page') && wps_js.global.request_params.page === "hits") {
["visits", "visitors"].forEach(function (key) {
var tag = "span[id^='number-total-chart-" + key + "']";
if (wps_js.exist_tag(tag)) {
jQuery(tag).html(args.total[key]);
}
});
}
},
hits_chart: function hits_chart(tag_id) {
var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
// Check Hit-chart for Quick State
var params = args;
if ('hits-chart' in args) {
params = args['hits-chart'];
}

// Prepare Chart Data
var datasets = [];
if (wps_js.is_active('visitors')) {
datasets.push({
label: wps_js._('visitors'),
data: params['visitors'],
backgroundColor: 'rgba(255, 99, 132, 0.2)',
borderColor: 'rgba(255, 99, 132, 1)',
borderWidth: 1,
fill: true,
tension: 0.4
});
}
if (wps_js.is_active('visits')) {
datasets.push({
label: wps_js._('visits'),
data: params['visits'],
backgroundColor: 'rgba(54, 162, 235, 0.2)',
borderColor: 'rgba(54, 162, 235, 1)',
borderWidth: 1,
fill: true,
tension: 0.4
});
}

// Set Options for Chart only for overview page
var options = {};
if (wps_js.is_active('overview_page')) {
options = {
options: {
maintainAspectRatio: false,
interaction: {
intersect: false,
mode: 'index'
},
scales: {
y: {
ticks: {
stepSize: 1
}
}
}
}
};
}
wps_js.line_chart(tag_id, params['title'], params['date'], datasets, options);
}
};
wps_js.hitsmap_meta_box = {
placeholder: function placeholder() {
return wps_js.rectangle_placeholder();
},
view: function view() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
return "<div class=\"o-wrap\"><div id=\"wp-statistics-visitors-map\"></div></div>";
},
meta_box_init: function meta_box_init() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
var pin = Array();

// Prepare Country Pin
if (args.hasOwnProperty('country')) {
Object.keys(args['country']).forEach(function (key) {
var t = "<div class='map-html-marker'><div class=\"map-country-header\"><img src='".concat(args['country'][key]['flag'], "' alt=\"").concat(args['country'][key]['name'], "\" title='").concat(args['country'][key]['name'], "' class='log-tools wps-flag'/> ").concat(args['country'][key]['name'], " (").concat(args['total_country'][key], ")</div>");

// Get List visitors
Object.keys(args['visitor'][key]).forEach(function (visitor_id) {
t += "<p><img src='".concat(args['visitor'][key][visitor_id]['browser']['logo'], "' alt=\"").concat(args['visitor'][key][visitor_id]['browser']['name'], "\" class='wps-flag log-tools' title='").concat(args['visitor'][key][visitor_id]['browser']['name'], "'/> ").concat(args['visitor'][key][visitor_id]['ip'], " ") + (["Unknown", "(Unknown)"].includes(args['visitor'][key][visitor_id]['city']) ? '' : '- ' + args['visitor'][key][visitor_id]['city']) + "</p>";
});
t += "</div>";
pin[key] = t;
});
}

// Load Jquery Map
jQuery('#wp-statistics-visitors-map').vectorMap({
map: 'world_en',
backgroundColor: '#fff',
borderColor: '#7e7e7e',
borderOpacity: 0.60,
color: '#e6e5e2',
selectedColor: '#9DA3F7',
hoverColor: '#404BF2',
colors: args['color'],
onLabelShow: function onLabelShow(element, label, code) {
if (pin[code] !== undefined) {
label.html(pin[code]);
} else {
label.html(label.html() + ' [0]<hr />');
}
}
});
var widgetWrapper = jQuery("#wp-statistics-hitsmap-widget");
var sideSortable = jQuery("#side-sortables");
var normalSortable = jQuery("#normal-sortables");
var observerConfig = {
attributes: false,
childList: true,
characterData: false,
subtree: true
};
var observer = new MutationObserver(function (mutations) {
if (sideSortable.find(widgetWrapper).length || normalSortable.find(widgetWrapper).length) {
window.dispatchEvent(new Event('resize'));
}
});
observer.observe(document.getElementById('side-sortables'), observerConfig);
observer.observe(document.getElementById('normal-sortables'), observerConfig);
}
};
wps_js.models_meta_box = {
placeholder: function placeholder() {
return wps_js.circle_placeholder();
},
view: function view() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
// Create Html
var html = '';

// Add Chart
html += '<div class="o-wrap"><div class="c-chart c-chart--limited-height"><canvas id="' + wps_js.chart_id('models') + '" height="220"></canvas></div></div>';

// show Data
return html;
},
meta_box_init: function meta_box_init() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
// Get Background Color
var backgroundColor = [];
var color;
for (var i = 0; i <= 20; i++) {
color = wps_js.random_color(i);
backgroundColor.push('rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + '0.4)');
}

// Prepare Data
var data = [{
label: wps_js._('model'),
data: args['model_value'],
backgroundColor: backgroundColor,
tension: 0.4
}];
var label_callback = function label_callback(tooltipItem) {
return tooltipItem.label;
};
var title_callback = function title_callback(ctx) {
return wps_js._('visitors') + ':' + ctx[0].formattedValue;
};

// Show Chart
wps_js.pie_chart(wps_js.chart_id('models'), args['model_name'], data, label_callback, title_callback);
}
};
wps_js.pages_chart_meta_box = {
placeholder: function placeholder() {
return wps_js.rectangle_placeholder();
},
view: function view() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
return '<div class="o-wrap"><canvas id="' + wps_js.chart_id('pages-chart') + '" height="80"></canvas></div>';
},
meta_box_init: function meta_box_init() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
// Show chart
this.show_chart(wps_js.chart_id('pages-chart'), args);

// Set Total For Hits Page
if (wps_js.exist_tag("span[id=number-total-visits]")) {
jQuery("span[id=number-total-visits]").html(args.total);
}
if (wps_js.exist_tag("span[id=number-total-chart-visits]")) {
jQuery("span[id=number-total-chart-visits]").html(args.total_dates);
}
},
show_chart: function show_chart(tag_id) {
var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
wps_js.line_chart(tag_id, args['title'], args['date'], [{
label: wps_js._('visits'),
data: args['stat'],
backgroundColor: 'rgba(54, 162, 235, 0.2)',
borderColor: 'rgba(54, 162, 235, 1)',
borderWidth: 1,
fill: true,
tension: 0.4
}]);
}
};
wps_js.pages_meta_box = {
view: function view() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
var t = '';
t += "<div class=\"o-table-wrapper\"><table width=\"100%\" class=\"o-table o-table--pages o-table--layout-fixed\"><tbody><tr><th colspan=\"6\">".concat(wps_js._('title'), "</th><th width=\"10%\">").concat(wps_js._('visits'), "</th></tr>");
var siteUrl = wps_js.global.admin_url.replace('/wp-admin/', '');
var i = 1;
args.pages.forEach(function (value) {
t += "<tr><td colspan=\"6\"><a href=\"".concat(siteUrl).concat(value['str_url'], "\" title=\"").concat(value['title'], "\" class='wps-text-wrap' target=\"_blank\">").concat(value['title'], " <span class=\"dashicons dashicons-external\" style=\"font-size: 15px; vertical-align: middle\"></span></a></td><td><a style=\"justify-content: flex-end;\" href=\"").concat(value['hits_page'], "\">").concat(value['number'], " <svg style=\"margin-top: 3px;\" width=\"10\" height=\"10\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.82751 4.99993 2.62209 2.79451c-.0759-.07859-.1179-.18384-.11695-.29309.00095-.10924.04477-.21375.12203-.291.07725-.07726.18176-.12108.291-.12203.10925-.00094.2145.04105.29309.11695l2.5 2.5c.07811.07814.12199.1841.12199.29459 0 .11048-.04388.21644-.12199.29458l-2.5 2.5c-.07859.0759-.18384.1179-.29309.11695-.10924-.00095-.21375-.04477-.291-.12203-.07726-.07725-.12108-.18176-.12203-.291-.00095-.10925.04105-.2145.11695-.29309l2.20542-2.20541Z\" fill=\"#404BF2\" fill-opacity=\".5\"/><path d=\"M7.87792 5.13371 5.67251 2.9283c-.0759-.07859-.1179-.18384-.11695-.29309.00095-.10924.04477-.21375.12202-.291.07726-.07726.18176-.12108.29101-.12203.10925-.00095.2145.04105.29308.11695l2.5 2.5c.07812.07814.122.1841.122.29458 0 .11049-.04388.21645-.122.29459l-2.5 2.5c-.07858.0759-.18383.11789-.29308.11695-.10925-.00095-.21375-.04477-.29101-.12203-.07725-.07725-.12107-.18176-.12202-.29101-.00095-.10924.04105-.2145.11695-.29308l2.20541-2.20542Z\" fill=\"#404BF2\"/> </svg> </a></td></tr>");
i++;
});
t += "</tbody></table></div>";
return t;
}
};
wps_js.platforms_meta_box = {
placeholder: function placeholder() {
return wps_js.circle_placeholder();
},
view: function view() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
// Create Html
var html = '';

// Check Show Button Group
// if (wps_js.is_active('overview_page')) {
// html += wps_js.btn_group_chart('platforms', args);
// setTimeout(function () {
// wps_js.date_picker();
// }, 1000);
// }

// Add Chart
html += '<div class="o-wrap"><div class="c-chart c-chart--limited-height"><canvas id="' + wps_js.chart_id('platforms') + '" height="220"></canvas></div></div>';

// show Data
return html;
},
meta_box_init: function meta_box_init() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
// Get Background Color
var backgroundColor = [];
var color;
for (var i = 0; i <= 20; i++) {
color = wps_js.random_color(i);
backgroundColor.push('rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + '0.4)');
}

// Prepare Data
var data = [{
label: wps_js._('platform'),
data: args['platform_value'],
backgroundColor: backgroundColor,
tension: 0.4
}];
var label_callback = function label_callback(tooltipItem) {
return tooltipItem.label;
};
var title_callback = function title_callback(ctx) {
return wps_js._('visitors') + ':' + ctx[0].formattedValue;
};

// Show Chart
wps_js.pie_chart(wps_js.chart_id('platforms'), args['platform_name'], data, label_callback, title_callback);

// Check Table information
if (wps_js.exist_tag('#' + wps_js.getMetaBoxKey('platforms-table'))) {
// Reset All Height
['platforms-table', 'platforms'].forEach(function (key) {
jQuery("#" + wps_js.getMetaBoxKey(key) + " .inside").removeAttr("style");
});

// Show Table information
var tbl = "<div class=\"title-center\">".concat(args.title, "</div><table width=\"100%\" class=\"o-table\"><tr><td class=\"wps-text-muted\">").concat(wps_js._('platform'), "</td><td class=\"wps-text-muted\">").concat(wps_js._('visitor_count'), "</td><td class=\"wps-text-muted\">").concat(wps_js._('percentage'), "</td></tr>");
for (var _i6 = 0; _i6 < args.platform_name.length; _i6++) {
tbl += " <tr><td>".concat(args.platform_name[_i6], "</td><td>").concat(parseInt(args.platform_value[_i6]) > 0 ? "<a href=\"" + args.info.visitor_page + "&platform=" + args.platform_name[_i6] + "&from=" + args.from + "&to=" + args.to + "\" target=\"_blank\"> ".concat(wps_js.number_format(args.platform_value[_i6]), " </a>") : wps_js.number_format(args.platform_value[_i6]), "</td><td>").concat(wps_js.number_format(args.platform_value[_i6] / args.total * 100), "%</td> </tr>");
}

// Set Total
tbl += " <tr><td>".concat(wps_js._('total'), "</td><td>").concat(wps_js.number_format(args.total), "</td><td></td></tr>");
tbl += "</table>";
jQuery("#" + wps_js.getMetaBoxKey('platforms-table') + " .inside").html(tbl);

// Set Equal Height
wps_js.set_equal_height('.postBox-table .inside', '.postBox-chart .inside');
}
}
};
wps_js.post_meta_box = {
params: function params() {
return {
'ID': wps_js.global['page']['ID']
};
},
view: function view() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
return args.hasOwnProperty('content') ? ' <div class="wps-center" style="padding: 15px;"> ' + args['content'] + '</div>' : '<canvas id="' + wps_js.chart_id('post') + '" height="85"></canvas>' + '<div class="wps-wrap wps-meta-box-footer">' + args['visitors'] + '</div>';
},
meta_box_init: function meta_box_init() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
if (!args.hasOwnProperty('content')) {
this.post_hits_chart(wps_js.chart_id('post'), args);
} else {
jQuery("#" + wps_js.getMetaBoxKey('post') + " button[onclick]").remove();
}
},
post_hits_chart: function post_hits_chart(tag_id) {
var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
wps_js.line_chart(tag_id, args['title'], args['date'], [{
label: args['post_title'],
data: args['state'],
backgroundColor: 'rgba(255, 99, 132, 0.2)',
borderColor: 'rgba(255, 99, 132, 1)',
borderWidth: 1,
fill: true,
tension: 0.4
}]);
}
};
wps_js.quickstats_meta_box = {
view: function view() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
var t = '';
t += wps_js.summary_meta_box.user_online(args);
t += "<div class=\"o-table-wrapper\"><table width=\"100%\" class=\"o-table\"><tbody>";

//Summary Statistics
t += wps_js.summary_meta_box.summary_statistics(args);
t += "</tbody></table></div>";
t += "<br><hr width=\"80%\"/><br>";

// Show Chart JS
t += "<canvas id=\"" + wps_js.chart_id('quickstats') + "\" height=\"210\"></canvas>";
return t;
},
meta_box_init: function meta_box_init() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
wps_js.hits_meta_box.hits_chart(wps_js.chart_id('quickstats'), args);
}
};
wps_js.recent_meta_box = {
view: function view() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
var t = '';
t += "<div class=\"o-table-wrapper\">";
t += "<table width=\"100%\" class=\"o-table o-table--visitors\"><thead><tr><th>".concat(wps_js._('browser'), "</th>") + (wps_js.is_active('geo_ip') ? "<th>".concat(wps_js._('country'), "</th>") : "") + "" + (wps_js.is_active('geo_city') ? "<th>".concat(wps_js._('city'), "</th>") : "") + "<th>".concat(wps_js._('date'), "</th><th class=\"o-table__td--sm-width\">").concat(wps_js._('hits'), "</th><th class=\"o-table__link\">").concat(wps_js._('ip'), "</th><th>").concat(wps_js._('referrer'), "</th></tr></thead><tbody>");
args.forEach(function (value, index) {
t += "<tr><td><a class=\"is-normal-text\" href=\"".concat(value['browser']['link'], "\" title=\"").concat(value['browser']['name'], "\"><img src=\"").concat(value['browser']['logo'], "\" alt=\"").concat(value['browser']['name'], "\" class='wps-flag log-tools' title='").concat(value['browser']['name'], "'/> ").concat(value['browser']['name'], "</a></td>") + (wps_js.is_active('geo_ip') ? "<td><img src='".concat(value['country']['flag'], "' alt='").concat(value['country']['name'], "' title='").concat(value['country']['name'], "' class='wps-flag'/> ").concat(value['country']['name'], "</td>") : "") + "" + (wps_js.is_active('geo_city') ? "<td>".concat(value['city'], "</td>") : "") + "<td>".concat(value['date'], "</td><td class=\"o-table__td--sm-width\">").concat(value['hits'], "</td><td class=\"o-table__link o-table__ip\">") + (value['hash_ip'] ? value['hash_ip'] : "<a href='".concat(value['ip']['link'], "'>").concat(value['ip']['value'], "</a>")) + "</td><td class=\"o-table__referred\">".concat(value['referred'], "</td></tr>");
});
t += "</tbody></table>";
t += "</div>";
return t;
}
};
wps_js.referring_meta_box = {
view: function view() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
var t = '<div class="o-table-wrapper">';
t += "<table width=\"100%\" class=\"o-table o-table--link o-table--space-between\"><thead><tr><th>".concat(wps_js._('address'), "</th><th>").concat(wps_js.meta_box_lang('referring', 'references'), "</th></tr></thead><tbody>");
args.referring.forEach(function (value) {
t += "<tr><td>" + wps_js.site_icon(value['domain']) + " <a href='//".concat(value['domain'], "' title='").concat(value['title'], "' target=\"_blank\">").concat(value['domain'], " <span class=\"dashicons dashicons-external\" style=\"font-size: 15px; vertical-align: middle\"></span></a></td><td class=\"wps-middle-vertical\"><a style=\"justify-content: flex-end;\" href=\"").concat(value['page_link'], "\">").concat(value['number'], " <svg style=\"margin-top: 3px;\" width=\"10\" height=\"10\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.82751 4.99993 2.62209 2.79451c-.0759-.07859-.1179-.18384-.11695-.29309.00095-.10924.04477-.21375.12203-.291.07725-.07726.18176-.12108.291-.12203.10925-.00094.2145.04105.29309.11695l2.5 2.5c.07811.07814.12199.1841.12199.29459 0 .11048-.04388.21644-.12199.29458l-2.5 2.5c-.07859.0759-.18384.1179-.29309.11695-.10924-.00095-.21375-.04477-.291-.12203-.07726-.07725-.12108-.18176-.12203-.291-.00095-.10925.04105-.2145.11695-.29309l2.20542-2.20541Z\" fill=\"#404BF2\" fill-opacity=\".5\"/><path d=\"M7.87792 5.13371 5.67251 2.9283c-.0759-.07859-.1179-.18384-.11695-.29309.00095-.10924.04477-.21375.12202-.291.07726-.07726.18176-.12108.29101-.12203.10925-.00095.2145.04105.29308.11695l2.5 2.5c.07812.07814.122.1841.122.29458 0 .11049-.04388.21645-.122.29459l-2.5 2.5c-.07858.0759-.18383.11789-.29308.11695-.10925-.00095-.21375-.04477-.29101-.12203-.07725-.07725-.12107-.18176-.12202-.29101-.00095-.10924.04105-.2145.11695-.29308l2.20541-2.20542Z\" fill=\"#404BF2\"/> </svg></a></td></tr>");
});
t += "</tbody></table></div>";
return t;
}
};
wps_js.search_meta_box = {
placeholder: function placeholder() {
return wps_js.rectangle_placeholder();
},
view: function view() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
// Check Hit Chart size in Different Page
var height = wps_js.is_active('overview_page') ? 300 : 210;
if (wps_js.isset(wps_js.global, 'request_params', 'page') && wps_js.global.request_params.page === "searches") {
height = 300;
}

// Create Html
var html = '';

// Add Chart
html += '<div class="o-wrap"><canvas id="' + wps_js.chart_id('search') + '" height="' + height + '"></canvas></div>';

// show Data
return html;
},
meta_box_init: function meta_box_init() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
// Prepare Chart Data
var datasets = [];
var i = 0;
Object.keys(args['search-engine']).forEach(function (key) {
var search_engine_name = args['search-engine'][key]['name'];
var color = wps_js.random_color(i);
datasets.push({
label: search_engine_name,
data: args['stat'][search_engine_name],
backgroundColor: 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + '0.3)',
borderColor: 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + '1)',
borderWidth: 1,
fill: true,
tension: 0.4
});
i++;
});

// Set Total
if (args['total']['active'] === 1) {
datasets.push({
label: wps_js._('total'),
data: args['total']['stat'],
backgroundColor: 'rgba(' + args['total']['color'] + ', 0.2)',
borderColor: 'rgba(' + args['total']['color'] + ', 1)',
borderWidth: 1,
fill: true,
tension: 0.4
});
}
wps_js.line_chart(wps_js.chart_id('search'), args['title'], args['date'], datasets, {
options: {
maintainAspectRatio: false,
interaction: {
intersect: false,
mode: 'index'
},
scales: {
y: {
ticks: {
stepSize: 1
}
}
}
}
});
}
};
wps_js.summary_meta_box = {
summary_statistics: function summary_statistics() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
var t = '<thead>';

// Show Visitor Online
// -- Moved to bottom

// Show Visitors and Visits
if (wps_js.is_active('visitors') || wps_js.is_active('visits')) {
t += "<tr><th width=\"50%\">" + wps_js._('time') + "</th>";
["visitors", "visits"].forEach(function (key) {
t += "<th>" + (wps_js.is_active(key) ? wps_js._(key) : "") + "</th>";
});
t += "</tr>";
t += '</thead>';
t += '<tbody>';
if (Object.keys(args).length) {
// Show Statistics in Days
var summary_item = ["today", "yesterday", "last-week", "week", "month", "60days", "90days", "year", "this-year", "last-year", "total"];
var _loop = function _loop(i) {
t += "<tr><td><b>".concat(wps_js._(summary_item[i]), "</b></td>");
["visitors", "visits"].forEach(function (key) {
if (typeof args[key] === 'undefined') {
t += "<td></td>";
} else {
t += "<td>" + (wps_js.is_active(key) ? "<a href=\"".concat(args[key][summary_item[i]]['link'], "\"><span class=\"quickstats-values\">").concat(args[key][summary_item[i]]['value'], "</span></a>") : "") + "</td>";
}
});
t += "</tr>";
};
for (var i = 0; i < summary_item.length; i++) {
_loop(i);
}
t += '</tbody>';
}
}
return t;
},
user_online: function user_online() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
var t = '';
if (args['user_online']) {
t = "<div class=\"c-live\"><div><span class=\"c-live__status\"></span> <span class=\"c-live__title\">".concat(wps_js._('online_users'), ":</span><span><a class=\"c-live__value\" href=\"").concat(args['user_online']['link'], "\">").concat(args['user_online']['value'], "</a></span></div>");
if (args['real_time_button']) {
t += "<a target=\"_blank\" class=\"".concat(args['real_time_button']['class'], "\" href=\"").concat(args['real_time_button']['link'], "\" title=\"").concat(args['real_time_button']['title'], "\">").concat(wps_js._('Realtime'), " </a>");
}
t += "</div>";
}
return t;
},
view: function view() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
var t = '';
t += this.user_online(args);
t += "<div class=\"o-table-wrapper\"><table width=\"100%\" class=\"o-table o-table--wps-summary-stats\">";

// Summary Statistics
t += this.summary_statistics(args);
t += "</table></div>";
return t;
}
};
wps_js.top_pages_chart_meta_box = {
placeholder: function placeholder() {
return wps_js.rectangle_placeholder();
},
view: function view() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
// Create Html
var html = '';

// Check Show Button Group
//html += wps_js.btn_group_chart('top-pages-chart', args);
setTimeout(function () {
wps_js.date_picker();
}, 1000);

// Add Chart
html += '<div class="o-wrap"><canvas id="' + wps_js.chart_id('top-pages-chart') + '" height="80"></canvas></div>';

// show Data
return html;
},
meta_box_init: function meta_box_init() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
this.top_pages_chart(wps_js.chart_id('top-pages-chart'), args);
},
top_pages_chart: function top_pages_chart(tag_id) {
var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
// Prepare Chart Data
var datasets = [];
var i = 0;
Object.keys(args['stat']).forEach(function (key) {
var color = wps_js.random_color(i);
datasets.push({
label: key,
data: args['stat'][key],
backgroundColor: 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + '0.3)',
borderColor: 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + '1)',
borderWidth: 1,
fill: true,
tension: 0.4
});
i++;
});
wps_js.line_chart(tag_id, args['title'], args['date'], datasets);
}
};
wps_js.top_visitors_meta_box = {
view: function view() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
var t = '';
t += "<div class=\"o-table-wrapper\">";
t += "<table width=\"100%\" class=\"o-table o-table--responsive\"><tbody><tr>" + (wps_js.is_active('geo_ip') ? "<td>".concat(wps_js._('country'), "</td>") : "") + "" + (wps_js.is_active('geo_city') ? "<td>".concat(wps_js._('city'), "</td>") : "") + "<td>".concat(wps_js._('ip'), "</td><td>").concat(wps_js._('browser'), "</td><td>").concat(wps_js._('platform'), "</td><td>").concat(wps_js._('version'), "</td><td class=\"o-table__td--sm-width\">").concat(wps_js._('hits'), "</td></tr>");
var i = 1;
args.forEach(function (value) {
t += "<tr>" + (wps_js.is_active('geo_ip') ? "<td><img src='".concat(value['country']['flag'], "' alt='").concat(value['country']['name'], "' title='").concat(value['country']['name'], "' class='log-tools wps-flag'/> ").concat(value['country']['name'], "</td>") : "") + "" + (wps_js.is_active('geo_city') ? "<td>".concat(value['city'], "</td>") : "") + "<td class=\"wps-admin-column__ip\">" + (value['hash_ip'] ? value['hash_ip'] : "<a href='".concat(value['ip']['link'], "'>").concat(value['ip']['value'], "</a>")) + "</td><td><a class=\"is-normal-text\" href=\"".concat(value['browser']['link'], "\" title=\"").concat(value['browser']['name'], "\"><img src=\"").concat(value['browser']['logo'], "\" alt=\"").concat(value['browser']['name'], "\" class='wps-flag log-tools' title='").concat(value['browser']['name'], "'/> ").concat(value['browser']['name'], "</a></td><td>").concat(value['platform'], "</td><td>").concat(value['version'], "</td><td class=\"o-table__td--sm-width\">").concat(value['hits'], "</td></tr>");
i++;
});
t += "</tbody></table>";
t += "</div>";
return t;
}
};
wps_js.useronline_meta_box = {
view: function view() {
var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
var t = '<div class="o-table-wrapper">';
t += "<table class=\"o-table o-table--visitors\"><tr><td>".concat(wps_js._('page'), "</td><td>").concat(wps_js._('referrer'), "</td>") + (wps_js.is_active('geo_ip') ? "<td>".concat(wps_js._('country'), "</td>") : "") + "<td>".concat(wps_js._('ip'), "</td><td>").concat(wps_js._('user'), "</td></tr>");
args.forEach(function (value) {
t += "<tr><td><span class=\"wps-text-wrap\">" + (value['page']['link'].length > 2 ? "<a href=\"".concat(value['page']['link'], "\" title=\"").concat(value['page']['title'], "\" target=\"_blank\" class=\"wps-text-muted is-normal-text\">") : "") + value['page']['title'] + (value['page']['link'].length > 2 ? "</a>" : "") + "</span></td><td><div class=\"table-cell-scroller\">".concat(value['referred'], "</div></td>") + (wps_js.is_active('geo_ip') ? "<td><img src='".concat(value['country']['flag'], "' alt='").concat(value['country']['name'], "' class='wps-flag wps-flag--first'/> ").concat(value['country']['name'], "</td>") : "") + "<td><a href='" + (value['hash_ip'] ? '#' : value['ip']['link']) + "'>" + (value['hash_ip'] ? value['hash_ip'] : value['ip']['value']) + "</a></td>" + (typeof value['user'] != 'undefined' ? "<td><a href='" + wps_js.global.admin_url + "user-edit.php?user_id=" + value['user']['ID'] + "'>" + value['user']['name'] + " (ID: #" + value['user']['ID'] + ")</a></td>" : "<td>-</td>") + "</tr>";
});
t += "</table></div>";
return t;
}
};
if (wps_js.isset(wps_js.global, 'request_params', 'page') && wps_js.global.request_params.page === "author-analytics") {
var wpStatisticsAuthorAnalytics = {
init: function init() {
if (typeof Wp_Statistics_Author_Analytics_Object == "undefined") {
console.log('Variable Wp_Statistics_Author_Analytics_Object not found.');
return;
}
this.generateCharts();
},
generateCharts: function generateCharts() {
this.generatePublishingOverviewChart();
this.generateViewsPerPostsChart();
this.generateOperatingSystemChart();
this.generateBrowsersChartData();
},
generateBrowsersChartData: function generateBrowsersChartData() {
if (!wps_js.isset(Wp_Statistics_Author_Analytics_Object, 'browser_chart_data')) {
return;
}
var chartData = Wp_Statistics_Author_Analytics_Object.browser_chart_data;
if (chartData.data.length == 0) {
jQuery('#wps-browsers').parent().text(wps_js._('no_result'));
jQuery('#wps-browsers').remove();
return;
}
var browsersData = {
labels: chartData.labels,
datasets: [{
data: chartData.data,
backgroundColor: ['#F7D399', '#99D3FB', '#D7BDE2', '#D7BDE2', '#EBA39B', '#F5CBA7'],
borderColor: '#fff',
borderWidth: 1
}]
};
var browsersOptions = {
responsive: true,
plugins: {
legend: {
position: 'top',
hidden: false,
labels: {
padding: 13,
fontSize: 13,
color: '#56585A',
usePointStyle: true,
pointStyle: 'rect',
pointRadius: 2
}
}
}
};
var browsersCtx = document.getElementById('wps-browsers').getContext('2d');
var browsersChart = new Chart(browsersCtx, {
type: 'pie',
data: browsersData,
options: browsersOptions
});
},
generateOperatingSystemChart: function generateOperatingSystemChart() {
if (!wps_js.isset(Wp_Statistics_Author_Analytics_Object, 'os_chart_data')) {
return;
}
var chartData = Wp_Statistics_Author_Analytics_Object.os_chart_data;
if (chartData.labels.length == 0 || chartData.data.length == 0) {
jQuery('#wps-operating-systems').parent().text(wps_js._('no_result'));
jQuery('#wps-operating-systems').remove();
return;
}
var operatingSystemsData = {
labels: chartData.labels,
datasets: [{
data: chartData.data,
backgroundColor: ['#F7D399', '#99D3FB', '#D7BDE2', '#D7BDE2', '#EBA39B', '#F5CBA7'],
borderColor: '#fff',
borderWidth: 1
}]
};
var operatingSystemsOptions = {
responsive: true,
plugins: {
legend: {
position: 'top',
hidden: false,
labels: {
padding: 13,
fontSize: 13,
color: '#56585A',
usePointStyle: true,
pointStyle: 'rect',
pointRadius: 2
}
}
}
};
var operatingSystemsCtx = document.getElementById('wps-operating-systems').getContext('2d');
var operatingSystemsChart = new Chart(operatingSystemsCtx, {
type: 'pie',
data: operatingSystemsData,
options: operatingSystemsOptions
});
},
generateViewsPerPostsChart: function generateViewsPerPostsChart() {
if (!wps_js.isset(Wp_Statistics_Author_Analytics_Object, 'views_per_posts_chart_data')) {
return;
}
var publishedChartData = Wp_Statistics_Author_Analytics_Object.views_per_posts_chart_data;
var chartImageUrls = publishedChartData.data.map(function (point) {
return point.img;
});
var chartImages = chartImageUrls.map(function (url) {
var img = new Image();
img.src = url;
return img;
});
var afterRenderPlugin = {
id: 'afterRenderPlugin',
afterDraw: function afterDraw(chart, args, options) {
var canvas = document.getElementById('publishedChart');
var ctx = canvas.getContext('2d');
chart.data.datasets.forEach(function (dataset, datasetIndex) {
dataset.data.forEach(function (point, index) {
var img = chartImages[index % chartImages.length];
var x = chart.scales.x.getPixelForValue(point.x);
var y = chart.scales.y.getPixelForValue(point.y);
var radius = 15;
var borderWidth = 2; // Adjust border width
var centerX = x - radius;
var centerY = y - radius;

// Draw border circle
ctx.beginPath();
ctx.arc(x, y, radius + borderWidth, 0, 2 * Math.PI);
ctx.lineWidth = borderWidth * 2;
ctx.strokeStyle = 'rgba(81,0,253,20%)';
ctx.stroke();
ctx.closePath();

// Clip to the circle
ctx.save();
ctx.beginPath();
ctx.arc(x, y, radius, 0, 2 * Math.PI);
ctx.clip();

// Draw image
ctx.drawImage(img, centerX, centerY, radius * 2, radius * 2);
ctx.restore();
});
});
}
};
Chart.register(afterRenderPlugin);
Chart.Tooltip.positioners.top = function (element, eventPosition) {
var tooltip = this;
var _this$chart = this.chart,
bottom = _this$chart.chartArea.bottom,
_this$chart$scales = _this$chart.scales,
x = _this$chart$scales.x,
y = _this$chart$scales.y;
return {
x: x.getPixelForValue(x.getValueForPixel(eventPosition.x)),
y: y.getPixelForValue(y.getValueForPixel(eventPosition.y)) - 20,
xAlign: 'center',
yAlign: 'bottom'
};
};
var publishedData = {
datasets: [{
label: publishedChartData.chartLabel,
data: publishedChartData.data,
backgroundColor: '#E8EAEE'
}]
};
var publishedConfig = {
type: 'scatter',
data: publishedData,
options: {
responsive: true,
pointRadius: 16,
pointHoverRadius: 16,
tooltipPosition: {
x: 10,
y: 30
},
layout: {
padding: {
Right: 20,
Left: 20
}
},
scales: {
y: {
type: 'linear',
ticks: {
stepSize: 4,
color: '#56585A',
fontSize: 13,
padding: 15
},
title: {
display: true,
text: publishedChartData.yAxisLabel,
fontSize: 14,
color: '#000'
},
grid: {
drawBorder: false,
tickLength: 0
}
},
x: {
type: 'linear',
position: 'bottom',
title: {
display: true,
text: publishedChartData.xAxisLabel,
fontSize: 14,
color: '#000'
},
ticks: {
stepSize: 50000,
autoSkip: false,
maxRotation: 90,
minRotation: 90,
color: '#56585A',
padding: 15,
fontSize: 13
},
grid: {
drawBorder: false,
tickLength: 0
}
}
},
plugins: {
legend: {
display: false
},
tooltip: {
position: 'top',
callbacks: {
label: function label(context) {
var point = context.raw;
return ["".concat(wps_js._('visits'), "/").concat(wps_js._('published'), ": (").concat(point.x, ", ").concat(point.y, ")"), "".concat(wps_js._('author'), ": ").concat(point.author)];
}
}
}
}
},
plugins: [afterRenderPlugin]
};
new Chart(document.getElementById('publishedChart'), publishedConfig);
},
generatePublishingOverviewChart: function generatePublishingOverviewChart() {
if (!wps_js.isset(Wp_Statistics_Author_Analytics_Object, 'publish_chart_data')) {
return;
}
function interpolateColor(minColor, maxColor, minValue, maxValue, value) {
var colors = ['#B28DFF', '#5100FD', '#4915B9', '#250766']; // Colors array
var index = Math.floor((value - minValue) / (maxValue - minValue) * (colors.length - 1));
var clampedIndex = Math.min(Math.max(index, 0), colors.length - 1);
return colors[clampedIndex];
}
var _backgroundColor = function backgroundColor(c) {
var value = c.dataset.data[c.dataIndex].v;
var minValue = Math.min.apply(Math, _toConsumableArray(c.dataset.data.map(function (data) {
return data.v;
})));
var maxValue = Math.max.apply(Math, _toConsumableArray(c.dataset.data.map(function (data) {
return data.v;
})));
if (value === 0) {
return '#e8eaee';
}
var interpolatedColor = interpolateColor('#B28DFF', '#250766', minValue, maxValue, value);
return interpolatedColor;
};
var overviewPublishData = {
datasets: [{
label: 'overview',
data: Wp_Statistics_Author_Analytics_Object.publish_chart_data,
backgroundColor: function backgroundColor(c) {
return _backgroundColor(c);
},
borderColor: 'transparent',
borderWidth: 4,
borderRadius: 2,
boxShadow: 0,
width: function width(c) {
var a = c.chart.chartArea || {};
return (a.right - a.left) / 53 - 1 - 2;
},
height: function height(c) {
var a = c.chart.chartArea || {};
return (a.bottom - a.top) / 7 - 1 - 1;
}
}]
};

//scales
var overviewPublishScales = {
y: {
type: 'time',
offset: true,
time: {
unit: 'day',
round: 'day',
isoWeek: 1,
parser: 'i',
displayFormats: {
day: 'iiiiii'
}
},
reverse: true,
position: 'left',
ticks: {
maxRotation: 0,
autoSkip: true,
padding: 5,
color: '#000',
font: {
size: 12
}
},
grid: {
display: false,
drawBorder: false,
tickLength: 0
},
border: {
display: false
}
},
x: {
type: 'time',
offset: true,
position: 'top',
time: {
unit: 'month',
round: 'week',
isoWeekday: 1,
displayFormats: {
week: 'MMM'
}
},
ticks: {
maxRotation: 0,
autoSkip: true,
padding: 5,
color: '#000000',
font: {
size: 12
},
callback: function callback(value, index, values) {
var date = new Date(value);
var month = date.toLocaleString('default', {
month: 'short'
});
var day = date.getDate();
return day === 1 ? month : month + ' ' + day;
}
},
border: {
display: false
},
grid: {
display: false,
drawBorder: false,
tickLength: 0
}
}
};
var overviewPublishConfig = {
type: 'matrix',
data: overviewPublishData,
options: {
maintainAspectRatio: false,
scales: overviewPublishScales,
aspectRatio: 10,
animation: false,
plugins: {
chartAreaBorder: {
borderWidth: 5,
borderColor: '#fff'
},
legend: false,
tooltip: {
displayColors: false,
callbacks: {
title: function title() {
return '';
},
label: function label(context) {
var v = context.dataset.data[context.dataIndex];
return ["".concat(wps_js._('date'), ": ").concat(v.d), "".concat(wps_js.global.active_post_type, ": ").concat(v.v)];
}
}
}
}
}
};
new Chart(document.getElementById('overviewPublishChart'), overviewPublishConfig);
}
};
jQuery(document).ready(function () {
wpStatisticsAuthorAnalytics.init();
});
}
if (wps_js.isset(wps_js.global, 'request_params', 'page') && wps_js.global.request_params.page === "browser") {
// Check Pagination
var params = {};

// Check Extra Parameter [Days ago or Between ..]
['from', 'to'].forEach(function (key) {
if (wps_js.isset(wps_js.global, 'request_params', key)) {
params[key] = wps_js.global.request_params[key];
}
});

// Set Equal Height
['browsers-table', 'browsers'].forEach(function (key) {
jQuery("#" + wps_js.getMetaBoxKey(key) + " .inside").css('height', '430px');
});

// Set Loading Table-List
jQuery("#wp-statistics-browsers-table-widget .inside").html(wps_js.placeholder());
jQuery(".wps-ph-picture").attr("style", "height: 310px;");

// Run Browsers Meta Box
wps_js.run_meta_box('browsers', params, false);
}
if (wps_js.isset(wps_js.global, 'request_params', 'page') && wps_js.global.request_params.page === "countries") {
// Check Params
var _params = {
'limit': 0
};

// Check Extra Parameter [Days ago or Between ..]
['from', 'to'].forEach(function (key) {
if (wps_js.isset(wps_js.global, 'request_params', key)) {
_params[key] = wps_js.global.request_params[key];
}
});

// Run Pages list MetaBox
wps_js.run_meta_box('countries', _params, false);
}
if (wps_js.isset(wps_js.global, 'request_params', 'page') && wps_js.global.request_params.page === "exclusions") {
// Create Params
var _params2;

// Check Days ago or Between
if (wps_js.isset(wps_js.global, 'request_params', 'from') && wps_js.isset(wps_js.global, 'request_params', 'to')) {
_params2 = {
'from': wps_js.global.request_params.from,
'to': wps_js.global.request_params.to
};
} else {
_params2 = {
'ago': 30
};
}

// Set PlaceHolder For Total
jQuery("span[id^='number-total-chart-']").html(wps_js.rectangle_placeholder('wps-text-placeholder'));

// Run MetaBox
wps_js.run_meta_box('exclusions', _params2, false);
}
if (wps_js.isset(wps_js.global, 'request_params', 'page') && wps_js.global.request_params.page === "hits") {
// Create Params
var _params3 = {};

// Check Days ago or Between
if (wps_js.isset(wps_js.global, 'request_params', 'from') && wps_js.isset(wps_js.global, 'request_params', 'to')) {
_params3 = {
'from': wps_js.global.request_params.from,
'to': wps_js.global.request_params.to
};
} else {
_params3 = {
'ago': 30
};
}

// Set PlaceHolder For Total
jQuery("span[id^='number-total-chart-']").html(wps_js.rectangle_placeholder('wps-text-placeholder'));

// Run MetaBox
wps_js.run_meta_box('hits', _params3, false);
}
if (wps_js.isset(wps_js.global, 'request_params', 'page') && wps_js.global.request_params.page === "overview") {
// Add Click Close Donate Notice
jQuery('#wps-donate-notice').on('click', '.notice-dismiss', function () {
jQuery.ajax({
url: wps_js.global.admin_url + 'admin-ajax.php',
type: 'get',
data: {
'action': 'wp_statistics_close_notice',
'notice': 'donate',
'wps_nonce': '' + wps_js.global.rest_api_nonce + ''
},
datatype: 'json'
});
});
}
if (wps_js.isset(wps_js.global, 'request_params', 'page') && wps_js.global.request_params.page === "pages") {
// Check has Custom Page
if (wps_js.isset(wps_js.global, 'request_params', 'ID') && wps_js.isset(wps_js.global, 'request_params', 'type')) {
// Create Params
var _params4;

// Check Days ago or Between
if (wps_js.isset(wps_js.global, 'request_params', 'from') && wps_js.isset(wps_js.global, 'request_params', 'to')) {
_params4 = {
'from': wps_js.global.request_params.from,
'to': wps_js.global.request_params.to
};
} else {
_params4 = {
'ago': 30
};
}

// Add Page ID and type
_params4 = Object.assign(_params4, {
'ID': wps_js.global.request_params.ID,
'type': wps_js.global.request_params.type
});

// Check page_id parameter
var page_id = null;
if (wps_js.isset(wps_js.global, 'request_params', 'page_id')) {
page_id = wps_js.global.request_params.page_id;
}

// Add page_id to Params
if (page_id !== null) {
_params4 = Object.assign(_params4, {
'page_id': page_id
});
}

// Run MetaBox
wps_js.run_meta_box('pages-chart', _params4, false);

// Set Select2 For List
if (wps_js.exist_tag("form#wp-statistics-select-pages")) {
wps_js.select2();
}

// Submit Change Page Select Form
jQuery(document).on('change', 'select[name=ID]', function () {
jQuery("span.submit-form").html(wps_js._('please_wait'));
jQuery(this).closest('form').trigger('submit');
});

// Display Top Browsers Chart
if (wps_js.exist_tag("div[data-top-browsers-chart='true']")) {
var browsersEl = jQuery("div[data-top-browsers-chart='true']");
// Get Names
var browserNames = jQuery(browsersEl).data('browsers-names');
// Get Values
var browserValues = jQuery(browsersEl).data('browsers-values');
// Get Background Color
var backgroundColor = [];
var color;
for (var i = 0; i <= 10; i++) {
color = wps_js.random_color(i);
backgroundColor.push('rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + '0.4)');
}
// Prepare Data
var data = [{
label: wps_js._('browsers'),
data: browserValues,
backgroundColor: backgroundColor
}];
// Add html after browsersEl
jQuery(browsersEl).after('<div class="o-wrap"><div class="c-chart c-chart--limited-height"><canvas id="' + wps_js.chart_id('browsers') + '" height="220"></canvas></div></div>');
// Remove browsersEl
jQuery(browsersEl).remove();
// Check Data
if (browserNames.length && browserValues.length) {
var label_callback = function label_callback(tooltipItem) {
return tooltipItem.label;
};
var title_callback = function title_callback(ctx) {
return wps_js._('visitors') + ':' + ctx[0].formattedValue;
};
// Show Chart
wps_js.pie_chart(wps_js.chart_id('browsers'), browserNames, data, label_callback, title_callback);
} else {
jQuery('#wp-statistics-browsers-widget').empty().html(wps_js.no_meta_box_data());
}
}

// Display Top Operating Systems Chart
if (wps_js.exist_tag("div[data-top-platforms-chart='true']")) {
var platformsEl = jQuery("div[data-top-platforms-chart='true']");
// Get Names
var platformsNames = jQuery(platformsEl).data('platforms-names');
// Get Values
var platformsValues = jQuery(platformsEl).data('platforms-values');
// Get Background Color
var _backgroundColor2 = [];
var _color;
for (var _i7 = 0; _i7 <= 10; _i7++) {
_color = wps_js.random_color(_i7);
_backgroundColor2.push('rgba(' + _color[0] + ',' + _color[1] + ',' + _color[2] + ',' + '0.4)');
}
// Prepare Data
var _data = [{
label: wps_js._('platforms'),
data: platformsValues,
backgroundColor: _backgroundColor2
}];
// Add html after browsersEl
jQuery(platformsEl).after('<div class="o-wrap"><div class="c-chart c-chart--limited-height"><canvas id="' + wps_js.chart_id('platforms') + '" height="220"></canvas></div></div>');
// Remove browsersEl
jQuery(platformsEl).remove();
// Check Data
if (platformsNames.length && platformsValues.length) {
// Show Chart
wps_js.pie_chart(wps_js.chart_id('platforms'), platformsNames, _data);
} else {
jQuery('#wp-statistics-platforms-widget').empty().html(wps_js.no_meta_box_data());
}
}

// Display Visitors Map
if (wps_js.exist_tag("div[data-visitors-map='true']")) {
var mapEl = jQuery("div[data-visitors-map='true']");
// Get Response
var args = jQuery(mapEl).data('response');
// Add html after mapEl
jQuery(mapEl).after('<div class="o-wrap"><div id="wp-statistics-visitors-map"></div></div>');
// Remove mapEl
jQuery(mapEl).remove();
// Prepare Data
var pin = Array();
if (args.hasOwnProperty('country')) {
Object.keys(args['country']).forEach(function (key) {
var t = "<div class='map-html-marker'><div class=\"map-country-header\"><img src='".concat(args['country'][key]['flag'], "' alt=\"").concat(args['country'][key]['name'], "\" title='").concat(args['country'][key]['name'], "' class='log-tools wps-flag'/> ").concat(args['country'][key]['name'], " (").concat(args['total_country'][key], ")</div>");

// Get List visitors
Object.keys(args['visitor'][key]).forEach(function (visitor_id) {
t += "<p><img src='".concat(args['visitor'][key][visitor_id]['browser']['logo'], "' alt=\"").concat(args['visitor'][key][visitor_id]['browser']['name'], "\" class='wps-flag log-tools' title='").concat(args['visitor'][key][visitor_id]['browser']['name'], "'/> ").concat(args['visitor'][key][visitor_id]['ip'], " ") + (["Unknown", "(Unknown)"].includes(args['visitor'][key][visitor_id]['city']) ? '' : '- ' + args['visitor'][key][visitor_id]['city']) + "</p>";
});
t += "</div>";
pin[key] = t;
});
jQuery('#wp-statistics-visitors-map').vectorMap({
map: 'world_en',
backgroundColor: '#fff',
borderColor: '#7e7e7e',
borderOpacity: 0.60,
color: '#e6e5e2',
selectedColor: '#9DA3F7',
hoverColor: '#404BF2',
colors: args['color'],
onLabelShow: function onLabelShow(element, label, code) {
if (pin[code] !== undefined) {
label.html(pin[code]);
} else {
label.html(label.html() + ' [0]<hr />');
}
}
});
} else {
jQuery('#wp-statistics-visitors-map-widget').empty().html(wps_js.no_meta_box_data());
}
}
} else {
// Create Params
var _params5 = {};

// Check Pagination
if (wps_js.isset(wps_js.global, 'request_params', 'pagination-page')) {
_params5['paged'] = wps_js.global.request_params['pagination-page'];
}

// Check Days ago or Between
if (wps_js.isset(wps_js.global, 'request_params', 'from') && wps_js.isset(wps_js.global, 'request_params', 'to')) {
_params5['from'] = wps_js.global.request_params.from;
_params5['to'] = wps_js.global.request_params.to;
} else {
_params5['ago'] = 30;
}

// Check Post Type
if (wps_js.isset(wps_js.global, 'request_params', 'type')) {
_params5['type'] = wps_js.global.request_params['type'];
}

// Run Pages list MetaBox
//wps_js.run_meta_box('pages', params, false);

// Run Top Pages chart Meta Box
wps_js.run_meta_box('top-pages-chart', _params5, false);
}
}
if (wps_js.isset(wps_js.global, 'request_params', 'page') && wps_js.global.request_params.page === "platform") {
// Check Params
var _params6 = {};

// Check Extra Parameter [Days ago or Between ..]
['from', 'to'].forEach(function (key) {
if (wps_js.isset(wps_js.global, 'request_params', key)) {
_params6[key] = wps_js.global.request_params[key];
}
});

// Set Equal Height
['platforms-table', 'platforms'].forEach(function (key) {
jQuery("#" + wps_js.getMetaBoxKey(key) + " .inside").css('height', '430px');
});

// Set Loading Table-List
jQuery("#wp-statistics-platforms-table-widget .inside").html(wps_js.placeholder());
jQuery(".wps-ph-picture").attr("style", "height: 310px;");

// Run Browsers Meta Box
wps_js.run_meta_box('platforms', _params6, false);
}
if (wps_js.isset(wps_js.global, 'request_params', 'page') && wps_js.global.request_params.page === "privacy-audit") {
var updateComplianceInfo = function updateComplianceInfo(complianceData) {
var privacyModeWrapper = jQuery('.wps-privacy-mode__items');
var headerPrivacyIndicator = jQuery('.wps-adminHeader .wps-adminHeader__side .privacy');
var complianceStatusWrapper = jQuery('.wps-privacy-status');

// Reset previous styles
privacyModeWrapper.find('.wps-privacy-mode__item').removeClass('loading');
complianceStatusWrapper.removeClass('loading success warning');
complianceStatusWrapper.find('.wps-privacy-status__bar-passed').css('display', 'none');
complianceStatusWrapper.find('.wps-privacy-status__bar-need-work').css('display', 'none');

// Update compliance status element with new data
complianceStatusWrapper.addClass(complianceData.percentage_ready == 100 ? 'success' : 'warning');
complianceStatusWrapper.find('.wps-privacy-status__percent-value').text(complianceData.percentage_ready);
complianceStatusWrapper.find('.wps-privacy-status__rules-mapped-value').text(complianceData.rules_mapped);
complianceStatusWrapper.find('.wps-privacy-status__passed-value').text(complianceData.summary.passed);
complianceStatusWrapper.find('.wps-privacy-status__need-work-value').text(complianceData.summary.action_required);

// Update elements that depend on action required audits 
if (complianceData.summary.action_required > 0) {
privacyModeWrapper.find('.wps-privacy-mode__item input:checked').next().find('.wps-privacy-mode__content').text(wps_js._('non_privacy_compliant'));
privacyModeWrapper.find('.wps-privacy-mode__item input:checked').parent().addClass('wps-privacy-mode__item--warning');
complianceStatusWrapper.find('.wps-privacy-status__bar-need-work').css('display', 'block');
complianceStatusWrapper.find('.wps-privacy-status__bar-need-work').css('width', "".concat(100 - complianceData.percentage_ready, "%"));
headerPrivacyIndicator.addClass('warning');
} else {
privacyModeWrapper.find('.wps-privacy-mode__item input:checked').next().find('.wps-privacy-mode__content').text(wps_js._('privacy_compliant'));
privacyModeWrapper.find('.wps-privacy-mode__item input:checked').parent().removeClass('wps-privacy-mode__item--warning');
headerPrivacyIndicator.removeClass('warning');
}

// Update elements that depend on passed audit
if (complianceData.summary.passed > 0) {
complianceStatusWrapper.find('.wps-privacy-status__bar-passed').css('display', 'block');
complianceStatusWrapper.find('.wps-privacy-status__bar-passed').css('width', "".concat(complianceData.percentage_ready, "%"));
}
};
var updateAuditElement = function updateAuditElement(element, data) {
// Update content
element.attr('class', "wps-privacy-list__item wps-privacy-list__item--".concat(data.status));
element.find('.wps-privacy-list__icon').attr('class', "wps-privacy-list__icon wps-privacy-list__icon--".concat(data.status));
element.find('.wps-privacy-list__button').attr('class', "wps-privacy-list__button wps-privacy-list__button--".concat(data.status));
element.find('.wps-privacy-list__text').html(data.title);
element.find('.wps-privacy-list__content').html(data.notes);

// Update action
if (data.hasOwnProperty('action')) {
element.find('.wps-privacy-list__button').attr('class', "wps-privacy-list__button wps-privacy-list__button--".concat(data.action.key));
element.find('.wps-privacy-list__button').attr('data-action', data.action.key);
element.find('.wps-privacy-list__button').data('action', data.action.key);
element.find('.wps-privacy-list__button').text(data.action.value);
}
};
var loadAudits = function loadAudits(auditList) {
var privacyItemsWrapper = jQuery('.wps-privacy-list .wps-privacy-list__items');
privacyItemsWrapper.html('');
privacyItemsWrapper.removeClass('loading');
auditList.forEach(function (auditData) {
var auditElement = generateAuditElement(auditData);
privacyItemsWrapper.append(auditElement);
});
};
var generateAuditElement = function generateAuditElement(data) {
var actionData = '';
var buttonClass = data.status;
var buttonTitle = data.compliance.value;

// If item has action, set proper data attribute
if (data.hasOwnProperty('action')) {
actionData += "data-audit=\"".concat(data.name, "\" data-action=\"").concat(data.action.key, "\"");
buttonClass = data.action.key;
buttonTitle = data.action.value;
}
var auditElement = "<div id=\"".concat(data.name, "\" class=\"wps-privacy-list__item wps-privacy-list__item--").concat(data.status, "\"><div class=\"wps-privacy-list__title\"><div><span class=\"wps-privacy-list__icon wps-privacy-list__icon--").concat(data.status, "\"></span><span class=\"wps-privacy-list__text\">").concat(data.title, "</span></div><a ").concat(actionData, " class=\"wps-privacy-list__button wps-privacy-list__button--").concat(buttonClass, "\">").concat(buttonTitle, "</a></div><div class=\"wps-privacy-list__content\">").concat(data.notes, "</div></div>");
return auditElement;
};
var loadFaqs = function loadFaqs(faqList) {
var faqWrapper = jQuery('.wps-privacy-questions .wps-privacy-list__items');
faqWrapper.html('');
faqWrapper.removeClass('loading');
faqList.forEach(function (faqData) {
var faqElement = generateFaqElement(faqData);
faqWrapper.append(faqElement);
});
};
var generateFaqElement = function generateFaqElement(data) {
var faqElement = "<div class=\"wps-privacy-list__item wps-privacy-list__item--".concat(data.status, "\"><div class=\"wps-privacy-list__title\"><span class=\"wps-privacy-list__icon wps-privacy-list__icon--").concat(data.status, "\"></span><div><span>").concat(data.title, "</span><span>").concat(data.summary, "</span></div></div><div class=\"wps-privacy-list__content\">").concat(data.notes, "</div></div>");
return faqElement;
};
jQuery(document).ready(function () {
var params = {
'wps_nonce': wps_js.global.rest_api_nonce,
'action': 'wp_statistics_getPrivacyStatus'
};
params = Object.assign(params, wps_js.global.request_params);
jQuery.ajax({
url: wps_js.global.admin_url + 'admin-ajax.php',
type: 'GET',
dataType: 'json',
data: params,
timeout: 30000,
success: function success(_ref) {
var data = _ref.data,
_success = _ref.success;
// If request is not successful, return early
if (_success == false) return console.log(data);

// Update compliance information
updateComplianceInfo(data.compliance_status);

// Append audit items to the page.
loadAudits(data.audit_list);

// Append faq items to the page.
loadFaqs(data.faq_list);
},
error: function error(xhr, status, _error2) {
console.log(_error2);
}
});
});
jQuery(document).on('click', '.wps-privacy-list__button[data-action]', function (e) {
var button = jQuery(e.currentTarget);
var auditName = button.data('audit');
var auditAction = button.data('action');
var auditElement = jQuery('#' + auditName);

// Do not proceed if button is in loading state
if (button.hasClass('loading')) return;

// Show alert message when user tries to resolve the audit
if (auditAction === 'resolve') {
alert(wps_js._('privacy_resolve_alert'));
}

// Add loading class
button.addClass('loading');
jQuery('.wps-privacy-questions .wps-privacy-list__items').addClass('loading');
jQuery('.wps-privacy-mode__items .wps-privacy-mode__item').addClass('loading');
jQuery('.wps-privacy-status').addClass('loading');
var params = {
'wps_nonce': wps_js.global.rest_api_nonce,
'action': 'wp_statistics_updatePrivacyStatus',
'audit_name': auditName,
'audit_action': auditAction
};
params = Object.assign(params, wps_js.global.request_params);
jQuery.ajax({
url: wps_js.global.admin_url + 'admin-ajax.php',
type: 'POST',
dataType: 'json',
data: params,
timeout: 30000,
success: function success(_ref2) {
var data = _ref2.data,
_success2 = _ref2.success;
// If request is not successful, return early
if (_success2 == false) return console.log(data);

// Remove loading
button.removeClass('loading');

// Update compliance data
updateComplianceInfo(data.compliance_status);

// Load faq items
loadFaqs(data.faq_list);

// If audit item data is not null, update it with new data
if (data.audit_item) {
updateAuditElement(auditElement, data.audit_item);
}
},
error: function error(xhr, status, _error3) {
console.log(_error3);
}
});
});
}
if (wps_js.isset(wps_js.global, 'request_params', 'page') && wps_js.global.request_params.page === "searches") {
// Create Params
var _params7;

// Check Days ago or Between
if (wps_js.isset(wps_js.global, 'request_params', 'from') && wps_js.isset(wps_js.global, 'request_params', 'to')) {
_params7 = {
'from': wps_js.global.request_params.from,
'to': wps_js.global.request_params.to
};
} else {
_params7 = {
'ago': 30
};
}

// Run MetaBox
wps_js.run_meta_box('search', _params7, false);
}
/**
 * Get Parameter value
 *
 * @param name
 * @returns {*}
 */
function wp_statistics_getParameterValue(name) {
var results = new RegExp('[\?&]' + name + '=([^&#]*)').exec(window.location.href);
if (results) {
return results[1];
}
}

/**
 * Enable Tab
 *
 * @param tab_id
 */
function wp_statistics_enableTab(tab_id) {
jQuery('.wp-statistics-settings .wps-optionsMenu .wps-optionsMenuItem').removeClass('current');
jQuery('.wp-statistics-settings .tab-content').removeClass('current');
jQuery("[data-tab=" + tab_id + "]").addClass('current');
jQuery("#" + tab_id).addClass('current');
if (jQuery('#wp-statistics-settings-form').length) {
var click_url = jQuery(location).attr('href') + '&tab=' + tab_id;
jQuery('#wp-statistics-settings-form').attr('action', click_url).submit();
}
}

/**
 * Check has setting page
 */
if (jQuery('.wp-statistics-settings').length) {
var current_tab = wp_statistics_getParameterValue('tab');
if (current_tab) {
wp_statistics_enableTab(current_tab);
}
jQuery('.wp-statistics-settings .wps-optionsMenu .wps-optionsMenuItem').click(function () {
var tab_id = jQuery(this).attr('data-tab');
wp_statistics_enableTab(tab_id);
});
}

// Check the Condition Require Setting Api
function wp_statistics_check_condition_view_option(selector, field) {
jQuery(document).on("change", selector, function (e) {
e.preventDefault();
var option_field = jQuery(field);
if (this.checked) {
option_field.show("slow");
} else {
option_field.hide("slow");
option_field.find("input[type=checkbox]").prop('checked', false);
}
});
}

// Check the visitor log is checked
wp_statistics_check_condition_view_option("input[name=wps_visitors]", "tr[data-view=visitors_log_tr]");

// Check the Spam List
wp_statistics_check_condition_view_option("input[name=wps_referrerspam]", "tr.referrerspam_field");
if (wps_js.isset(wps_js.global, 'request_params', 'page') && wps_js.global.request_params.page === "settings") {
// Set Active Tab
jQuery('#wp-statistics-settings-form ul.tabs li').click(function (e) {
e.preventDefault();
var _tab = $(this).attr('data-tab');
if (typeof localStorage != 'undefined') {
localStorage.setItem("wp-statistics-settings-active-tab", _tab);
}
});

// Set Current Tab
if (typeof localStorage != 'undefined' && wps_js.isset(wps_js.global, 'request_params', 'save_setting') && wps_js.global.request_params.save_setting === "yes") {
var ActiveTab = localStorage.getItem("wp-statistics-settings-active-tab");
if (ActiveTab && ActiveTab.length > 0) {
$('#wp-statistics-settings-form ul.tabs li[data-tab=' + ActiveTab + ']').click();
}
}
}
if (wps_js.isset(wps_js.global, 'request_params', 'page') && wps_js.global.request_params.page === "taxonomies") {
// Create Params
var _params8 = {
'ago': 0,
'type': wps_js.global.request_params.taxonomy,
'ID': 0
};

// Check Extra Parameter [Days ago or Between ..]
['from', 'to', 'ID'].forEach(function (key) {
if (wps_js.isset(wps_js.global, 'request_params', key)) {
_params8[key] = wps_js.global.request_params[key];
}
});

// Set PlaceHolder For Total
jQuery("span[id^='number-total-']").html(wps_js.rectangle_placeholder('wps-text-placeholder'));

// Run Meta Box
wps_js.run_meta_box('pages-chart', _params8, false);
}
if (wps_js.isset(wps_js.global, 'request_params', 'page') && wps_js.global.request_params.page === "visitors") {
// Show Filter form
var wp_statistics_show_visitors_filter = function wp_statistics_show_visitors_filter(tickBox_DIV, data) {
// Create Table
var html = '<table class="o-table">';

// Show List Select
var select = {
/**
 * Key: global i18n
 * [0]: select name
 * [1]: data key from ajax
 */
'browsers': ['agent', 'browsers'],
'country': ['location', 'location'],
'platform': ['platform', 'platform'],
'referrer': ['referrer', 'referrer'],
'user': ['user_id', 'users']
};
Object.keys(select).forEach(function (key) {
html += "<tr><td>".concat(wps_js._(key), "</td></tr>");
html += "<tr><td><select name=\"".concat(select[key][0], "\" class=\"select2 wps-width-100\" data-type-show=\"select2\">");
html += "<option value=''>".concat(wps_js._('all'), "</option>");
var current_value = wps_js.getLinkParams(select[key][0]);
Object.keys(data[select[key][1]]).forEach(function (item) {
html += "<option value='".concat(item, "' ").concat(current_value != null && current_value == item ? "selected" : "", ">").concat(data[select[key][1]][item], "</option>");
});
html += "</select></td></tr>";
});

// Add IP
html += "<tr><td>".concat(wps_js._('ip'), "</td></tr>");
html += "<tr><td><input name=\"ip\" value=\"".concat(wps_js.getLinkParams('ip') != null ? decodeURIComponent(wps_js.getLinkParams('ip')) : "", "\" class=\"wps-width-100\" placeholder='xxx.xxx.xxx.xxx' autocomplete=\"off\"></td></tr>");

// Add Date
html += "<tr><td>".concat(wps_js._('date'), "</td></tr>");
var input_date_style = 'width: calc(50% - 5px);display: inline-block;';
html += "<tr><td><div style=\"".concat(input_date_style, "\">").concat(wps_js._('from'), ": <input name=\"date-from\" class=\"modal-input\" data-wps-date-picker=\"from\" value=\"").concat(wps_js.getLinkParams('from') != null ? wps_js.getLinkParams('from') : "", "\" style=\"width: calc(100% - 5px);\" placeholder=\"YYYY-MM-DD\" autocomplete=\"off\"></div><div style=\"").concat(input_date_style, "\">").concat(wps_js._('to'), ": <input name=\"date-to\" class=\"modal-input\" data-wps-date-picker=\"to\" value=\"").concat(wps_js.getLinkParams('to') != null ? wps_js.getLinkParams('to') : "", "\" style=\"width: 100%;\" placeholder=\"YYYY-MM-DD\" autocomplete=\"off\"></div><input type=\"hidden\" name=\"from\" id=\"date-from\" class=\"modal-input\" value=\"").concat(wps_js.getLinkParams('from') != null ? wps_js.getLinkParams('from') : "", "\"><input type=\"hidden\" name=\"to\" id=\"date-to\" class=\"modal-input\" value=\"").concat(wps_js.getLinkParams('to') != null ? wps_js.getLinkParams('to') : "", "\"></td></tr>");

// Submit Button
html += "<tr><td></td></tr>";
html += "<tr><td><input type=\"submit\" value=\"".concat(wps_js._('filter'), "\" class=\"button-primary\"> &nbsp; <span class=\"filter-loading\"></span></td></tr>");
html += "</table>";
jQuery(tickBox_DIV).html(html);

// Set datePicker and Select 2
setTimeout(function () {
jQuery(FORM_ID + " input[data-wps-date-picker]").on('change', function () {
var dateType = jQuery(this).attr('data-wps-date-picker');
jQuery(FORM_ID + " input[name=" + dateType + "]").val(jQuery(this).val());
});
wps_js.date_picker();
wps_js.select2();
}, 500);
};
// TickBox
jQuery(document).on('click', "div#visitors-filter", function (e) {
e.preventDefault();

// Show
tb_show('', '#TB_inline?&width=430&height=615&inlineId=visitors-filter-popup');

// Add Content
setTimeout(function () {
var tickBox_DIV = "#wps-visitors-filter-form";
if (!wps_js.exist_tag(tickBox_DIV + " input[type=submit]")) {
// Set PlaceHolder
jQuery(tickBox_DIV).html('<div style="height: 50px;"></div>' + wps_js.line_placeholder(5));

// Check Use Cached Data
var filter_data = localStorage.getItem('wp-statistics-visitors-filter') ? JSON.parse(localStorage.getItem('wp-statistics-visitors-filter')) : {};
if (!wps_js.isset(filter_data, 'timestamp') || !wps_js.isset(filter_data, 'value') || wps_js.isset(filter_data, 'timestamp') && wps_js.isset(filter_data, 'value') && new Date().getTime().toString() > parseInt(filter_data.timestamp)) {
// Create Params
var _params9 = {
'wps_nonce': wps_js.global.rest_api_nonce,
'action': 'wp_statistics_visitors_page_filters'
};
_params9 = Object.assign(_params9, wps_js.global.request_params);

// Create Ajax
jQuery.ajax({
url: wps_js.global.admin_url + 'admin-ajax.php',
type: 'GET',
dataType: "json",
data: _params9,
timeout: 30000,
success: function success(data) {
// Load function
wp_statistics_show_visitors_filter(tickBox_DIV, data);
},
error: function error(xhr, status, _error4) {
jQuery("span.tb-close-icon").click();
}
});
} else {
wp_statistics_show_visitors_filter(tickBox_DIV, filter_data['value']);
}
}
}, 500);
});

// submit and disable empty value
var FORM_ID = '#wp_statistics_visitors_filter_form';
jQuery(document).on('submit', FORM_ID, function () {
//Validate DatePicker
var FROM_DATE = jQuery(FORM_ID + " input[name=date-from]");
var TO_DATE = jQuery(FORM_ID + " input[name=date-to]");
if (FROM_DATE.val().length > 0 && TO_DATE.val().length < 1 || FROM_DATE.val().length < 1 && TO_DATE.val().length > 1) {
alert(wps_js._('er_datepicker'));
return false;
}

// Check IS IP
var Input_IP = jQuery(FORM_ID + " input[name=ip]").val();
if (Input_IP.length > 0 && Input_IP.includes('#hash#') === false && wps_js.isIP(Input_IP) === false) {
alert(wps_js._('er_valid_ip'));
return false;
}

// Disable DatePicker
jQuery("input[data-wps-date-picker]").prop('disabled', true);

// Remove Empty Parameter
var forms = {
'input': ['date-from', 'date-to', 'ip'],
'select': ['agent', 'platform', 'location', 'referrer', 'user_id']
};
Object.keys(forms).forEach(function (type) {
forms[type].forEach(function (name) {
var input = jQuery(FORM_ID + " " + type + "[name=" + name + "]");
if (input.val().length < 1) {
input.prop('disabled', true);
['from', 'to'].forEach(function (key) {
if (name == "date-" + key) {
jQuery(FORM_ID + " input[name=" + key + "]").prop('disabled', true);
}
});
}
});
});

// Set Order
var order = wps_js.getLinkParams('order');
if (order != null) {
jQuery(this).append('<input type="hidden" name="order" value="' + order + '" /> ');
}

// Show Loading
jQuery("span.filter-loading").html(wps_js._('please_wait'));
return true;
});
}

// When close TickBox
//jQuery(window).bind('tb_unload', function () {});

// Welcome Page Script
// Load Jquery Date Picker in WP Statistics Admin
wps_js.date_picker();

// Run Meta Box [Overview Or Dashboard]
if (wps_js.global.page.file === "index.php" || wps_js.is_active('overview_page') || wps_js.global.page.file === "post-new.php" || wps_js.global.page.file === "post.php" && wps_js.isset(wps_js.global, 'page', 'ID')) {
wps_js.run_meta_boxes();
}
jQuery(document).ready(function ($) {
// WP 3.5+ uploader
var file_frame;
$(document.body).on('click', '.wps_img_settings_upload_button', function (e) {
e.preventDefault();
var button = $(this);

// If the media frame already exists, reopen it.
if (file_frame) {
//file_frame.uploader.uploader.param( 'post_id', set_to_post_id );
file_frame.open();
return;
}

// Create the media frame.
file_frame = wp.media.frames.file_frame = wp.media({
frame: 'post',
state: 'insert',
library: {
type: ['image']
},
multiple: false
});
file_frame.on('menu:render:default', function (view) {
// Store our views in an object.
var views = {};

// Unset default menu items
view.unset('library-separator');
view.unset('gallery');
view.unset('featured-image');
view.unset('embed');
view.unset('playlist');
view.unset('video-playlist');

// Initialize the views in our view object.
view.set(views);
});

// When an image is selected, run a callback.
file_frame.on('insert', function () {
var selection = file_frame.state().get('selection');
selection.each(function (attachment, index) {
attachment = attachment.toJSON();
button.parent().parent().find('input[type="text"]').val(attachment.url);
button.parent().parent().parent().find('#wps-upload-image-preview').attr('src', attachment.url);
button.parent().parent().find('.wps_img_settings_clear_upload_button').show();
});
});

// Finally, open the modal
file_frame.open();
});
$(document.body).on('click', '.wps_img_settings_clear_upload_button', function (e) {
e.preventDefault();
$(this).parent().prev().val('');
$('#wps-upload-image-preview').attr('src', wps_ar_vars.default_avatar_url);
$('.wps_img_settings_clear_upload_button').hide();
});
});
});